// Code generated by protoc-gen-go-plain. DO NOT EDIT.

package enum_dispatched

import (
	json "encoding/json"
	jx "github.com/go-faster/jx"
	protojson "google.golang.org/protobuf/encoding/protojson"
)

type PaymentPlain_MethodType int32

const (
	PaymentPlain_METHOD_TYPE_UNSPECIFIED PaymentPlain_MethodType = 0
	PaymentPlain_METHOD_TYPE_CARD        PaymentPlain_MethodType = 1
	PaymentPlain_METHOD_TYPE_CRYPTO      PaymentPlain_MethodType = 2
)

type PaymentPlain_BackupMethodType int32

const (
	PaymentPlain_BACKUP_METHOD_TYPE_UNSPECIFIED   PaymentPlain_BackupMethodType = 0
	PaymentPlain_BACKUP_METHOD_TYPE_BACKUP_CARD   PaymentPlain_BackupMethodType = 1
	PaymentPlain_BACKUP_METHOD_TYPE_BACKUP_CRYPTO PaymentPlain_BackupMethodType = 2
)

type PaymentPlain struct {

	// src: <virtual>; transform: virtual
	MethodType PaymentPlain_MethodType
	// src: .test.enum_dispatched.Payment.card; transform: oneof
	Card *PaymentCard
	// src: .test.enum_dispatched.Payment.crypto; transform: oneof
	Crypto *PaymentCrypto
	// src: <virtual>; transform: virtual
	BackupMethodBackupMethodType PaymentPlain_BackupMethodType
	// src: .test.enum_dispatched.Payment.backup_card; transform: oneof
	BackupMethodBackupCard *PaymentCard
	// src: .test.enum_dispatched.Payment.backup_crypto; transform: oneof
	BackupMethodBackupCrypto *PaymentCrypto
}

const enumFull_TestEnumDispatchedMethodType = "test.enum_dispatched.MethodType"

func (m *Payment) IntoPlain() *PaymentPlain {
	if m == nil {
		return nil
	}
	var oneof_card *PaymentCard
	var oneof_crypto *PaymentCrypto
	switch x := m.GetMethod().(type) {
	case *Payment_Card:
		oneof_card = x.Card
	case *Payment_Crypto:
		oneof_crypto = x.Crypto
	}
	var oneof_backupMethodBackupCard *PaymentCard
	var oneof_backupMethodBackupCrypto *PaymentCrypto
	switch x := m.GetBackupMethod().(type) {
	case *Payment_BackupCard:
		oneof_backupMethodBackupCard = x.BackupCard
	case *Payment_BackupCrypto:
		oneof_backupMethodBackupCrypto = x.BackupCrypto
	}
	return &PaymentPlain{
		Card:                     oneof_card,
		Crypto:                   oneof_crypto,
		BackupMethodBackupCard:   oneof_backupMethodBackupCard,
		BackupMethodBackupCrypto: oneof_backupMethodBackupCrypto,
	}
}

func (m *Payment) IntoPlainErr() (*PaymentPlain, error) {
	if m == nil {
		return nil, nil
	}
	var oneof_card *PaymentCard
	var oneof_crypto *PaymentCrypto
	switch x := m.GetMethod().(type) {
	case *Payment_Card:
		oneof_card = x.Card
	case *Payment_Crypto:
		oneof_crypto = x.Crypto
	}
	var oneof_backupMethodBackupCard *PaymentCard
	var oneof_backupMethodBackupCrypto *PaymentCrypto
	switch x := m.GetBackupMethod().(type) {
	case *Payment_BackupCard:
		oneof_backupMethodBackupCard = x.BackupCard
	case *Payment_BackupCrypto:
		oneof_backupMethodBackupCrypto = x.BackupCrypto
	}
	return &PaymentPlain{
		Card:                     oneof_card,
		Crypto:                   oneof_crypto,
		BackupMethodBackupCard:   oneof_backupMethodBackupCard,
		BackupMethodBackupCrypto: oneof_backupMethodBackupCrypto,
	}, nil
}

func (m *PaymentPlain) IntoPb() *Payment {
	if m == nil {
		return nil
	}
	var oneof_method isPayment_Method
	if m.Card != nil {
		oneof_method = &Payment_Card{Card: m.Card}
	}
	if m.Crypto != nil {
		oneof_method = &Payment_Crypto{Crypto: m.Crypto}
	}
	var oneof_backupMethod isPayment_BackupMethod
	if m.BackupMethodBackupCard != nil {
		oneof_backupMethod = &Payment_BackupCard{BackupCard: m.BackupMethodBackupCard}
	}
	if m.BackupMethodBackupCrypto != nil {
		oneof_backupMethod = &Payment_BackupCrypto{BackupCrypto: m.BackupMethodBackupCrypto}
	}
	return &Payment{
		BackupMethod: oneof_backupMethod,
		Method:       oneof_method,
	}
}

func (m *PaymentPlain) IntoPbErr() (*Payment, error) {
	if m == nil {
		return nil, nil
	}
	var oneof_method isPayment_Method
	if m.Card != nil {
		oneof_method = &Payment_Card{Card: m.Card}
	}
	if m.Crypto != nil {
		oneof_method = &Payment_Crypto{Crypto: m.Crypto}
	}
	var oneof_backupMethod isPayment_BackupMethod
	if m.BackupMethodBackupCard != nil {
		oneof_backupMethod = &Payment_BackupCard{BackupCard: m.BackupMethodBackupCard}
	}
	if m.BackupMethodBackupCrypto != nil {
		oneof_backupMethod = &Payment_BackupCrypto{BackupCrypto: m.BackupMethodBackupCrypto}
	}
	return &Payment{
		Method:       oneof_method,
		BackupMethod: oneof_backupMethod,
	}, nil
}

func (m *PaymentPlain) MarshalJSON() ([]byte, error) {
	if m == nil {
		return []byte("null"), nil
	}
	_ = protojson.Marshal
	_ = json.Marshal
	var e jx.Encoder
	e.ObjStart()
	e.FieldStart("methodType")
	e.Int32(int32(m.MethodType))
	e.FieldStart("card")
	if m.Card == nil {
		e.Null()
	} else {
		if b, err := protojson.Marshal(m.Card); err != nil {
			return nil, err
		} else {
			e.Raw(b)
		}
	}
	e.FieldStart("crypto")
	if m.Crypto == nil {
		e.Null()
	} else {
		if b, err := protojson.Marshal(m.Crypto); err != nil {
			return nil, err
		} else {
			e.Raw(b)
		}
	}
	e.FieldStart("backupMethodBackupMethodType")
	e.Int32(int32(m.BackupMethodBackupMethodType))
	e.FieldStart("backupMethodBackupCard")
	if m.BackupMethodBackupCard == nil {
		e.Null()
	} else {
		if b, err := protojson.Marshal(m.BackupMethodBackupCard); err != nil {
			return nil, err
		} else {
			e.Raw(b)
		}
	}
	e.FieldStart("backupMethodBackupCrypto")
	if m.BackupMethodBackupCrypto == nil {
		e.Null()
	} else {
		if b, err := protojson.Marshal(m.BackupMethodBackupCrypto); err != nil {
			return nil, err
		} else {
			e.Raw(b)
		}
	}
	e.ObjEnd()
	return e.Bytes(), nil
}

func (m *PaymentPlain) UnmarshalJSON(data []byte) error {
	if m == nil {
		return nil
	}
	_ = protojson.Unmarshal
	_ = json.Unmarshal
	d := jx.DecodeBytes(data)
	return d.Obj(func(d *jx.Decoder, key string) error {
		switch key {
		case "methodType":
			v, err := d.Int32()
			if err != nil {
				return err
			}
			m.MethodType = PaymentPlain_MethodType(v)
			return nil
		case "card":
			raw, err := d.Raw()
			if err != nil {
				return err
			}
			if string(raw) == "null" {
				m.Card = nil
				return nil
			}
			v := &PaymentCard{}
			if err := protojson.Unmarshal(raw, v); err != nil {
				return err
			}
			m.Card = v
			return nil
		case "crypto":
			raw, err := d.Raw()
			if err != nil {
				return err
			}
			if string(raw) == "null" {
				m.Crypto = nil
				return nil
			}
			v := &PaymentCrypto{}
			if err := protojson.Unmarshal(raw, v); err != nil {
				return err
			}
			m.Crypto = v
			return nil
		case "backupMethodBackupMethodType":
			v, err := d.Int32()
			if err != nil {
				return err
			}
			m.BackupMethodBackupMethodType = PaymentPlain_BackupMethodType(v)
			return nil
		case "backupMethodBackupCard":
			raw, err := d.Raw()
			if err != nil {
				return err
			}
			if string(raw) == "null" {
				m.BackupMethodBackupCard = nil
				return nil
			}
			v := &PaymentCard{}
			if err := protojson.Unmarshal(raw, v); err != nil {
				return err
			}
			m.BackupMethodBackupCard = v
			return nil
		case "backupMethodBackupCrypto":
			raw, err := d.Raw()
			if err != nil {
				return err
			}
			if string(raw) == "null" {
				m.BackupMethodBackupCrypto = nil
				return nil
			}
			v := &PaymentCrypto{}
			if err := protojson.Unmarshal(raw, v); err != nil {
				return err
			}
			m.BackupMethodBackupCrypto = v
			return nil
		default:
			return d.Skip()
		}
	})
}
