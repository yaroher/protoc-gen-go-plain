// Code generated by protoc-gen-go-plain. DO NOT EDIT.

package embed

import (
	json "encoding/json"
	jx "github.com/go-faster/jx"
	protojson "google.golang.org/protobuf/encoding/protojson"
)

type UserPlain struct {

	// src: .test.embed.User.name; transform: none
	Name string
	// src: .test.embed.User.email; transform: oneof
	Email string
	// src: .test.embed.User.phone; transform: oneof
	Phone string
}

func (m *User) IntoPlain() *UserPlain {
	if m == nil {
		return nil
	}
	var oneof_email string
	var oneof_phone string
	switch x := m.GetContact().(type) {
	case *User_Email:
		oneof_email = x.Email
	case *User_Phone:
		oneof_phone = x.Phone
	}
	return &UserPlain{
		Name:  m.GetName(),
		Email: oneof_email,
		Phone: oneof_phone,
	}
}

func (m *User) IntoPlainErr() (*UserPlain, error) {
	if m == nil {
		return nil, nil
	}
	var oneof_email string
	var oneof_phone string
	switch x := m.GetContact().(type) {
	case *User_Email:
		oneof_email = x.Email
	case *User_Phone:
		oneof_phone = x.Phone
	}
	return &UserPlain{
		Name:  m.GetName(),
		Email: oneof_email,
		Phone: oneof_phone,
	}, nil
}

func (m *UserPlain) IntoPb() *User {
	if m == nil {
		return nil
	}
	var oneof_contact isUser_Contact
	if m.Email != "" {
		oneof_contact = &User_Email{Email: m.Email}
	}
	if m.Phone != "" {
		oneof_contact = &User_Phone{Phone: m.Phone}
	}
	return &User{
		Name:    m.Name,
		Contact: oneof_contact,
	}
}

func (m *UserPlain) IntoPbErr() (*User, error) {
	if m == nil {
		return nil, nil
	}
	var oneof_contact isUser_Contact
	if m.Email != "" {
		oneof_contact = &User_Email{Email: m.Email}
	}
	if m.Phone != "" {
		oneof_contact = &User_Phone{Phone: m.Phone}
	}
	return &User{
		Name:    m.Name,
		Contact: oneof_contact,
	}, nil
}

func (m *UserPlain) MarshalJSON() ([]byte, error) {
	if m == nil {
		return []byte("null"), nil
	}
	_ = protojson.Marshal
	_ = json.Marshal
	var e jx.Encoder
	e.ObjStart()
	e.FieldStart("name")
	e.Str(m.Name)
	e.FieldStart("email")
	e.Str(m.Email)
	e.FieldStart("phone")
	e.Str(m.Phone)
	e.ObjEnd()
	return e.Bytes(), nil
}

func (m *UserPlain) UnmarshalJSON(data []byte) error {
	if m == nil {
		return nil
	}
	_ = protojson.Unmarshal
	_ = json.Unmarshal
	d := jx.DecodeBytes(data)
	return d.Obj(func(d *jx.Decoder, key string) error {
		switch key {
		case "name":
			v, err := d.Str()
			if err != nil {
				return err
			}
			m.Name = v
			return nil
		case "email":
			v, err := d.Str()
			if err != nil {
				return err
			}
			m.Email = v
			return nil
		case "phone":
			v, err := d.Str()
			if err != nil {
				return err
			}
			m.Phone = v
			return nil
		default:
			return d.Skip()
		}
	})
}

type UserWrapperPlain struct {

	// src: .test.embed.UserWrapper.user; transform: none
	User *UserPlain
}

func (m *UserWrapper) IntoPlain() *UserWrapperPlain {
	if m == nil {
		return nil
	}
	return &UserWrapperPlain{
		User: func() *UserPlain {
			v := m.GetUser()
			if v == nil {
				return nil
			}
			return v.IntoPlain()
		}(),
	}
}

func (m *UserWrapper) IntoPlainErr() (*UserWrapperPlain, error) {
	if m == nil {
		return nil, nil
	}
	return &UserWrapperPlain{
		User: func() *UserPlain {
			v := m.GetUser()
			if v == nil {
				return nil
			}
			return v.IntoPlain()
		}(),
	}, nil
}

func (m *UserWrapperPlain) IntoPb() *UserWrapper {
	if m == nil {
		return nil
	}
	return &UserWrapper{
		User: func() *User {
			if m.User == nil {
				return nil
			}
			return m.User.IntoPb()
		}(),
	}
}

func (m *UserWrapperPlain) IntoPbErr() (*UserWrapper, error) {
	if m == nil {
		return nil, nil
	}
	return &UserWrapper{
		User: func() *User {
			if m.User == nil {
				return nil
			}
			return m.User.IntoPb()
		}(),
	}, nil
}

func (m *UserWrapperPlain) MarshalJSON() ([]byte, error) {
	if m == nil {
		return []byte("null"), nil
	}
	_ = protojson.Marshal
	_ = json.Marshal
	var e jx.Encoder
	e.ObjStart()
	e.FieldStart("user")
	if m.User == nil {
		e.Null()
	} else {
		if b, err := protojson.Marshal(m.User.IntoPb()); err != nil {
			return nil, err
		} else {
			e.Raw(b)
		}
	}
	e.ObjEnd()
	return e.Bytes(), nil
}

func (m *UserWrapperPlain) UnmarshalJSON(data []byte) error {
	if m == nil {
		return nil
	}
	_ = protojson.Unmarshal
	_ = json.Unmarshal
	d := jx.DecodeBytes(data)
	return d.Obj(func(d *jx.Decoder, key string) error {
		switch key {
		case "user":
			raw, err := d.Raw()
			if err != nil {
				return err
			}
			if string(raw) == "null" {
				m.User = nil
				return nil
			}
			pb := &User{}
			if err := protojson.Unmarshal(raw, pb); err != nil {
				return err
			}
			m.User = pb.IntoPlain()
			return nil
		default:
			return d.Skip()
		}
	})
}
