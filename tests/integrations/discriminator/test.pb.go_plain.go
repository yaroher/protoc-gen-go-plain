// Code generated by protoc-gen-go-plain. DO NOT EDIT.

package discriminator

import (
	fmt "fmt"
	oneoff "github.com/yaroher/protoc-gen-go-plain/oneoff"
)

type UserPlain struct {

	// src: .test.discriminator.User.contact_kind; transform: none
	ContactKind ContactKind
	// src: .test.discriminator.User.id_kind; transform: none
	IdKind IdKind
	// src: <virtual>; transform: virtual|override_type
	ContactDisc oneoff.EnumDiscriminator
	// src: .test.discriminator.User.email; transform: oneof
	Email *Email
	// src: .test.discriminator.User.phone; transform: oneof
	Phone *Phone
	// src: <virtual>; transform: virtual|override_type
	IdentityDisc oneoff.EnumDiscriminator
	// src: .test.discriminator.User.user_id; transform: oneof
	UserId *UserId
}

func (m *User) IntoPlain() *UserPlain {
	if m == nil {
		return nil
	}
	var disc_contactDisc oneoff.EnumDiscriminator
	var oneof_email *Email
	var oneof_phone *Phone
	switch x := m.GetContact().(type) {
	case *User_Email:
		oneof_email = x.Email
	case *User_Phone:
		oneof_phone = x.Phone
	}
	var disc_identityDisc oneoff.EnumDiscriminator
	var oneof_userId *UserId
	switch x := m.GetIdentity().(type) {
	case *User_UserId:
		oneof_userId = x.UserId
	}
	return &UserPlain{
		ContactKind:  m.GetContactKind(),
		IdKind:       m.GetIdKind(),
		ContactDisc:  disc_contactDisc,
		Email:        oneof_email,
		Phone:        oneof_phone,
		IdentityDisc: disc_identityDisc,
		UserId:       oneof_userId,
	}
}

func (m *User) IntoPlainErr() (*UserPlain, error) {
	if m == nil {
		return nil, nil
	}
	var disc_contactDisc oneoff.EnumDiscriminator
	var oneof_email *Email
	var oneof_phone *Phone
	var matched_contact bool
	switch x := m.GetContact().(type) {
	case *User_Email:
		oneof_email = x.Email
	case *User_Phone:
		oneof_phone = x.Phone
	}
	var disc_identityDisc oneoff.EnumDiscriminator
	var oneof_userId *UserId
	var matched_identity bool
	switch x := m.GetIdentity().(type) {
	case *User_UserId:
		oneof_userId = x.UserId
	}
	if m.GetContact() != nil && !matched_contact {
		return nil, fmt.Errorf("oneof %s discriminator mismatch", "Contact")
	}
	if m.GetIdentity() != nil && !matched_identity {
		return nil, fmt.Errorf("oneof %s discriminator mismatch", "Identity")
	}
	return &UserPlain{
		ContactKind:  m.GetContactKind(),
		IdKind:       m.GetIdKind(),
		ContactDisc:  disc_contactDisc,
		Email:        oneof_email,
		Phone:        oneof_phone,
		IdentityDisc: disc_identityDisc,
		UserId:       oneof_userId,
	}, nil
}

func (m *UserPlain) IntoPb() *User {
	if m == nil {
		return nil
	}
	var oneof_contact isUser_Contact
	if m.Email != nil {
		oneof_contact = &User_Email{Email: m.Email}
	}
	if m.Phone != nil {
		oneof_contact = &User_Phone{Phone: m.Phone}
	}
	var oneof_identity isUser_Identity
	if m.UserId != nil {
		oneof_identity = &User_UserId{UserId: m.UserId}
	}
	return &User{
		ContactKind: m.ContactKind,
		IdKind:      m.IdKind,
		Contact:     oneof_contact,
		Identity:    oneof_identity,
	}
}

func (m *UserPlain) IntoPbErr() (*User, error) {
	if m == nil {
		return nil, nil
	}
	var oneof_contact isUser_Contact
	if m.Email != nil {
		oneof_contact = &User_Email{Email: m.Email}
	}
	if m.Phone != nil {
		oneof_contact = &User_Phone{Phone: m.Phone}
	}
	var oneof_identity isUser_Identity
	if m.UserId != nil {
		oneof_identity = &User_UserId{UserId: m.UserId}
	}
	return &User{
		ContactKind: m.ContactKind,
		IdKind:      m.IdKind,
		Contact:     oneof_contact,
		Identity:    oneof_identity,
	}, nil
}
