// Code generated by protoc-gen-go-plain. DO NOT EDIT.

package discriminator

import (
	json "encoding/json"
	fmt "fmt"
	jx "github.com/go-faster/jx"
	oneoff "github.com/yaroher/protoc-gen-go-plain/oneoff"
	protojson "google.golang.org/protobuf/encoding/protojson"
)

type UserPlain struct {

	// src: .test.discriminator.User.contact_kind; transform: none
	ContactKind ContactKind
	// src: .test.discriminator.User.id_kind; transform: none
	IdKind IdKind
	// src: <virtual>; transform: virtual|override_type
	ContactDisc oneoff.EnumDiscriminator
	// src: <virtual>; transform: virtual|override_type
	Contact any
	// src: <virtual>; transform: virtual|override_type
	IdentityDisc oneoff.EnumDiscriminator
	// src: <virtual>; transform: virtual|override_type
	Identity any
}

const enumFull_TestDiscriminatorContactKind = "test.discriminator.ContactKind"
const enumFull_TestDiscriminatorIdKind = "test.discriminator.IdKind"

func (m *User) IntoPlain() *UserPlain {
	if m == nil {
		return nil
	}
	var disc_contactDisc oneoff.EnumDiscriminator
	var oneof_contact any
	switch x := m.GetContact().(type) {
	case *User_Email:
		oneof_contact = x.Email
		disc_contactDisc = oneoff.NewDiscriminator(ContactKind_CONTACT_KIND_EMAIL)
	case *User_Phone:
		oneof_contact = x.Phone
		disc_contactDisc = oneoff.NewDiscriminator(ContactKind_CONTACT_KIND_PHONE)
	}
	var disc_identityDisc oneoff.EnumDiscriminator
	var oneof_identity any
	switch x := m.GetIdentity().(type) {
	case *User_UserId:
		oneof_identity = x.UserId
		disc_identityDisc = oneoff.NewDiscriminator(IdKind_ID_KIND_USER)
	}
	return &UserPlain{
		ContactKind:  m.GetContactKind(),
		IdKind:       m.GetIdKind(),
		ContactDisc:  disc_contactDisc,
		Contact:      oneof_contact,
		IdentityDisc: disc_identityDisc,
		Identity:     oneof_identity,
	}
}

func (m *User) IntoPlainErr() (*UserPlain, error) {
	if m == nil {
		return nil, nil
	}
	var disc_contactDisc oneoff.EnumDiscriminator
	var oneof_contact any
	var matched_contact bool
	switch x := m.GetContact().(type) {
	case *User_Email:
		oneof_contact = x.Email
		disc_contactDisc = oneoff.NewDiscriminator(ContactKind_CONTACT_KIND_EMAIL)
		matched_contact = true
	case *User_Phone:
		oneof_contact = x.Phone
		disc_contactDisc = oneoff.NewDiscriminator(ContactKind_CONTACT_KIND_PHONE)
		matched_contact = true
	}
	var disc_identityDisc oneoff.EnumDiscriminator
	var oneof_identity any
	var matched_identity bool
	switch x := m.GetIdentity().(type) {
	case *User_UserId:
		oneof_identity = x.UserId
		disc_identityDisc = oneoff.NewDiscriminator(IdKind_ID_KIND_USER)
		matched_identity = true
	}
	if m.GetContact() != nil && !matched_contact {
		return nil, fmt.Errorf("oneof %s discriminator mismatch", "Contact")
	}
	if m.GetIdentity() != nil && !matched_identity {
		return nil, fmt.Errorf("oneof %s discriminator mismatch", "Identity")
	}
	return &UserPlain{
		ContactKind:  m.GetContactKind(),
		IdKind:       m.GetIdKind(),
		ContactDisc:  disc_contactDisc,
		Contact:      oneof_contact,
		IdentityDisc: disc_identityDisc,
		Identity:     oneof_identity,
	}, nil
}

func (m *UserPlain) IntoPb() *User {
	if m == nil {
		return nil
	}
	var oneof_contact isUser_Contact
	if disc, err := oneoff.ParseDiscriminator(m.ContactDisc); err == nil {
		if string(disc.Descriptor().FullName()) == enumFull_TestDiscriminatorContactKind && disc.Number() == 1 {
			if v, ok := m.Contact.(*Email); ok {
				oneof_contact = &User_Email{Email: v}
			}
		}
		if string(disc.Descriptor().FullName()) == enumFull_TestDiscriminatorContactKind && disc.Number() == 2 {
			if v, ok := m.Contact.(*Phone); ok {
				oneof_contact = &User_Phone{Phone: v}
			}
		}
	}
	var oneof_identity isUser_Identity
	if disc, err := oneoff.ParseDiscriminator(m.IdentityDisc); err == nil {
		if string(disc.Descriptor().FullName()) == enumFull_TestDiscriminatorIdKind && disc.Number() == 1 {
			if v, ok := m.Identity.(*UserId); ok {
				oneof_identity = &User_UserId{UserId: v}
			}
		}
	}
	return &User{
		ContactKind: m.ContactKind,
		IdKind:      m.IdKind,
		Identity:    oneof_identity,
		Contact:     oneof_contact,
	}
}

func (m *UserPlain) IntoPbErr() (*User, error) {
	if m == nil {
		return nil, nil
	}
	var oneof_contact isUser_Contact
	if disc, err := oneoff.ParseDiscriminator(m.ContactDisc); err != nil {
		return nil, err
	} else {
		matched := false
		if string(disc.Descriptor().FullName()) == enumFull_TestDiscriminatorContactKind && disc.Number() == 1 {
			if v, ok := m.Contact.(*Email); ok {
				oneof_contact = &User_Email{Email: v}
				matched = true
			} else {
				return nil, fmt.Errorf("oneof %s discriminator payload type mismatch", "Contact")
			}
		}
		if string(disc.Descriptor().FullName()) == enumFull_TestDiscriminatorContactKind && disc.Number() == 2 {
			if v, ok := m.Contact.(*Phone); ok {
				oneof_contact = &User_Phone{Phone: v}
				matched = true
			} else {
				return nil, fmt.Errorf("oneof %s discriminator payload type mismatch", "Contact")
			}
		}
		if !matched {
			return nil, fmt.Errorf("oneof %s discriminator mismatch", "Contact")
		}
	}
	var oneof_identity isUser_Identity
	if disc, err := oneoff.ParseDiscriminator(m.IdentityDisc); err != nil {
		return nil, err
	} else {
		matched := false
		if string(disc.Descriptor().FullName()) == enumFull_TestDiscriminatorIdKind && disc.Number() == 1 {
			if v, ok := m.Identity.(*UserId); ok {
				oneof_identity = &User_UserId{UserId: v}
				matched = true
			} else {
				return nil, fmt.Errorf("oneof %s discriminator payload type mismatch", "Identity")
			}
		}
		if !matched {
			return nil, fmt.Errorf("oneof %s discriminator mismatch", "Identity")
		}
	}
	return &User{
		ContactKind: m.ContactKind,
		IdKind:      m.IdKind,
		Contact:     oneof_contact,
		Identity:    oneof_identity,
	}, nil
}

func (m *UserPlain) MarshalJSON() ([]byte, error) {
	if m == nil {
		return []byte("null"), nil
	}
	_ = protojson.Marshal
	_ = json.Marshal
	var e jx.Encoder
	e.ObjStart()
	e.FieldStart("contactKind")
	e.Int32(int32(m.ContactKind))
	e.FieldStart("idKind")
	e.Int32(int32(m.IdKind))
	e.FieldStart("contactDisc")
	e.Str(string(m.ContactDisc))
	e.FieldStart("contact")
	if m.Contact == nil {
		e.Null()
	} else {
		if b, err := json.Marshal(m.Contact); err != nil {
			return nil, err
		} else {
			e.Raw(b)
		}
	}
	e.FieldStart("identityDisc")
	e.Str(string(m.IdentityDisc))
	e.FieldStart("identity")
	if m.Identity == nil {
		e.Null()
	} else {
		if b, err := json.Marshal(m.Identity); err != nil {
			return nil, err
		} else {
			e.Raw(b)
		}
	}
	e.ObjEnd()
	return e.Bytes(), nil
}

func (m *UserPlain) UnmarshalJSON(data []byte) error {
	if m == nil {
		return nil
	}
	_ = protojson.Unmarshal
	_ = json.Unmarshal
	d := jx.DecodeBytes(data)
	return d.Obj(func(d *jx.Decoder, key string) error {
		switch key {
		case "contactKind":
			v, err := d.Int32()
			if err != nil {
				return err
			}
			m.ContactKind = ContactKind(v)
			return nil
		case "idKind":
			v, err := d.Int32()
			if err != nil {
				return err
			}
			m.IdKind = IdKind(v)
			return nil
		case "contactDisc":
			v, err := d.Str()
			if err != nil {
				return err
			}
			m.ContactDisc = oneoff.EnumDiscriminator(v)
			return nil
		case "contact":
			raw, err := d.Raw()
			if err != nil {
				return err
			}
			if string(raw) == "null" {
				m.Contact = nil
				return nil
			}
			var v any
			if err := json.Unmarshal(raw, &v); err != nil {
				return err
			}
			m.Contact = v
			return nil
		case "identityDisc":
			v, err := d.Str()
			if err != nil {
				return err
			}
			m.IdentityDisc = oneoff.EnumDiscriminator(v)
			return nil
		case "identity":
			raw, err := d.Raw()
			if err != nil {
				return err
			}
			if string(raw) == "null" {
				m.Identity = nil
				return nil
			}
			var v any
			if err := json.Unmarshal(raw, &v); err != nil {
				return err
			}
			m.Identity = v
			return nil
		default:
			return d.Skip()
		}
	})
}
