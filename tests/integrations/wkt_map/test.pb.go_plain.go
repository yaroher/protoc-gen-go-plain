// Code generated by protoc-gen-go-plain. DO NOT EDIT.

package wkt_map

import (
	anypb "google.golang.org/protobuf/types/known/anypb"
	durationpb "google.golang.org/protobuf/types/known/durationpb"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
	structpb "google.golang.org/protobuf/types/known/structpb"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
	wrapperspb "google.golang.org/protobuf/types/known/wrapperspb"
)

type UserPlain struct {

	// src: .test.wkt_map.User.f_any; transform: none
	FAny *anypb.Any
	// src: .test.wkt_map.User.f_duration; transform: none
	FDuration *durationpb.Duration
	// src: .test.wkt_map.User.f_empty; transform: none
	FEmpty *emptypb.Empty
	// src: .test.wkt_map.User.f_struct; transform: none
	FStruct *structpb.Struct
	// src: .test.wkt_map.User.f_ts; transform: none
	FTs *timestamppb.Timestamp
	// src: .test.wkt_map.User.f_bool; transform: none
	FBool *wrapperspb.BoolValue
	// src: .test.wkt_map.User.f_string; transform: none
	FString *wrapperspb.StringValue
	// src: .test.wkt_map.User.f_map_int32; transform: none
	FMapInt32 map[string]int32
	// src: .test.wkt_map.User.f_map_msg; transform: none
	FMapMsg map[string]*Address
}

func (m *User) IntoPlain() *UserPlain {
	if m == nil {
		return nil
	}
	return &UserPlain{
		FAny:      m.GetFAny(),
		FDuration: m.GetFDuration(),
		FEmpty:    m.GetFEmpty(),
		FStruct:   m.GetFStruct(),
		FTs:       m.GetFTs(),
		FBool:     m.GetFBool(),
		FString:   m.GetFString(),
		FMapInt32: m.GetFMapInt32(),
		FMapMsg:   m.GetFMapMsg(),
	}
}

func (m *User) IntoPlainErr() (*UserPlain, error) {
	if m == nil {
		return nil, nil
	}
	return &UserPlain{
		FAny:      m.GetFAny(),
		FDuration: m.GetFDuration(),
		FEmpty:    m.GetFEmpty(),
		FStruct:   m.GetFStruct(),
		FTs:       m.GetFTs(),
		FBool:     m.GetFBool(),
		FString:   m.GetFString(),
		FMapInt32: m.GetFMapInt32(),
		FMapMsg:   m.GetFMapMsg(),
	}, nil
}

func (m *UserPlain) IntoPb() *User {
	if m == nil {
		return nil
	}
	return &User{
		FAny:      m.FAny,
		FDuration: m.FDuration,
		FEmpty:    m.FEmpty,
		FStruct:   m.FStruct,
		FTs:       m.FTs,
		FBool:     m.FBool,
		FString:   m.FString,
		FMapInt32: m.FMapInt32,
		FMapMsg:   m.FMapMsg,
	}
}

func (m *UserPlain) IntoPbErr() (*User, error) {
	if m == nil {
		return nil, nil
	}
	return &User{
		FAny:      m.FAny,
		FDuration: m.FDuration,
		FEmpty:    m.FEmpty,
		FStruct:   m.FStruct,
		FTs:       m.FTs,
		FBool:     m.FBool,
		FString:   m.FString,
		FMapInt32: m.FMapInt32,
		FMapMsg:   m.FMapMsg,
	}, nil
}
