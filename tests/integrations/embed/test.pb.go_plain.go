// Code generated by protoc-gen-go-plain. DO NOT EDIT.

package embed

import (
	json "encoding/json"
	jx "github.com/go-faster/jx"
	protojson "google.golang.org/protobuf/encoding/protojson"
)

type UserPlain struct {

	// src: .test.embed.User.name; transform: none
	Name string
	// src: .test.embed.User.street; transform: embed
	Street string
	// src: .test.embed.User.city; transform: embed
	City string
	// src: .test.embed.User.street; transform: embed
	WorkAddressStreet string
	// src: .test.embed.User.city; transform: embed
	WorkAddressCity string
	// src: .test.embed.User.contact_type; transform: none
	ContactType ContactType
	// src: .test.embed.User.email; transform: oneof
	Email string
	// src: .test.embed.User.phone; transform: oneof
	Phone string
	// src: .test.embed.User.backup_email; transform: oneof
	BackupContactBackupEmail string
	// src: .test.embed.User.backup_phone; transform: oneof
	BackupContactBackupPhone string
}

const enumFull_TestEmbedContactType = "test.embed.ContactType"

func (m *User) IntoPlain() *UserPlain {
	if m == nil {
		return nil
	}
	var disc_contactType ContactType
	var oneof_email string
	var oneof_phone string
	switch x := m.GetContact().(type) {
	case *User_Email:
		oneof_email = x.Email
	case *User_Phone:
		oneof_phone = x.Phone
	}
	var oneof_backupContactBackupEmail string
	var oneof_backupContactBackupPhone string
	switch x := m.GetBackupContact().(type) {
	case *User_BackupEmail:
		oneof_backupContactBackupEmail = x.BackupEmail
	case *User_BackupPhone:
		oneof_backupContactBackupPhone = x.BackupPhone
	}
	return &UserPlain{
		Name: m.GetName(),
		Street: func() string {
			if m.GetAddress() == nil {
				return ""
			}
			return m.GetAddress().Street
		}(),
		City: func() string {
			if m.GetAddress() == nil {
				return ""
			}
			return m.GetAddress().City
		}(),
		WorkAddressStreet: func() string {
			if m.GetWorkAddress() == nil {
				return ""
			}
			return m.GetWorkAddress().Street
		}(),
		WorkAddressCity: func() string {
			if m.GetWorkAddress() == nil {
				return ""
			}
			return m.GetWorkAddress().City
		}(),
		ContactType:              disc_contactType,
		Email:                    oneof_email,
		Phone:                    oneof_phone,
		BackupContactBackupEmail: oneof_backupContactBackupEmail,
		BackupContactBackupPhone: oneof_backupContactBackupPhone,
	}
}

func (m *User) IntoPlainErr() (*UserPlain, error) {
	if m == nil {
		return nil, nil
	}
	var disc_contactType ContactType
	var oneof_backupContactBackupEmail string
	var oneof_backupContactBackupPhone string
	switch x := m.GetBackupContact().(type) {
	case *User_BackupEmail:
		oneof_backupContactBackupEmail = x.BackupEmail
	case *User_BackupPhone:
		oneof_backupContactBackupPhone = x.BackupPhone
	}
	var oneof_email string
	var oneof_phone string
	switch x := m.GetContact().(type) {
	case *User_Email:
		oneof_email = x.Email
	case *User_Phone:
		oneof_phone = x.Phone
	}
	return &UserPlain{
		Name: m.GetName(),
		Street: func() string {
			if m.GetAddress() == nil {
				return ""
			}
			return m.GetAddress().Street
		}(),
		City: func() string {
			if m.GetAddress() == nil {
				return ""
			}
			return m.GetAddress().City
		}(),
		WorkAddressStreet: func() string {
			if m.GetWorkAddress() == nil {
				return ""
			}
			return m.GetWorkAddress().Street
		}(),
		WorkAddressCity: func() string {
			if m.GetWorkAddress() == nil {
				return ""
			}
			return m.GetWorkAddress().City
		}(),
		ContactType:              disc_contactType,
		Email:                    oneof_email,
		Phone:                    oneof_phone,
		BackupContactBackupEmail: oneof_backupContactBackupEmail,
		BackupContactBackupPhone: oneof_backupContactBackupPhone,
	}, nil
}

func (m *UserPlain) IntoPb() *User {
	if m == nil {
		return nil
	}
	var embed_address *Address
	embed_address = &Address{Street: m.Street, City: m.City}
	var embed_work_address *Address
	embed_work_address = &Address{Street: m.WorkAddressStreet, City: m.WorkAddressCity}
	var oneof_contact isUser_Contact
	switch m.ContactType {
	case ContactType_CONTACT_TYPE_EMAIL:
		oneof_contact = &User_Email{Email: m.Email}
	case ContactType_CONTACT_TYPE_PHONE:
		oneof_contact = &User_Phone{Phone: m.Phone}
	}
	var oneof_backupContact isUser_BackupContact
	switch m.ContactType {
	case ContactType_CONTACT_TYPE_EMAIL:
		oneof_backupContact = &User_BackupEmail{BackupEmail: m.BackupContactBackupEmail}
	case ContactType_CONTACT_TYPE_PHONE:
		oneof_backupContact = &User_BackupPhone{BackupPhone: m.BackupContactBackupPhone}
	}
	return &User{
		Name:          m.Name,
		ContactType:   m.ContactType,
		Address:       embed_address,
		WorkAddress:   embed_work_address,
		Contact:       oneof_contact,
		BackupContact: oneof_backupContact,
	}
}

func (m *UserPlain) IntoPbErr() (*User, error) {
	if m == nil {
		return nil, nil
	}
	var embed_address *Address
	embed_address = &Address{Street: m.Street, City: m.City}
	var embed_work_address *Address
	embed_work_address = &Address{Street: m.WorkAddressStreet, City: m.WorkAddressCity}
	var oneof_contact isUser_Contact
	switch m.ContactType {
	case ContactType_CONTACT_TYPE_EMAIL:
		oneof_contact = &User_Email{Email: m.Email}
	case ContactType_CONTACT_TYPE_PHONE:
		oneof_contact = &User_Phone{Phone: m.Phone}
	}
	var oneof_backupContact isUser_BackupContact
	switch m.ContactType {
	case ContactType_CONTACT_TYPE_EMAIL:
		oneof_backupContact = &User_BackupEmail{BackupEmail: m.BackupContactBackupEmail}
	case ContactType_CONTACT_TYPE_PHONE:
		oneof_backupContact = &User_BackupPhone{BackupPhone: m.BackupContactBackupPhone}
	}
	return &User{
		Name:          m.Name,
		ContactType:   m.ContactType,
		Address:       embed_address,
		WorkAddress:   embed_work_address,
		Contact:       oneof_contact,
		BackupContact: oneof_backupContact,
	}, nil
}

func (m *UserPlain) MarshalJSON() ([]byte, error) {
	if m == nil {
		return []byte("null"), nil
	}
	_ = protojson.Marshal
	_ = json.Marshal
	var e jx.Encoder
	e.ObjStart()
	e.FieldStart("name")
	e.Str(m.Name)
	e.FieldStart("street")
	e.Str(m.Street)
	e.FieldStart("city")
	e.Str(m.City)
	e.FieldStart("workAddressStreet")
	e.Str(m.WorkAddressStreet)
	e.FieldStart("workAddressCity")
	e.Str(m.WorkAddressCity)
	e.FieldStart("contactType")
	e.Int32(int32(m.ContactType))
	e.FieldStart("email")
	e.Str(m.Email)
	e.FieldStart("phone")
	e.Str(m.Phone)
	e.FieldStart("backupContactBackupEmail")
	e.Str(m.BackupContactBackupEmail)
	e.FieldStart("backupContactBackupPhone")
	e.Str(m.BackupContactBackupPhone)
	e.ObjEnd()
	return e.Bytes(), nil
}

func (m *UserPlain) UnmarshalJSON(data []byte) error {
	if m == nil {
		return nil
	}
	_ = protojson.Unmarshal
	_ = json.Unmarshal
	d := jx.DecodeBytes(data)
	return d.Obj(func(d *jx.Decoder, key string) error {
		switch key {
		case "name":
			v, err := d.Str()
			if err != nil {
				return err
			}
			m.Name = v
			return nil
		case "street":
			v, err := d.Str()
			if err != nil {
				return err
			}
			m.Street = v
			return nil
		case "city":
			v, err := d.Str()
			if err != nil {
				return err
			}
			m.City = v
			return nil
		case "workAddressStreet":
			v, err := d.Str()
			if err != nil {
				return err
			}
			m.WorkAddressStreet = v
			return nil
		case "workAddressCity":
			v, err := d.Str()
			if err != nil {
				return err
			}
			m.WorkAddressCity = v
			return nil
		case "contactType":
			v, err := d.Int32()
			if err != nil {
				return err
			}
			m.ContactType = ContactType(v)
			return nil
		case "email":
			v, err := d.Str()
			if err != nil {
				return err
			}
			m.Email = v
			return nil
		case "phone":
			v, err := d.Str()
			if err != nil {
				return err
			}
			m.Phone = v
			return nil
		case "backupContactBackupEmail":
			v, err := d.Str()
			if err != nil {
				return err
			}
			m.BackupContactBackupEmail = v
			return nil
		case "backupContactBackupPhone":
			v, err := d.Str()
			if err != nil {
				return err
			}
			m.BackupContactBackupPhone = v
			return nil
		default:
			return d.Skip()
		}
	})
}
