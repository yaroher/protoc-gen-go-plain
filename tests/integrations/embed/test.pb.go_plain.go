// Code generated by protoc-gen-go-plain. DO NOT EDIT.

package embed

type UserPlain struct {

	// src: .test.embed.User.name; transform: none
	Name string
	// src: .test.embed.User.street; transform: embed
	Street string
	// src: .test.embed.User.city; transform: embed
	City string
	// src: .test.embed.User.street; transform: embed
	WorkAddressStreet string
	// src: .test.embed.User.city; transform: embed
	WorkAddressCity string
	// src: .test.embed.User.contact_type; transform: none
	ContactType ContactType
	// src: .test.embed.User.email; transform: oneof
	Email string
	// src: .test.embed.User.phone; transform: oneof
	Phone string
	// src: .test.embed.User.backup_email; transform: oneof
	BackupContactBackupEmail string
	// src: .test.embed.User.backup_phone; transform: oneof
	BackupContactBackupPhone string
}

func (m *User) IntoPlain() *UserPlain {
	if m == nil {
		return nil
	}
	var disc_contactType ContactType
	var oneof_email string
	var oneof_phone string
	switch x := m.GetContact().(type) {
	case *User_Email:
		oneof_email = x.Email
	case *User_Phone:
		oneof_phone = x.Phone
	}
	var oneof_backupContactBackupEmail string
	var oneof_backupContactBackupPhone string
	switch x := m.GetBackupContact().(type) {
	case *User_BackupEmail:
		oneof_backupContactBackupEmail = x.BackupEmail
	case *User_BackupPhone:
		oneof_backupContactBackupPhone = x.BackupPhone
	}
	return &UserPlain{
		Name: m.GetName(),
		Street: func() string {
			if m.GetAddress() == nil {
				return ""
			}
			return m.GetAddress().Street
		}(),
		City: func() string {
			if m.GetAddress() == nil {
				return ""
			}
			return m.GetAddress().City
		}(),
		WorkAddressStreet: func() string {
			if m.GetWorkAddress() == nil {
				return ""
			}
			return m.GetWorkAddress().Street
		}(),
		WorkAddressCity: func() string {
			if m.GetWorkAddress() == nil {
				return ""
			}
			return m.GetWorkAddress().City
		}(),
		ContactType:              disc_contactType,
		Email:                    oneof_email,
		Phone:                    oneof_phone,
		BackupContactBackupEmail: oneof_backupContactBackupEmail,
		BackupContactBackupPhone: oneof_backupContactBackupPhone,
	}
}

func (m *User) IntoPlainErr() (*UserPlain, error) {
	if m == nil {
		return nil, nil
	}
	var disc_contactType ContactType
	var oneof_email string
	var oneof_phone string
	switch x := m.GetContact().(type) {
	case *User_Email:
		oneof_email = x.Email
	case *User_Phone:
		oneof_phone = x.Phone
	}
	var oneof_backupContactBackupEmail string
	var oneof_backupContactBackupPhone string
	switch x := m.GetBackupContact().(type) {
	case *User_BackupEmail:
		oneof_backupContactBackupEmail = x.BackupEmail
	case *User_BackupPhone:
		oneof_backupContactBackupPhone = x.BackupPhone
	}
	return &UserPlain{
		Name: m.GetName(),
		Street: func() string {
			if m.GetAddress() == nil {
				return ""
			}
			return m.GetAddress().Street
		}(),
		City: func() string {
			if m.GetAddress() == nil {
				return ""
			}
			return m.GetAddress().City
		}(),
		WorkAddressStreet: func() string {
			if m.GetWorkAddress() == nil {
				return ""
			}
			return m.GetWorkAddress().Street
		}(),
		WorkAddressCity: func() string {
			if m.GetWorkAddress() == nil {
				return ""
			}
			return m.GetWorkAddress().City
		}(),
		ContactType:              disc_contactType,
		Email:                    oneof_email,
		Phone:                    oneof_phone,
		BackupContactBackupEmail: oneof_backupContactBackupEmail,
		BackupContactBackupPhone: oneof_backupContactBackupPhone,
	}, nil
}

func (m *UserPlain) IntoPb() *User {
	if m == nil {
		return nil
	}
	var embed_address *Address
	embed_address = &Address{Street: m.Street, City: m.City}
	var embed_work_address *Address
	embed_work_address = &Address{Street: m.WorkAddressStreet, City: m.WorkAddressCity}
	var oneof_contact isUser_Contact
	switch m.ContactType {
	}
	var oneof_backupContact isUser_BackupContact
	switch m.ContactType {
	}
	return &User{
		Name:          m.Name,
		ContactType:   m.ContactType,
		Address:       embed_address,
		WorkAddress:   embed_work_address,
		Contact:       oneof_contact,
		BackupContact: oneof_backupContact,
	}
}

func (m *UserPlain) IntoPbErr() (*User, error) {
	if m == nil {
		return nil, nil
	}
	var embed_address *Address
	embed_address = &Address{Street: m.Street, City: m.City}
	var embed_work_address *Address
	embed_work_address = &Address{Street: m.WorkAddressStreet, City: m.WorkAddressCity}
	var oneof_contact isUser_Contact
	switch m.ContactType {
	}
	var oneof_backupContact isUser_BackupContact
	switch m.ContactType {
	}
	return &User{
		Name:          m.Name,
		ContactType:   m.ContactType,
		Address:       embed_address,
		WorkAddress:   embed_work_address,
		Contact:       oneof_contact,
		BackupContact: oneof_backupContact,
	}, nil
}
