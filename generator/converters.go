package generator

import (
	"fmt"
	"sort"
	"strings"

	"github.com/iancoleman/strcase"
	"github.com/yaroher/protoc-gen-go-plain/generator/empath"
	"github.com/yaroher/protoc-gen-go-plain/generator/marker"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/reflect/protoreflect"
	"google.golang.org/protobuf/types/known/typepb"
)

func (g *Generator) RenderConverters(typeIRs []*TypePbIR) error {
	for _, ir := range typeIRs {
		if ir.File == nil {
			continue
		}
		outName := ir.File.GeneratedFilenamePrefix + "_plain.conv.go"
		out := g.Plugin.NewGeneratedFile(outName, ir.File.GoImportPath)

		messageCasterTypes := g.collectMessageCasterTypes(ir)
		fileCasterTypes := g.collectFileCasterTypes(messageCasterTypes)

		msgNames := make([]string, 0, len(ir.Messages))
		for name := range ir.Messages {
			msgNames = append(msgNames, name)
		}
		sort.Strings(msgNames)

		out.P("// Code generated by protoc-gen-go-plain. DO NOT EDIT.")
		out.P()
		out.P("package ", ir.File.GoPackageName)
		out.P()
		imports := map[string]struct{}{}
		if g.hasCrfFields(ir) {
			imports["strings"] = struct{}{}
		}
		if len(fileCasterTypes.list) > 0 {
			imports["fmt"] = struct{}{}
			imports["github.com/yaroher/protoc-gen-go-plain/cast"] = struct{}{}
			for _, ct := range fileCasterTypes.list {
				if ct.importPath != "" {
					imports[ct.importPath] = struct{}{}
				}
				if ct.needsProtoReflect {
					imports["google.golang.org/protobuf/reflect/protoreflect"] = struct{}{}
				}
			}
		}
		out.P("import (")
		paths := make([]string, 0, len(imports))
		for path := range imports {
			paths = append(paths, path)
		}
		sort.Strings(paths)
		for _, path := range paths {
			out.P(fmt.Sprintf("%q", path))
		}
		out.P(")")
		out.P()

		if g.hasCrfFields(ir) {
			out.P("func parseCRFPath(s string) []string {")
			out.P("\tif s == \"\" {")
			out.P("\t\treturn nil")
			out.P("\t}")
			out.P("\tparts := strings.Split(s, \"/\")")
			out.P("\tresult := make([]string, 0, len(parts))")
			out.P("\tfor _, p := range parts {")
			out.P("\t\tif p == \"\" {")
			out.P("\t\t\tcontinue")
			out.P("\t\t}")
			out.P("\t\tif idx := strings.Index(p, \"?\"); idx >= 0 {")
			out.P("\t\t\tp = p[:idx]")
			out.P("\t\t}")
			out.P("\t\tresult = append(result, p)")
			out.P("\t}")
			out.P("\treturn result")
			out.P("}")
			out.P()
		}

		for _, name := range msgNames {
			msg := ir.Messages[name]
			casterTypes := messageCasterTypes[msg.Name]
			g.renderConvertersForMessage(out, ir, msg, casterTypes, messageCasterTypes)
			out.P()
		}

	}
	return nil
}

func (g *Generator) renderConvertersForMessage(out typeWriter, ir *TypePbIR, msg *typepb.Type, casterTypes casterTypes, messageCasterTypes map[string]casterTypes) {
	if !g.isPbMessage(ir, msg.Name) {
		return
	}
	if g.isTypeAliasMessage(msg.Name) {
		return
	}
	msgPlain := g.plainTypeName(msg.Name)
	msgPb := strcase.ToCamel(getShortName(msg.Name))
	paramList := g.casterParamList(casterTypes.list, true, false)
	paramListErr := g.casterParamList(casterTypes.list, true, true)

	out.P("func (x *", msgPlain, ") IntoPb(", paramList, ") *", msgPb, " {")
	out.P("\tif x == nil {")
	out.P("\t\treturn nil")
	out.P("\t}")
	out.P("\tout := &", msgPb, "{}")

	for _, field := range msg.Fields {
		if field.OneofIndex > 0 {
			continue
		}
		path := g.fieldPath(field)
		if len(path) == 0 {
			continue
		}
		fieldName := g.fieldGoName(field)
		segments, ok := g.pbPathSegments(out, ir, msg, path)
		if !ok {
			out.P("\t// skip invalid path for ", fieldName)
			continue
		}

		isCrf := hasMarker(field.TypeUrl, crfMarker) && !hasMarker(field.TypeUrl, crfForMarker)
		if isCrf {
			crfGo := goFieldNameFromPlain(g.plainName(field) + "CRF")
			basePath := strings.Join(path, "/")
			paths := g.expandCrfPaths(g.crfPaths(field), basePath)
			out.P("\tif x.", crfGo, " != \"\" {")
			out.P("\t\t_crfPath := strings.Join(parseCRFPath(x.", crfGo, "), \"/\")")
			out.P("\t\tswitch _crfPath {")
			for _, crfPath := range paths {
				crfParts := strings.Split(crfPath, "/")
				crfSegments, ok := g.pbPathSegments(out, ir, msg, crfParts)
				if !ok {
					continue
				}
				out.P("\t\tcase ", fmt.Sprintf("%q", crfPath), ":")
				g.renderFieldIntoPb(out, ir, msg, field, fieldName, crfSegments, casterTypes, messageCasterTypes, "\t\t\t")
			}
			out.P("\t\t}")
			out.P("\t} else {")
			g.renderFieldIntoPb(out, ir, msg, field, fieldName, segments, casterTypes, messageCasterTypes, "\t\t")
			out.P("\t}")
			continue
		}

		g.renderFieldIntoPb(out, ir, msg, field, fieldName, segments, casterTypes, messageCasterTypes, "\t")
	}

	for _, oneof := range g.collectOneofFieldNames(msg) {
		out.P("\tout.", oneof.fieldName, " = x.", oneof.fieldName)
	}

	out.P("\treturn out")
	out.P("}")
	out.P()

	paramListPlain := g.casterParamList(casterTypes.list, false, false)
	paramListPlainErr := g.casterParamList(casterTypes.list, false, true)
	out.P("func (x *", msgPb, ") IntoPlain(", paramListPlain, ") *", msgPlain, " {")
	out.P("\tif x == nil {")
	out.P("\t\treturn nil")
	out.P("\t}")
	out.P("\tout := &", msgPlain, "{}")

	for _, field := range msg.Fields {
		if field.OneofIndex > 0 {
			continue
		}
		path := g.fieldPath(field)
		if len(path) == 0 {
			continue
		}
		fieldName := g.fieldGoName(field)
		segments, ok := g.pbPathSegments(out, ir, msg, path)
		if !ok {
			out.P("\t// skip invalid path for ", fieldName)
			continue
		}
		pathString := strings.Join(path, "/")
		isCrf := hasMarker(field.TypeUrl, crfMarker) && !hasMarker(field.TypeUrl, crfForMarker)
		if isCrf {
			paths := g.expandCrfPaths(g.crfPaths(field), pathString)
			for i, crfPath := range paths {
				crfParts := strings.Split(crfPath, "/")
				crfSegments, ok := g.pbPathSegments(out, ir, msg, crfParts)
				if !ok {
					continue
				}
				if i == 0 {
					out.P("\t// CRF paths")
				}
				g.renderFieldIntoPlain(out, ir, msg, field, fieldName, crfSegments, casterTypes, messageCasterTypes, "\t", crfPath, true)
			}
			continue
		}
		g.renderFieldIntoPlain(out, ir, msg, field, fieldName, segments, casterTypes, messageCasterTypes, "\t", pathString, false)
	}

	for _, oneof := range g.collectOneofFieldNames(msg) {
		out.P("\tout.", oneof.fieldName, " = x.", oneof.fieldName)
	}

	out.P("\treturn out")
	out.P("}")

	out.P()
	out.P("func (x *", msgPlain, ") IntoPbErr(", paramListErr, ") (*", msgPb, ", error) {")
	out.P("\tif x == nil {")
	out.P("\t\treturn nil, nil")
	out.P("\t}")
	out.P("\tout := &", msgPb, "{}")

	for _, field := range msg.Fields {
		if field.OneofIndex > 0 {
			continue
		}
		path := g.fieldPath(field)
		if len(path) == 0 {
			continue
		}
		fieldName := g.fieldGoName(field)
		segments, ok := g.pbPathSegments(out, ir, msg, path)
		if !ok {
			out.P("\t// skip invalid path for ", fieldName)
			continue
		}
		isCrf := hasMarker(field.TypeUrl, crfMarker) && !hasMarker(field.TypeUrl, crfForMarker)
		if isCrf {
			crfGo := goFieldNameFromPlain(g.plainName(field) + "CRF")
			basePath := strings.Join(path, "/")
			paths := g.expandCrfPaths(g.crfPaths(field), basePath)
			out.P("\tif x.", crfGo, " != \"\" {")
			out.P("\t\t_crfPath := strings.Join(parseCRFPath(x.", crfGo, "), \"/\")")
			out.P("\t\tswitch _crfPath {")
			for _, crfPath := range paths {
				crfParts := strings.Split(crfPath, "/")
				crfSegments, ok := g.pbPathSegments(out, ir, msg, crfParts)
				if !ok {
					continue
				}
				out.P("\t\tcase ", fmt.Sprintf("%q", crfPath), ":")
				g.renderFieldIntoPbErr(out, ir, msg, field, fieldName, crfSegments, casterTypes, messageCasterTypes, "\t\t\t")
			}
			out.P("\t\t}")
			out.P("\t} else {")
			g.renderFieldIntoPbErr(out, ir, msg, field, fieldName, segments, casterTypes, messageCasterTypes, "\t\t")
			out.P("\t}")
			continue
		}
		g.renderFieldIntoPbErr(out, ir, msg, field, fieldName, segments, casterTypes, messageCasterTypes, "\t")
	}

	for _, oneof := range g.collectOneofFieldNames(msg) {
		out.P("\tout.", oneof.fieldName, " = x.", oneof.fieldName)
	}

	out.P("\treturn out, nil")
	out.P("}")
	out.P()

	out.P("func (x *", msgPb, ") IntoPlainErr(", paramListPlainErr, ") (*", msgPlain, ", error) {")
	out.P("\tif x == nil {")
	out.P("\t\treturn nil, nil")
	out.P("\t}")
	out.P("\tout := &", msgPlain, "{}")

	for _, field := range msg.Fields {
		if field.OneofIndex > 0 {
			continue
		}
		path := g.fieldPath(field)
		if len(path) == 0 {
			continue
		}
		fieldName := g.fieldGoName(field)
		segments, ok := g.pbPathSegments(out, ir, msg, path)
		if !ok {
			out.P("\t// skip invalid path for ", fieldName)
			continue
		}
		pathString := strings.Join(path, "/")
		isCrf := hasMarker(field.TypeUrl, crfMarker) && !hasMarker(field.TypeUrl, crfForMarker)
		if isCrf {
			paths := g.expandCrfPaths(g.crfPaths(field), pathString)
			for i, crfPath := range paths {
				crfParts := strings.Split(crfPath, "/")
				crfSegments, ok := g.pbPathSegments(out, ir, msg, crfParts)
				if !ok {
					continue
				}
				if i == 0 {
					out.P("\t// CRF paths")
				}
				g.renderFieldIntoPlainErr(out, ir, msg, field, fieldName, crfSegments, casterTypes, messageCasterTypes, "\t", crfPath, true)
			}
			continue
		}
		g.renderFieldIntoPlainErr(out, ir, msg, field, fieldName, segments, casterTypes, messageCasterTypes, "\t", pathString, false)
	}

	for _, oneof := range g.collectOneofFieldNames(msg) {
		out.P("\tout.", oneof.fieldName, " = x.", oneof.fieldName)
	}

	out.P("\treturn out, nil")
	out.P("}")
}

func (g *Generator) renderAssignScalarAtLeaf(out typeWriter, field *typepb.Field, leaf pbPathSegment, access, valueExpr, indent string) {
	if leaf.isOneof && field.Cardinality == typepb.Field_CARDINALITY_REPEATED {
		out.P(indent, "// repeated oneof scalar is not supported")
		return
	}
	enumType := g.enumGoType(out, leaf)
	if enumType != "" {
		valueExpr = enumType + "(" + valueExpr + ")"
	}
	if leaf.isOneof {
		out.P(indent, access, ".", leaf.oneofGoName, " = &", leaf.oneofWrapperGo, "{", leaf.goName, ": ", valueExpr, "}")
		return
	}
	if isPointerScalarField(leaf.field) {
		valVar := g.valueVarName(field)
		out.P(indent, valVar, " := ", valueExpr)
		out.P(indent, access, ".", leaf.goName, " = &", valVar)
		return
	}
	out.P(indent, access, ".", leaf.goName, " = ", valueExpr)
}

func (g *Generator) renderAssignMessageAtLeaf(out typeWriter, leaf pbPathSegment, access, valueExpr, indent string) {
	if leaf.isOneof {
		out.P(indent, access, ".", leaf.oneofGoName, " = &", leaf.oneofWrapperGo, "{", leaf.goName, ": ", valueExpr, "}")
		return
	}
	out.P(indent, access, ".", leaf.goName, " = ", valueExpr)
}

func (g *Generator) renderScalarIntoPb(out typeWriter, field *typepb.Field, fieldName string, segments []pbPathSegment, indent string) {
	if len(segments) == 0 {
		return
	}
	leaf := segments[len(segments)-1]
	if field.Cardinality == typepb.Field_CARDINALITY_REPEATED {
		out.P(indent, "if len(x.", fieldName, ") > 0 {")
		inner := indent + "\t"
		access, ok := g.renderEnsurePath(out, "out", segments, inner)
		if !ok {
			out.P(inner, "// skip invalid path")
			out.P(indent, "}")
			return
		}
		enumType := g.enumGoType(out, leaf)
		if enumType != "" {
			valVar := g.valueVarName(field) + "Slice"
			out.P(inner, valVar, " := make([]", enumType, ", len(x.", fieldName, "))")
			out.P(inner, "for i, el := range x.", fieldName, " {")
			out.P(inner, "\t", valVar, "[i] = ", enumType, "(el)")
			out.P(inner, "}")
			out.P(inner, access, ".", leaf.goName, " = ", valVar)
		} else {
			out.P(inner, access, ".", leaf.goName, " = x.", fieldName)
		}
		out.P(indent, "}")
		return
	}

	if g.isPointerField(field) {
		out.P(indent, "if x.", fieldName, " != nil {")
		inner := indent + "\t"
		access, ok := g.renderEnsurePath(out, "out", segments, inner)
		if !ok {
			out.P(inner, "// skip invalid path")
			out.P(indent, "}")
			return
		}
		valueExpr := "*x." + fieldName
		g.renderAssignScalarAtLeaf(out, field, leaf, access, valueExpr, inner)
		out.P(indent, "}")
		return
	}

	access, ok := g.renderEnsurePath(out, "out", segments, indent)
	if !ok {
		out.P(indent, "// skip invalid path")
		return
	}
	valueExpr := "x." + fieldName
	g.renderAssignScalarAtLeaf(out, field, leaf, access, valueExpr, indent)
}

func (g *Generator) renderScalarIntoPlain(out typeWriter, field *typepb.Field, fieldName string, segments []pbPathSegment, indent, pathString string, setCrf bool) {
	if len(segments) == 0 {
		return
	}
	leaf := segments[len(segments)-1]
	leafAccess, innerIndent, closers, ok := g.renderPathAccessForGet(out, "x", segments, indent)
	if !ok {
		out.P(indent, "// skip invalid path")
		return
	}
	enumType := g.enumGoType(out, leaf)

	if field.Cardinality == typepb.Field_CARDINALITY_REPEATED {
		out.P(innerIndent, "if len(", leafAccess, ") > 0 {")
		innerIndent += "\t"
		if enumType != "" {
			valVar := g.valueVarName(field) + "Slice"
			out.P(innerIndent, valVar, " := make([]int32, len(", leafAccess, "))")
			out.P(innerIndent, "for i, el := range ", leafAccess, " {")
			out.P(innerIndent, "\t", valVar, "[i] = int32(el)")
			out.P(innerIndent, "}")
			out.P(innerIndent, "out.", fieldName, " = ", valVar)
		} else {
			out.P(innerIndent, "out.", fieldName, " = ", leafAccess)
		}
		if setCrf {
			out.P(innerIndent, "out.", goFieldNameFromPlain(g.plainName(field)+"CRF"), " = ", fmt.Sprintf("%q", pathString))
		}
		innerIndent = strings.TrimSuffix(innerIndent, "\t")
		out.P(innerIndent, "}")
		closeGuards(out, innerIndent, closers)
		return
	}

	valueExpr := leafAccess
	if enumType != "" {
		valueExpr = "int32(" + valueExpr + ")"
	}

	if leaf.isOneof {
		if field.Kind == typepb.Field_TYPE_MESSAGE {
			out.P(innerIndent, "if ", valueExpr, " != nil {")
			innerIndent += "\t"
		}
		if g.isPointerField(field) {
			valVar := g.valueVarName(field)
			out.P(innerIndent, valVar, " := ", valueExpr)
			out.P(innerIndent, "out.", fieldName, " = &", valVar)
		} else {
			out.P(innerIndent, "out.", fieldName, " = ", valueExpr)
		}
		if setCrf {
			out.P(innerIndent, "out.", goFieldNameFromPlain(g.plainName(field)+"CRF"), " = ", fmt.Sprintf("%q", pathString))
		}
		if field.Kind == typepb.Field_TYPE_MESSAGE {
			innerIndent = strings.TrimSuffix(innerIndent, "\t")
			out.P(innerIndent, "}")
		}
		closeGuards(out, innerIndent, closers)
		return
	}

	if isPointerScalarField(leaf.field) {
		out.P(innerIndent, "if ", valueExpr, " != nil {")
		innerIndent += "\t"
		valVar := g.valueVarName(field)
		out.P(innerIndent, valVar, " := *", valueExpr)
		out.P(innerIndent, "out.", fieldName, " = &", valVar)
		if setCrf {
			out.P(innerIndent, "out.", goFieldNameFromPlain(g.plainName(field)+"CRF"), " = ", fmt.Sprintf("%q", pathString))
		}
		innerIndent = strings.TrimSuffix(innerIndent, "\t")
		out.P(innerIndent, "}")
		closeGuards(out, innerIndent, closers)
		return
	}

	needPresence := g.isPointerField(field) || setCrf
	cond := ""
	if needPresence {
		cond = g.scalarPresenceExpr(valueExpr, field.Kind, enumType != "")
	}
	if cond != "" {
		out.P(innerIndent, "if ", cond, " {")
		innerIndent += "\t"
	}
	if g.isPointerField(field) {
		valVar := g.valueVarName(field)
		out.P(innerIndent, valVar, " := ", valueExpr)
		out.P(innerIndent, "out.", fieldName, " = &", valVar)
	} else {
		out.P(innerIndent, "out.", fieldName, " = ", valueExpr)
	}
	if setCrf {
		out.P(innerIndent, "out.", goFieldNameFromPlain(g.plainName(field)+"CRF"), " = ", fmt.Sprintf("%q", pathString))
	}
	if cond != "" {
		innerIndent = strings.TrimSuffix(innerIndent, "\t")
		out.P(innerIndent, "}")
	}
	closeGuards(out, innerIndent, closers)
}

func (g *Generator) renderFieldIntoPb(
	out typeWriter,
	ir *TypePbIR,
	msg *typepb.Type,
	field *typepb.Field,
	fieldName string,
	segments []pbPathSegment,
	casterTypes casterTypes,
	messageCasterTypes map[string]casterTypes,
	indent string,
) {
	_ = msg
	if alias, ok := g.typeAliasInfoForTypeURL(field.TypeUrl); ok {
		if len(segments) == 0 {
			out.P(indent, "// skip invalid alias path")
			return
		}
		leaf := segments[len(segments)-1]
		access, ok := g.renderEnsurePath(out, "out", segments, indent)
		if !ok {
			out.P(indent, "// skip invalid alias path")
			return
		}
		if field.Cardinality == typepb.Field_CARDINALITY_REPEATED {
			out.P(indent, "if len(x.", fieldName, ") > 0 {")
			out.P(indent, "\tvals := make([]*", alias.pbTypeName, ", len(x.", fieldName, "))")
			out.P(indent, "\tfor i, v := range x.", fieldName, " {")
			out.P(indent, "\t\tvals[i] = &", alias.pbTypeName, "{", alias.fieldGoName, ": v}")
			out.P(indent, "\t}")
			out.P(indent, "\t", access, ".", leaf.goName, " = vals")
			out.P(indent, "}")
			return
		}
		if g.isPointerField(field) {
			out.P(indent, "if x.", fieldName, " != nil {")
			out.P(indent, "\t", access, ".", leaf.goName, " = &", alias.pbTypeName, "{", alias.fieldGoName, ": *x.", fieldName, "}")
			out.P(indent, "}")
			return
		}
		out.P(indent, access, ".", leaf.goName, " = &", alias.pbTypeName, "{", alias.fieldGoName, ": x.", fieldName, "}")
		return
	}
	if info, ok := mapFieldInfoFor(field); ok {
		if len(segments) == 0 {
			out.P(indent, "// skip invalid map path")
			return
		}
		leaf := segments[len(segments)-1]
		access, ok := g.renderEnsurePath(out, "out", segments, indent)
		if !ok {
			out.P(indent, "// skip invalid map path")
			return
		}
		mapAccess := access + "." + leaf.goName
		if info.valueKind == typepb.Field_TYPE_ENUM {
			enumType := g.mapEnumGoType(out, leaf)
			if enumType == "" {
				out.P(indent, mapAccess, " = x.", fieldName)
				return
			}
			out.P(indent, "if len(x.", fieldName, ") > 0 {")
			out.P(indent, "\tvals := make(map[", mapScalarGoType(info.keyKind), "]", enumType, ", len(x.", fieldName, "))")
			out.P(indent, "\tfor k, v := range x.", fieldName, " {")
			out.P(indent, "\t\tvals[k] = ", enumType, "(v)")
			out.P(indent, "\t}")
			out.P(indent, "\t", mapAccess, " = vals")
			out.P(indent, "}")
			return
		}
		out.P(indent, mapAccess, " = x.", fieldName)
		return
	}
	if g.hasOverride(field) {
		g.renderOverrideIntoPb(out, ir, msg, field, fieldName, segments, casterTypes, indent)
		return
	}
	switch field.Kind {
	case typepb.Field_TYPE_MESSAGE:
		if !g.isPlainMessage(ir, field.TypeUrl) {
			if field.Cardinality == typepb.Field_CARDINALITY_REPEATED {
				out.P(indent, "if len(x.", fieldName, ") > 0 {")
				inner := indent + "\t"
				access, ok := g.renderEnsurePath(out, "out", segments, inner)
				if !ok {
					out.P(inner, "// skip invalid path")
					out.P(indent, "}")
					return
				}
				out.P(inner, access, ".", segments[len(segments)-1].goName, " = x.", fieldName)
				out.P(indent, "}")
				return
			}
			out.P(indent, "if x.", fieldName, " != nil {")
			inner := indent + "\t"
			access, ok := g.renderEnsurePath(out, "out", segments, inner)
			if !ok {
				out.P(inner, "// skip invalid path")
				out.P(indent, "}")
				return
			}
			out.P(inner, access, ".", segments[len(segments)-1].goName, " = x.", fieldName)
			out.P(indent, "}")
			return
		}
		if field.Cardinality == typepb.Field_CARDINALITY_REPEATED {
			out.P(indent, "// repeated message is not supported")
			return
		}
		out.P(indent, "if x.", fieldName, " != nil {")
		inner := indent + "\t"
		access, ok := g.renderEnsurePath(out, "out", segments, inner)
		if !ok {
			out.P(inner, "// skip invalid path")
			out.P(indent, "}")
			return
		}
		childArgs := g.childCasterArgs(ir, field, messageCasterTypes, true)
		valueExpr := "x." + fieldName + ".IntoPb(" + childArgs + ")"
		g.renderAssignMessageAtLeaf(out, segments[len(segments)-1], access, valueExpr, inner)
		out.P(indent, "}")
	default:
		g.renderScalarIntoPb(out, field, fieldName, segments, indent)
	}
}

func (g *Generator) renderFieldIntoPbErr(
	out typeWriter,
	ir *TypePbIR,
	msg *typepb.Type,
	field *typepb.Field,
	fieldName string,
	segments []pbPathSegment,
	casterTypes casterTypes,
	messageCasterTypes map[string]casterTypes,
	indent string,
) {
	_ = msg
	if alias, ok := g.typeAliasInfoForTypeURL(field.TypeUrl); ok {
		if len(segments) == 0 {
			out.P(indent, "// skip invalid alias path")
			return
		}
		leaf := segments[len(segments)-1]
		access, ok := g.renderEnsurePath(out, "out", segments, indent)
		if !ok {
			out.P(indent, "// skip invalid alias path")
			return
		}
		if field.Cardinality == typepb.Field_CARDINALITY_REPEATED {
			out.P(indent, "if len(x.", fieldName, ") > 0 {")
			out.P(indent, "\tvals := make([]*", alias.pbTypeName, ", len(x.", fieldName, "))")
			out.P(indent, "\tfor i, v := range x.", fieldName, " {")
			out.P(indent, "\t\tvals[i] = &", alias.pbTypeName, "{", alias.fieldGoName, ": v}")
			out.P(indent, "\t}")
			out.P(indent, "\t", access, ".", leaf.goName, " = vals")
			out.P(indent, "}")
			return
		}
		if g.isPointerField(field) {
			out.P(indent, "if x.", fieldName, " != nil {")
			out.P(indent, "\t", access, ".", leaf.goName, " = &", alias.pbTypeName, "{", alias.fieldGoName, ": *x.", fieldName, "}")
			out.P(indent, "}")
			return
		}
		out.P(indent, access, ".", leaf.goName, " = &", alias.pbTypeName, "{", alias.fieldGoName, ": x.", fieldName, "}")
		return
	}
	if info, ok := mapFieldInfoFor(field); ok {
		if len(segments) == 0 {
			out.P(indent, "// skip invalid map path")
			return
		}
		leaf := segments[len(segments)-1]
		access, ok := g.renderEnsurePath(out, "out", segments, indent)
		if !ok {
			out.P(indent, "// skip invalid map path")
			return
		}
		mapAccess := access + "." + leaf.goName
		if info.valueKind == typepb.Field_TYPE_ENUM {
			enumType := g.mapEnumGoType(out, leaf)
			if enumType == "" {
				out.P(indent, mapAccess, " = x.", fieldName)
				return
			}
			out.P(indent, "if len(x.", fieldName, ") > 0 {")
			out.P(indent, "\tvals := make(map[", mapScalarGoType(info.keyKind), "]", enumType, ", len(x.", fieldName, "))")
			out.P(indent, "\tfor k, v := range x.", fieldName, " {")
			out.P(indent, "\t\tvals[k] = ", enumType, "(v)")
			out.P(indent, "\t}")
			out.P(indent, "\t", mapAccess, " = vals")
			out.P(indent, "}")
			return
		}
		out.P(indent, mapAccess, " = x.", fieldName)
		return
	}
	if g.hasOverride(field) {
		g.renderOverrideIntoPbErr(out, ir, msg, field, fieldName, segments, casterTypes, indent)
		return
	}
	switch field.Kind {
	case typepb.Field_TYPE_MESSAGE:
		if !g.isPlainMessage(ir, field.TypeUrl) {
			if field.Cardinality == typepb.Field_CARDINALITY_REPEATED {
				out.P(indent, "if len(x.", fieldName, ") > 0 {")
				inner := indent + "\t"
				access, ok := g.renderEnsurePath(out, "out", segments, inner)
				if !ok {
					out.P(inner, "// skip invalid path")
					out.P(indent, "}")
					return
				}
				out.P(inner, access, ".", segments[len(segments)-1].goName, " = x.", fieldName)
				out.P(indent, "}")
				return
			}
			out.P(indent, "if x.", fieldName, " != nil {")
			inner := indent + "\t"
			access, ok := g.renderEnsurePath(out, "out", segments, inner)
			if !ok {
				out.P(inner, "// skip invalid path")
				out.P(indent, "}")
				return
			}
			out.P(inner, access, ".", segments[len(segments)-1].goName, " = x.", fieldName)
			out.P(indent, "}")
			return
		}
		if field.Cardinality == typepb.Field_CARDINALITY_REPEATED {
			out.P(indent, "// repeated message is not supported")
			return
		}
		out.P(indent, "if x.", fieldName, " != nil {")
		inner := indent + "\t"
		access, ok := g.renderEnsurePath(out, "out", segments, inner)
		if !ok {
			out.P(inner, "// skip invalid path")
			out.P(indent, "}")
			return
		}
		childArgs := g.childCasterArgs(ir, field, messageCasterTypes, true)
		out.P(inner, "mv, err := x.", fieldName, ".IntoPbErr(", childArgs, ")")
		out.P(inner, "if err != nil {")
		out.P(inner, "\treturn nil, err")
		out.P(inner, "}")
		g.renderAssignMessageAtLeaf(out, segments[len(segments)-1], access, "mv", inner)
		out.P(indent, "}")
	default:
		g.renderScalarIntoPb(out, field, fieldName, segments, indent)
	}
}

func (g *Generator) renderFieldIntoPlain(
	out typeWriter,
	ir *TypePbIR,
	msg *typepb.Type,
	field *typepb.Field,
	fieldName string,
	segments []pbPathSegment,
	casterTypes casterTypes,
	messageCasterTypes map[string]casterTypes,
	indent string,
	pathString string,
	setCrf bool,
) {
	_ = msg
	if alias, ok := g.typeAliasInfoForTypeURL(field.TypeUrl); ok {
		if len(segments) == 0 {
			out.P(indent, "// skip invalid alias path")
			return
		}
		leafAccess, innerIndent, closers, ok := g.renderPathAccessForGet(out, "x", segments, indent)
		if !ok {
			out.P(indent, "// skip invalid alias path")
			return
		}
		if field.Cardinality == typepb.Field_CARDINALITY_REPEATED {
			out.P(innerIndent, "if len(", leafAccess, ") > 0 {")
			out.P(innerIndent, "\tvals := make([]", g.scalarGoType(&typepb.Field{Kind: alias.kind}), ", 0, len(", leafAccess, "))")
			out.P(innerIndent, "\tfor _, v := range ", leafAccess, " {")
			out.P(innerIndent, "\t\tif v == nil {")
			out.P(innerIndent, "\t\t\tcontinue")
			out.P(innerIndent, "\t\t}")
			out.P(innerIndent, "\t\tvals = append(vals, v.", alias.fieldGoName, ")")
			out.P(innerIndent, "\t}")
			out.P(innerIndent, "\tout.", fieldName, " = vals")
			out.P(innerIndent, "}")
			closeGuards(out, innerIndent, closers)
			return
		}
		out.P(innerIndent, "if ", leafAccess, " != nil {")
		out.P(innerIndent, "\tval := ", leafAccess, ".", alias.fieldGoName)
		if g.isPointerField(field) {
			out.P(innerIndent, "\tout.", fieldName, " = &val")
		} else {
			out.P(innerIndent, "\tout.", fieldName, " = val")
		}
		out.P(innerIndent, "}")
		closeGuards(out, innerIndent, closers)
		return
	}
	if info, ok := mapFieldInfoFor(field); ok {
		if len(segments) == 0 {
			out.P(indent, "// skip invalid map path")
			return
		}
		leafAccess, innerIndent, closers, ok := g.renderPathAccessForGet(out, "x", segments, indent)
		if !ok {
			out.P(indent, "// skip invalid map path")
			return
		}
		if info.valueKind == typepb.Field_TYPE_ENUM {
			enumType := g.mapEnumGoType(out, segments[len(segments)-1])
			if enumType == "" {
				out.P(innerIndent, "if len(", leafAccess, ") > 0 {")
				out.P(innerIndent, "\tout.", fieldName, " = ", leafAccess)
				out.P(innerIndent, "}")
				closeGuards(out, innerIndent, closers)
				return
			}
			out.P(innerIndent, "if len(", leafAccess, ") > 0 {")
			out.P(innerIndent, "\tvals := make(map[", mapScalarGoType(info.keyKind), "]int32, len(", leafAccess, "))")
			out.P(innerIndent, "\tfor k, v := range ", leafAccess, " {")
			out.P(innerIndent, "\t\tvals[k] = int32(v)")
			out.P(innerIndent, "\t}")
			out.P(innerIndent, "\tout.", fieldName, " = vals")
			out.P(innerIndent, "}")
			closeGuards(out, innerIndent, closers)
			return
		}
		out.P(innerIndent, "if len(", leafAccess, ") > 0 {")
		out.P(innerIndent, "\tout.", fieldName, " = ", leafAccess)
		out.P(innerIndent, "}")
		closeGuards(out, innerIndent, closers)
		return
	}
	if g.hasOverride(field) {
		g.renderOverrideIntoPlain(out, ir, msg, field, fieldName, segments, casterTypes, indent, pathString, setCrf)
		return
	}
	switch field.Kind {
	case typepb.Field_TYPE_MESSAGE:
		if !g.isPlainMessage(ir, field.TypeUrl) {
			leafAccess, innerIndent, closers, ok := g.renderPathAccessForGet(out, "x", segments, indent)
			if !ok {
				out.P(indent, "// skip invalid path")
				return
			}
			if field.Cardinality == typepb.Field_CARDINALITY_REPEATED {
				out.P(innerIndent, "if len(", leafAccess, ") > 0 {")
				out.P(innerIndent, "\tout.", fieldName, " = ", leafAccess)
				out.P(innerIndent, "}")
				closeGuards(out, innerIndent, closers)
				return
			}
			out.P(innerIndent, "if ", leafAccess, " != nil {")
			out.P(innerIndent, "\tout.", fieldName, " = ", leafAccess)
			out.P(innerIndent, "}")
			closeGuards(out, innerIndent, closers)
			return
		}
		if field.Cardinality == typepb.Field_CARDINALITY_REPEATED {
			out.P(indent, "// repeated message is not supported")
			return
		}
		leafAccess, innerIndent, closers, ok := g.renderPathAccessForGet(out, "x", segments, indent)
		if !ok {
			out.P(indent, "// skip invalid path")
			return
		}
		out.P(innerIndent, "if ", leafAccess, " != nil {")
		innerIndent += "\t"
		childArgs := g.childCasterArgs(ir, field, messageCasterTypes, false)
		out.P(innerIndent, "out.", fieldName, " = ", leafAccess, ".IntoPlain(", childArgs, ")")
		if setCrf {
			out.P(innerIndent, "out.", goFieldNameFromPlain(g.plainName(field)+"CRF"), " = ", fmt.Sprintf("%q", pathString))
		}
		innerIndent = strings.TrimSuffix(innerIndent, "\t")
		out.P(innerIndent, "}")
		closeGuards(out, innerIndent, closers)
	default:
		g.renderScalarIntoPlain(out, field, fieldName, segments, indent, pathString, setCrf)
	}
}

func (g *Generator) renderFieldIntoPlainErr(
	out typeWriter,
	ir *TypePbIR,
	msg *typepb.Type,
	field *typepb.Field,
	fieldName string,
	segments []pbPathSegment,
	casterTypes casterTypes,
	messageCasterTypes map[string]casterTypes,
	indent string,
	pathString string,
	setCrf bool,
) {
	_ = msg
	if alias, ok := g.typeAliasInfoForTypeURL(field.TypeUrl); ok {
		if len(segments) == 0 {
			out.P(indent, "// skip invalid alias path")
			return
		}
		leafAccess, innerIndent, closers, ok := g.renderPathAccessForGet(out, "x", segments, indent)
		if !ok {
			out.P(indent, "// skip invalid alias path")
			return
		}
		if field.Cardinality == typepb.Field_CARDINALITY_REPEATED {
			out.P(innerIndent, "if len(", leafAccess, ") > 0 {")
			out.P(innerIndent, "\tvals := make([]", g.scalarGoType(&typepb.Field{Kind: alias.kind}), ", 0, len(", leafAccess, "))")
			out.P(innerIndent, "\tfor _, v := range ", leafAccess, " {")
			out.P(innerIndent, "\t\tif v == nil {")
			out.P(innerIndent, "\t\t\tcontinue")
			out.P(innerIndent, "\t\t}")
			out.P(innerIndent, "\t\tvals = append(vals, v.", alias.fieldGoName, ")")
			out.P(innerIndent, "\t}")
			out.P(innerIndent, "\tout.", fieldName, " = vals")
			out.P(innerIndent, "}")
			closeGuards(out, innerIndent, closers)
			return
		}
		out.P(innerIndent, "if ", leafAccess, " != nil {")
		out.P(innerIndent, "\tval := ", leafAccess, ".", alias.fieldGoName)
		if g.isPointerField(field) {
			out.P(innerIndent, "\tout.", fieldName, " = &val")
		} else {
			out.P(innerIndent, "\tout.", fieldName, " = val")
		}
		out.P(innerIndent, "}")
		closeGuards(out, innerIndent, closers)
		return
	}
	if info, ok := mapFieldInfoFor(field); ok {
		if len(segments) == 0 {
			out.P(indent, "// skip invalid map path")
			return
		}
		leafAccess, innerIndent, closers, ok := g.renderPathAccessForGet(out, "x", segments, indent)
		if !ok {
			out.P(indent, "// skip invalid map path")
			return
		}
		if info.valueKind == typepb.Field_TYPE_ENUM {
			enumType := g.mapEnumGoType(out, segments[len(segments)-1])
			if enumType == "" {
				out.P(innerIndent, "if len(", leafAccess, ") > 0 {")
				out.P(innerIndent, "\tout.", fieldName, " = ", leafAccess)
				out.P(innerIndent, "}")
				closeGuards(out, innerIndent, closers)
				return
			}
			out.P(innerIndent, "if len(", leafAccess, ") > 0 {")
			out.P(innerIndent, "\tvals := make(map[", mapScalarGoType(info.keyKind), "]int32, len(", leafAccess, "))")
			out.P(innerIndent, "\tfor k, v := range ", leafAccess, " {")
			out.P(innerIndent, "\t\tvals[k] = int32(v)")
			out.P(innerIndent, "\t}")
			out.P(innerIndent, "\tout.", fieldName, " = vals")
			out.P(innerIndent, "}")
			closeGuards(out, innerIndent, closers)
			return
		}
		out.P(innerIndent, "if len(", leafAccess, ") > 0 {")
		out.P(innerIndent, "\tout.", fieldName, " = ", leafAccess)
		out.P(innerIndent, "}")
		closeGuards(out, innerIndent, closers)
		return
	}
	if g.hasOverride(field) {
		g.renderOverrideIntoPlainErr(out, ir, msg, field, fieldName, segments, casterTypes, indent, pathString, setCrf)
		return
	}
	switch field.Kind {
	case typepb.Field_TYPE_MESSAGE:
		if !g.isPlainMessage(ir, field.TypeUrl) {
			leafAccess, innerIndent, closers, ok := g.renderPathAccessForGet(out, "x", segments, indent)
			if !ok {
				out.P(indent, "// skip invalid path")
				return
			}
			if field.Cardinality == typepb.Field_CARDINALITY_REPEATED {
				out.P(innerIndent, "if len(", leafAccess, ") > 0 {")
				out.P(innerIndent, "\tout.", fieldName, " = ", leafAccess)
				out.P(innerIndent, "}")
				closeGuards(out, innerIndent, closers)
				return
			}
			out.P(innerIndent, "if ", leafAccess, " != nil {")
			out.P(innerIndent, "\tout.", fieldName, " = ", leafAccess)
			out.P(innerIndent, "}")
			closeGuards(out, innerIndent, closers)
			return
		}
		if field.Cardinality == typepb.Field_CARDINALITY_REPEATED {
			out.P(indent, "// repeated message is not supported")
			return
		}
		leafAccess, innerIndent, closers, ok := g.renderPathAccessForGet(out, "x", segments, indent)
		if !ok {
			out.P(indent, "// skip invalid path")
			return
		}
		out.P(innerIndent, "if ", leafAccess, " != nil {")
		innerIndent += "\t"
		childArgs := g.childCasterArgs(ir, field, messageCasterTypes, false)
		out.P(innerIndent, "plainVal, err := ", leafAccess, ".IntoPlainErr(", childArgs, ")")
		out.P(innerIndent, "if err != nil {")
		out.P(innerIndent, "\treturn nil, err")
		out.P(innerIndent, "}")
		out.P(innerIndent, "out.", fieldName, " = plainVal")
		if setCrf {
			out.P(innerIndent, "out.", goFieldNameFromPlain(g.plainName(field)+"CRF"), " = ", fmt.Sprintf("%q", pathString))
		}
		innerIndent = strings.TrimSuffix(innerIndent, "\t")
		out.P(innerIndent, "}")
		closeGuards(out, innerIndent, closers)
	default:
		g.renderScalarIntoPlain(out, field, fieldName, segments, indent, pathString, setCrf)
	}
}

func (g *Generator) isPointerField(field *typepb.Field) bool {
	if field.Cardinality == typepb.Field_CARDINALITY_REPEATED {
		return false
	}
	return hasMarker(field.TypeUrl, isOneoffedMarker) ||
		(hasMarker(field.TypeUrl, crfMarker) && !hasMarker(field.TypeUrl, crfForMarker))
}

func (g *Generator) fieldPath(field *typepb.Field) []string {
	raw := ""
	for _, segment := range empath.Parse(field.TypeUrl) {
		if v := segment.GetMarker(empathMarker); v != "" {
			raw = v
			break
		}
	}
	if raw == "" {
		raw = field.Name
	} else {
		raw = decodeEmpath(raw)
	}
	path := empath.Parse(raw)
	var parts []string
	for _, segment := range path {
		if segment.HasMarker(isOneoffedMarker) {
			continue
		}
		name := getShortName(segment.Value())
		if name == "" {
			continue
		}
		parts = append(parts, name)
	}
	return parts
}

func (g *Generator) pathVarName(field *typepb.Field) string {
	return "_path" + strcase.ToCamel(g.plainName(field))
}

func quoteSlice(parts []string) string {
	if len(parts) == 0 {
		return ""
	}
	var b strings.Builder
	for i, p := range parts {
		if i > 0 {
			b.WriteString(", ")
		}
		b.WriteString(fmt.Sprintf("%q", p))
	}
	return b.String()
}

func (g *Generator) resolvePbTypeName(ir *TypePbIR, typeURL string) string {
	target := empath.Parse(typeURL).Last().Value()
	for _, m := range ir.Messages {
		if empath.Parse(m.Name).Last().Value() == target {
			if !g.isPbMessage(ir, m.Name) {
				return ""
			}
			return strcase.ToCamel(getShortName(m.Name))
		}
	}
	return strcase.ToCamel(getShortName(target))
}

func (g *Generator) isPbMessage(ir *TypePbIR, fullName string) bool {
	if ir == nil || ir.File == nil {
		return false
	}
	target := getShortName(fullName)
	for _, m := range ir.File.Messages {
		if string(m.Desc.Name()) == target {
			return true
		}
	}
	return false
}

// helper functions are in package into

func (g *Generator) hasCrfFields(ir *TypePbIR) bool {
	if ir == nil {
		return false
	}
	for _, msg := range ir.Messages {
		for _, field := range msg.Fields {
			if hasMarker(field.TypeUrl, crfMarker) && !hasMarker(field.TypeUrl, crfForMarker) {
				return true
			}
		}
	}
	return false
}

type pbPathSegment struct {
	protoName      string
	goName         string
	messageGoType  string
	isOneof        bool
	oneofGoName    string
	oneofWrapperGo string
	field          *protogen.Field
}

func (g *Generator) qualifyGoIdent(out typeWriter, ident protogen.GoIdent) string {
	type qualifier interface {
		QualifiedGoIdent(protogen.GoIdent) string
	}
	if q, ok := out.(qualifier); ok {
		return q.QualifiedGoIdent(ident)
	}
	return ident.GoName
}

func (g *Generator) findPbMessage(ir *TypePbIR, fullName string) *protogen.Message {
	if ir == nil || ir.File == nil {
		return nil
	}
	target := getShortName(fullName)
	for _, m := range ir.File.Messages {
		if string(m.Desc.Name()) == target {
			return m
		}
	}
	return nil
}

func (g *Generator) findPbField(msg *protogen.Message, protoName string) *protogen.Field {
	if msg == nil {
		return nil
	}
	for _, f := range msg.Fields {
		if string(f.Desc.Name()) == protoName {
			return f
		}
	}
	return nil
}

func (g *Generator) oneofWrapperType(parentQualified, fieldGoName string) string {
	if idx := strings.LastIndex(parentQualified, "."); idx >= 0 {
		pkg := parentQualified[:idx]
		parent := parentQualified[idx+1:]
		return pkg + "." + parent + "_" + fieldGoName
	}
	return parentQualified + "_" + fieldGoName
}

func (g *Generator) pbPathSegments(out typeWriter, ir *TypePbIR, msg *typepb.Type, path []string) ([]pbPathSegment, bool) {
	if len(path) == 0 {
		return nil, false
	}
	pbMsg := g.findPbMessage(ir, msg.Name)
	if pbMsg == nil {
		return nil, false
	}
	current := pbMsg
	currentQualified := g.qualifyGoIdent(out, current.GoIdent)
	segments := make([]pbPathSegment, 0, len(path))
	for i, name := range path {
		field := g.findPbField(current, name)
		if field == nil {
			return nil, false
		}
		seg := pbPathSegment{
			protoName: name,
			goName:    field.GoName,
			field:     field,
		}
		if i < len(path)-1 && field.Desc.Kind() == protoreflect.MessageKind && field.Message != nil {
			seg.messageGoType = g.qualifyGoIdent(out, field.Message.GoIdent)
		}
		if field.Oneof != nil && !field.Oneof.Desc.IsSynthetic() {
			seg.isOneof = true
			seg.oneofGoName = field.Oneof.GoName
			seg.oneofWrapperGo = g.oneofWrapperType(currentQualified, field.GoName)
		}
		segments = append(segments, seg)
		if i < len(path)-1 {
			if field.Desc.Kind() != protoreflect.MessageKind || field.Message == nil {
				return nil, false
			}
			current = field.Message
			currentQualified = g.qualifyGoIdent(out, current.GoIdent)
		}
	}
	return segments, true
}

func (g *Generator) oneofVarName(seg pbPathSegment, idx int) string {
	return fmt.Sprintf("_oneof%s%d", strcase.ToCamel(seg.goName), idx)
}

func (g *Generator) valueVarName(field *typepb.Field) string {
	return "_val" + strcase.ToCamel(g.plainName(field))
}

func isPointerScalarField(field *protogen.Field) bool {
	if field == nil {
		return false
	}
	if field.Desc.Cardinality() == protoreflect.Repeated {
		return false
	}
	if field.Oneof != nil && !field.Oneof.Desc.IsSynthetic() {
		return false
	}
	if field.Desc.Kind() == protoreflect.MessageKind {
		return false
	}
	return field.Desc.HasPresence()
}

func (g *Generator) renderEnsurePath(out typeWriter, base string, segments []pbPathSegment, indent string) (string, bool) {
	access := base
	for i := 0; i < len(segments)-1; i++ {
		seg := segments[i]
		if seg.isOneof {
			if seg.messageGoType == "" {
				return "", false
			}
			varName := g.oneofVarName(seg, i)
			out.P(indent, "var ", varName, " *", seg.messageGoType)
			out.P(indent, "if v, ok := ", access, ".", seg.oneofGoName, ".(*", seg.oneofWrapperGo, "); ok {")
			out.P(indent, "\t", varName, " = v.", seg.goName)
			out.P(indent, "}")
			out.P(indent, "if ", varName, " == nil {")
			out.P(indent, "\t", varName, " = &", seg.messageGoType, "{}")
			out.P(indent, "\t", access, ".", seg.oneofGoName, " = &", seg.oneofWrapperGo, "{", seg.goName, ": ", varName, "}")
			out.P(indent, "}")
			access = varName
			continue
		}
		if seg.messageGoType == "" {
			return "", false
		}
		accessField := access + "." + seg.goName
		out.P(indent, "if ", accessField, " == nil {")
		out.P(indent, "\t", accessField, " = &", seg.messageGoType, "{}")
		out.P(indent, "}")
		access = accessField
	}
	return access, true
}

func (g *Generator) renderPathAccessForGet(out typeWriter, base string, segments []pbPathSegment, indent string) (string, string, int, bool) {
	access := base
	closers := 0
	for i, seg := range segments {
		if seg.isOneof {
			varName := g.oneofVarName(seg, i)
			out.P(indent, "if ", varName, ", ok := ", access, ".", seg.oneofGoName, ".(*", seg.oneofWrapperGo, "); ok {")
			indent += "\t"
			closers++
			access = varName + "." + seg.goName
			if i < len(segments)-1 {
				out.P(indent, "if ", access, " != nil {")
				indent += "\t"
				closers++
			}
			continue
		}
		if i < len(segments)-1 {
			access = access + "." + seg.goName
			out.P(indent, "if ", access, " != nil {")
			indent += "\t"
			closers++
			continue
		}
		access = access + "." + seg.goName
	}
	return access, indent, closers, true
}

func (g *Generator) scalarPresenceExpr(expr string, kind typepb.Field_Kind, isEnum bool) string {
	if isEnum {
		return expr + " != 0"
	}
	switch kind {
	case typepb.Field_TYPE_STRING:
		return expr + " != \"\""
	case typepb.Field_TYPE_BOOL:
		return expr
	case typepb.Field_TYPE_BYTES:
		return "len(" + expr + ") > 0"
	case typepb.Field_TYPE_FLOAT, typepb.Field_TYPE_DOUBLE:
		return expr + " != 0"
	case typepb.Field_TYPE_INT32, typepb.Field_TYPE_SINT32, typepb.Field_TYPE_SFIXED32:
		return expr + " != 0"
	case typepb.Field_TYPE_UINT32, typepb.Field_TYPE_FIXED32:
		return expr + " != 0"
	case typepb.Field_TYPE_INT64, typepb.Field_TYPE_SINT64, typepb.Field_TYPE_SFIXED64:
		return expr + " != 0"
	case typepb.Field_TYPE_UINT64, typepb.Field_TYPE_FIXED64:
		return expr + " != 0"
	default:
		return ""
	}
}

func (g *Generator) crfPaths(field *typepb.Field) []string {
	if field == nil {
		return nil
	}
	raw := marker.Parse(field.TypeUrl).GetMarker(crfPathsMarker)
	if raw == "" {
		return nil
	}
	parts := strings.Split(raw, ",")
	paths := make([]string, 0, len(parts))
	for _, part := range parts {
		if part == "" {
			continue
		}
		paths = append(paths, decodeEmpath(part))
	}
	return paths
}

func (g *Generator) enumGoType(out typeWriter, seg pbPathSegment) string {
	if seg.field == nil || seg.field.Enum == nil {
		return ""
	}
	return g.qualifyGoIdent(out, seg.field.Enum.GoIdent)
}

func (g *Generator) mapEnumGoType(out typeWriter, seg pbPathSegment) string {
	if seg.field == nil || seg.field.Message == nil || len(seg.field.Message.Fields) < 2 {
		return ""
	}
	valField := seg.field.Message.Fields[1]
	if valField.Enum == nil {
		return ""
	}
	return g.qualifyGoIdent(out, valField.Enum.GoIdent)
}

func (g *Generator) expandCrfPaths(paths []string, basePath string) []string {
	seen := make(map[string]struct{})
	ordered := make([]string, 0, len(paths)+1)
	appendUnique := func(p string) {
		if p == "" {
			return
		}
		if _, ok := seen[p]; ok {
			return
		}
		seen[p] = struct{}{}
		ordered = append(ordered, p)
	}

	appendUnique(basePath)
	for _, p := range paths {
		if p == "" {
			continue
		}
		if basePath != "" && strings.HasSuffix(basePath, p) {
			prefix := strings.TrimSuffix(basePath, p)
			prefix = strings.TrimSuffix(prefix, "/")
			if prefix != "" {
				appendUnique(prefix + "/" + p)
			} else {
				appendUnique(p)
			}
		}
	}
	for _, p := range paths {
		appendUnique(p)
	}
	return ordered
}

func closeGuards(out typeWriter, indent string, closers int) {
	for i := 0; i < closers; i++ {
		indent = strings.TrimSuffix(indent, "\t")
		out.P(indent, "}")
	}
}

type casterTypes struct {
	list  []casterTypeInfo
	byKey map[string]casterTypeInfo
}

type casterTypeInfo struct {
	pbElemType        string
	plainElemType     string
	importPath        string
	needsProtoReflect bool
}

func (g *Generator) collectMessageCasterTypes(ir *TypePbIR) map[string]casterTypes {
	result := make(map[string]casterTypes)
	if ir == nil {
		return result
	}
	visiting := make(map[string]bool)
	for _, msg := range ir.Messages {
		_ = g.messageCasterTypes(ir, msg, visiting, result)
	}
	return result
}

func (g *Generator) collectFileCasterTypes(messageCasterTypes map[string]casterTypes) casterTypes {
	result := casterTypes{byKey: make(map[string]casterTypeInfo)}
	for _, ct := range messageCasterTypes {
		result = g.mergeCasterTypes(result, ct)
	}
	result.list = g.sortedCasterTypes(result.byKey)
	return result
}

func (g *Generator) messageCasterTypes(ir *TypePbIR, msg *typepb.Type, visiting map[string]bool, cache map[string]casterTypes) casterTypes {
	if msg == nil {
		return casterTypes{byKey: make(map[string]casterTypeInfo)}
	}
	if cached, ok := cache[msg.Name]; ok {
		return cached
	}
	if visiting[msg.Name] {
		return casterTypes{byKey: make(map[string]casterTypeInfo)}
	}
	visiting[msg.Name] = true
	result := casterTypes{byKey: make(map[string]casterTypeInfo)}
	for _, field := range msg.Fields {
		if field.OneofIndex > 0 {
			continue
		}
		if override, ok := g.overrideInfo(field); ok {
			pbElemType, needsProtoReflect := g.overridePbElemType(ir, field)
			result = g.addCasterType(result, pbElemType, override.name, override.importPath, needsProtoReflect)
			continue
		}
		if field.Kind == typepb.Field_TYPE_MESSAGE {
			embedded, ok := g.findMessage(ir, field.TypeUrl)
			if !ok {
				continue
			}
			child := g.messageCasterTypes(ir, embedded, visiting, cache)
			result = g.mergeCasterTypes(result, child)
		}
	}
	result.list = g.sortedCasterTypes(result.byKey)
	cache[msg.Name] = result
	visiting[msg.Name] = false
	return result
}

func (g *Generator) addCasterType(
	dst casterTypes,
	pbElemType, plainElemType, importPath string,
	needsProtoReflect bool,
) casterTypes {
	if dst.byKey == nil {
		dst.byKey = make(map[string]casterTypeInfo)
	}
	key := g.casterTypeKey(pbElemType, plainElemType)
	if _, ok := dst.byKey[key]; ok {
		return dst
	}
	dst.byKey[key] = casterTypeInfo{
		pbElemType:        pbElemType,
		plainElemType:     plainElemType,
		importPath:        importPath,
		needsProtoReflect: needsProtoReflect,
	}
	return dst
}

func (g *Generator) mergeCasterTypes(dst, src casterTypes) casterTypes {
	for key, ct := range src.byKey {
		if _, ok := dst.byKey[key]; ok {
			continue
		}
		dst.byKey[key] = ct
	}
	return dst
}

func (g *Generator) sortedCasterTypes(byKey map[string]casterTypeInfo) []casterTypeInfo {
	if len(byKey) == 0 {
		return nil
	}
	list := make([]casterTypeInfo, 0, len(byKey))
	for _, ct := range byKey {
		list = append(list, ct)
	}
	sort.Slice(list, func(i, j int) bool {
		left := g.casterTypeKey(list[i].pbElemType, list[i].plainElemType)
		right := g.casterTypeKey(list[j].pbElemType, list[j].plainElemType)
		return left < right
	})
	return list
}

func (g *Generator) hasOverride(field *typepb.Field) bool {
	_, ok := g.overrideInfo(field)
	return ok
}

func (g *Generator) casterTypeKey(pbType, plainType string) string {
	return pbType + "|" + plainType
}

func (g *Generator) casterTypeIdent(t string) string {
	ident := t
	ident = strings.ReplaceAll(ident, "[]", "Slice")
	ident = strings.ReplaceAll(ident, "*", "Ptr")
	ident = strings.ReplaceAll(ident, ".", "_")
	ident = strings.ReplaceAll(ident, " ", "")
	return strcase.ToCamel(ident)
}

func (g *Generator) casterParamNameForTypes(pbType, plainType string, toPb bool) string {
	if toPb {
		return "caster" + g.casterTypeIdent(plainType) + "To" + g.casterTypeIdent(pbType)
	}
	return "caster" + g.casterTypeIdent(pbType) + "To" + g.casterTypeIdent(plainType)
}

func (g *Generator) casterParamList(list []casterTypeInfo, toPb, withErr bool) string {
	if len(list) == 0 {
		return ""
	}
	var b strings.Builder
	for i, ct := range list {
		if i > 0 {
			b.WriteString(", ")
		}
		casterType := "cast.Caster"
		if withErr {
			casterType = "cast.CasterErr"
		}
		paramName := g.casterParamNameForTypes(ct.pbElemType, ct.plainElemType, toPb)
		if toPb {
			fmt.Fprintf(&b, "%s %s[%s, %s]", paramName, casterType, ct.plainElemType, ct.pbElemType)
		} else {
			fmt.Fprintf(&b, "%s %s[%s, %s]", paramName, casterType, ct.pbElemType, ct.plainElemType)
		}
	}
	return b.String()
}

func (g *Generator) casterArgList(list []casterTypeInfo, toPb bool) string {
	if len(list) == 0 {
		return ""
	}
	var b strings.Builder
	for i, ct := range list {
		if i > 0 {
			b.WriteString(", ")
		}
		b.WriteString(g.casterParamNameForTypes(ct.pbElemType, ct.plainElemType, toPb))
	}
	return b.String()
}

func (g *Generator) casterParamName(ir *TypePbIR, field *typepb.Field, casterTypes casterTypes, toPb bool) string {
	override, ok := g.overrideInfo(field)
	if !ok {
		return ""
	}
	pbElemType, _ := g.overridePbElemType(ir, field)
	key := g.casterTypeKey(pbElemType, override.name)
	if ct, ok := casterTypes.byKey[key]; ok {
		return g.casterParamNameForTypes(ct.pbElemType, ct.plainElemType, toPb)
	}
	return ""
}

func (g *Generator) childCasterArgs(
	ir *TypePbIR,
	field *typepb.Field,
	messageCasterTypes map[string]casterTypes,
	toPb bool,
) string {
	if field == nil || field.Kind != typepb.Field_TYPE_MESSAGE {
		return ""
	}
	embedded, ok := g.findMessage(ir, field.TypeUrl)
	if !ok {
		return ""
	}
	child := messageCasterTypes[embedded.Name]
	return g.casterArgList(child.list, toPb)
}

func (g *Generator) overridePbElemType(ir *TypePbIR, field *typepb.Field) (string, bool) {
	switch field.Kind {
	case typepb.Field_TYPE_DOUBLE:
		return "float64", false
	case typepb.Field_TYPE_FLOAT:
		return "float32", false
	case typepb.Field_TYPE_INT64, typepb.Field_TYPE_SINT64, typepb.Field_TYPE_SFIXED64:
		return "int64", false
	case typepb.Field_TYPE_UINT64, typepb.Field_TYPE_FIXED64:
		return "uint64", false
	case typepb.Field_TYPE_INT32, typepb.Field_TYPE_SINT32, typepb.Field_TYPE_SFIXED32:
		return "int32", false
	case typepb.Field_TYPE_UINT32, typepb.Field_TYPE_FIXED32:
		return "uint32", false
	case typepb.Field_TYPE_BOOL:
		return "bool", false
	case typepb.Field_TYPE_STRING:
		return "string", false
	case typepb.Field_TYPE_BYTES:
		return "[]byte", false
	case typepb.Field_TYPE_ENUM:
		return "protoreflect.EnumNumber", true
	case typepb.Field_TYPE_MESSAGE:
		pbType := g.resolvePbTypeName(ir, field.TypeUrl)
		if pbType == "" {
			pbType = strcase.ToCamel(getShortName(field.Name))
		}
		return "*" + pbType, false
	default:
		return "any", false
	}
}

func (g *Generator) scalarSetter(kind typepb.Field_Kind) string {
	switch kind {
	case typepb.Field_TYPE_STRING:
		return "into.SetString"
	case typepb.Field_TYPE_BOOL:
		return "into.SetBool"
	case typepb.Field_TYPE_INT32, typepb.Field_TYPE_SINT32, typepb.Field_TYPE_SFIXED32:
		return "into.SetInt32"
	case typepb.Field_TYPE_UINT32, typepb.Field_TYPE_FIXED32:
		return "into.SetUint32"
	case typepb.Field_TYPE_INT64, typepb.Field_TYPE_SINT64, typepb.Field_TYPE_SFIXED64:
		return "into.SetInt64"
	case typepb.Field_TYPE_UINT64, typepb.Field_TYPE_FIXED64:
		return "into.SetUint64"
	case typepb.Field_TYPE_FLOAT:
		return "into.SetFloat32"
	case typepb.Field_TYPE_DOUBLE:
		return "into.SetFloat64"
	case typepb.Field_TYPE_BYTES:
		return "into.SetBytes"
	case typepb.Field_TYPE_ENUM:
		return "into.SetEnum"
	default:
		return ""
	}
}

func (g *Generator) scalarListSetter(kind typepb.Field_Kind) string {
	switch kind {
	case typepb.Field_TYPE_STRING:
		return "into.SetStringList"
	case typepb.Field_TYPE_BOOL:
		return "into.SetBoolList"
	case typepb.Field_TYPE_INT32, typepb.Field_TYPE_SINT32, typepb.Field_TYPE_SFIXED32:
		return "into.SetInt32List"
	case typepb.Field_TYPE_UINT32, typepb.Field_TYPE_FIXED32:
		return "into.SetUint32List"
	case typepb.Field_TYPE_INT64, typepb.Field_TYPE_SINT64, typepb.Field_TYPE_SFIXED64:
		return "into.SetInt64List"
	case typepb.Field_TYPE_UINT64, typepb.Field_TYPE_FIXED64:
		return "into.SetUint64List"
	case typepb.Field_TYPE_FLOAT:
		return "into.SetFloat32List"
	case typepb.Field_TYPE_DOUBLE:
		return "into.SetFloat64List"
	case typepb.Field_TYPE_BYTES:
		return "into.SetBytesList"
	case typepb.Field_TYPE_ENUM:
		return "into.SetEnumList"
	default:
		return ""
	}
}

func (g *Generator) scalarGetter(kind typepb.Field_Kind) string {
	switch kind {
	case typepb.Field_TYPE_STRING:
		return "into.GetString"
	case typepb.Field_TYPE_BOOL:
		return "into.GetBool"
	case typepb.Field_TYPE_INT32, typepb.Field_TYPE_SINT32, typepb.Field_TYPE_SFIXED32:
		return "into.GetInt32"
	case typepb.Field_TYPE_UINT32, typepb.Field_TYPE_FIXED32:
		return "into.GetUint32"
	case typepb.Field_TYPE_INT64, typepb.Field_TYPE_SINT64, typepb.Field_TYPE_SFIXED64:
		return "into.GetInt64"
	case typepb.Field_TYPE_UINT64, typepb.Field_TYPE_FIXED64:
		return "into.GetUint64"
	case typepb.Field_TYPE_FLOAT:
		return "into.GetFloat32"
	case typepb.Field_TYPE_DOUBLE:
		return "into.GetFloat64"
	case typepb.Field_TYPE_BYTES:
		return "into.GetBytes"
	case typepb.Field_TYPE_ENUM:
		return "into.GetEnum"
	default:
		return ""
	}
}

func (g *Generator) scalarListGetter(kind typepb.Field_Kind) string {
	switch kind {
	case typepb.Field_TYPE_STRING:
		return "into.GetStringList"
	case typepb.Field_TYPE_BOOL:
		return "into.GetBoolList"
	case typepb.Field_TYPE_INT32, typepb.Field_TYPE_SINT32, typepb.Field_TYPE_SFIXED32:
		return "into.GetInt32List"
	case typepb.Field_TYPE_UINT32, typepb.Field_TYPE_FIXED32:
		return "into.GetUint32List"
	case typepb.Field_TYPE_INT64, typepb.Field_TYPE_SINT64, typepb.Field_TYPE_SFIXED64:
		return "into.GetInt64List"
	case typepb.Field_TYPE_UINT64, typepb.Field_TYPE_FIXED64:
		return "into.GetUint64List"
	case typepb.Field_TYPE_FLOAT:
		return "into.GetFloat32List"
	case typepb.Field_TYPE_DOUBLE:
		return "into.GetFloat64List"
	case typepb.Field_TYPE_BYTES:
		return "into.GetBytesList"
	case typepb.Field_TYPE_ENUM:
		return "into.GetEnumList"
	default:
		return ""
	}
}

func (g *Generator) renderOverrideIntoPb(out typeWriter, ir *TypePbIR, msg *typepb.Type, field *typepb.Field, fieldName string, segments []pbPathSegment, casterTypes casterTypes, indent string) {
	_ = msg
	casterName := g.casterParamName(ir, field, casterTypes, true)
	if casterName == "" {
		out.P(indent, "// missing caster mapping for override")
		return
	}
	if len(segments) == 0 {
		out.P(indent, "// skip invalid path")
		return
	}
	leaf := segments[len(segments)-1]
	switch field.Kind {
	case typepb.Field_TYPE_MESSAGE:
		if field.Cardinality == typepb.Field_CARDINALITY_REPEATED {
			out.P(indent, "// repeated message with override is not supported")
			return
		}
		out.P(indent, "if x.", fieldName, " != nil {")
		inner := indent + "\t"
		access, ok := g.renderEnsurePath(out, "out", segments, inner)
		if !ok {
			out.P(inner, "// skip invalid path")
			out.P(indent, "}")
			return
		}
		out.P(inner, "if ", casterName, " == nil {")
		out.P(inner, "\tpanic(\"missing caster: ", casterName, "\")")
		out.P(inner, "}")
		valueExpr := "x." + fieldName
		if g.isPointerField(field) {
			valueExpr = "*" + valueExpr
		}
		out.P(inner, "pbVal := ", casterName, ".Cast(", valueExpr, ")")
		out.P(inner, "if pbVal != nil {")
		g.renderAssignMessageAtLeaf(out, leaf, access, "pbVal", inner+"\t")
		out.P(inner, "}")
		out.P(indent, "}")
		return
	default:
		if field.Cardinality == typepb.Field_CARDINALITY_REPEATED {
			out.P(indent, "if len(x.", fieldName, ") > 0 {")
			inner := indent + "\t"
			access, ok := g.renderEnsurePath(out, "out", segments, inner)
			if !ok {
				out.P(inner, "// skip invalid path")
				out.P(indent, "}")
				return
			}
			out.P(inner, "if ", casterName, " == nil {")
			out.P(inner, "\tpanic(\"missing caster: ", casterName, "\")")
			out.P(inner, "}")
			enumType := g.enumGoType(out, leaf)
			if enumType != "" {
				valVar := g.valueVarName(field) + "Slice"
				out.P(inner, valVar, " := make([]", enumType, ", len(x.", fieldName, "))")
				out.P(inner, "for i, el := range x.", fieldName, " {")
				out.P(inner, "\t", valVar, "[i] = ", enumType, "(", casterName, ".Cast(el))")
				out.P(inner, "}")
				out.P(inner, access, ".", leaf.goName, " = ", valVar)
			} else {
				pbElemType, _ := g.overridePbElemType(ir, field)
				out.P(inner, "vals := make([]", pbElemType, ", len(x.", fieldName, "))")
				out.P(inner, "for i, el := range x.", fieldName, " {")
				out.P(inner, "\tvals[i] = ", casterName, ".Cast(el)")
				out.P(inner, "}")
				out.P(inner, access, ".", leaf.goName, " = vals")
			}
			out.P(indent, "}")
			return
		}
		if g.isPointerField(field) {
			out.P(indent, "if x.", fieldName, " != nil {")
			inner := indent + "\t"
			access, ok := g.renderEnsurePath(out, "out", segments, inner)
			if !ok {
				out.P(inner, "// skip invalid path")
				out.P(indent, "}")
				return
			}
			out.P(inner, "if ", casterName, " == nil {")
			out.P(inner, "\tpanic(\"missing caster: ", casterName, "\")")
			out.P(inner, "}")
			out.P(inner, "val := ", casterName, ".Cast(*x.", fieldName, ")")
			g.renderAssignScalarAtLeaf(out, field, leaf, access, "val", inner)
			out.P(indent, "}")
			return
		}
		access, ok := g.renderEnsurePath(out, "out", segments, indent)
		if !ok {
			out.P(indent, "// skip invalid path")
			return
		}
		out.P(indent, "if ", casterName, " == nil {")
		out.P(indent, "\tpanic(\"missing caster: ", casterName, "\")")
		out.P(indent, "}")
		out.P(indent, "val := ", casterName, ".Cast(x.", fieldName, ")")
		g.renderAssignScalarAtLeaf(out, field, leaf, access, "val", indent)
	}
}

func (g *Generator) renderOverrideIntoPlain(
	out typeWriter,
	ir *TypePbIR,
	msg *typepb.Type,
	field *typepb.Field,
	fieldName string,
	segments []pbPathSegment,
	casterTypes casterTypes,
	indent string,
	pathString string,
	setCrf bool,
) {
	_ = msg
	casterName := g.casterParamName(ir, field, casterTypes, false)
	if casterName == "" {
		out.P(indent, "// missing caster mapping for override")
		return
	}
	if len(segments) == 0 {
		out.P(indent, "// skip invalid path")
		return
	}
	leaf := segments[len(segments)-1]
	enumType := g.enumGoType(out, leaf)

	switch field.Kind {
	case typepb.Field_TYPE_MESSAGE:
		if field.Cardinality == typepb.Field_CARDINALITY_REPEATED {
			out.P(indent, "// repeated message with override is not supported")
			return
		}
		leafAccess, innerIndent, closers, ok := g.renderPathAccessForGet(out, "x", segments, indent)
		if !ok {
			out.P(indent, "// skip invalid path")
			return
		}
		out.P(innerIndent, "if ", leafAccess, " != nil {")
		innerIndent += "\t"
		out.P(innerIndent, "if ", casterName, " == nil {")
		out.P(innerIndent, "\tpanic(\"missing caster: ", casterName, "\")")
		out.P(innerIndent, "}")
		if g.isPointerField(field) {
			valVar := g.valueVarName(field)
			out.P(innerIndent, valVar, " := ", casterName, ".Cast(", leafAccess, ")")
			out.P(innerIndent, "out.", fieldName, " = &", valVar)
		} else {
			out.P(innerIndent, "out.", fieldName, " = ", casterName, ".Cast(", leafAccess, ")")
		}
		if setCrf {
			out.P(innerIndent, "out.", goFieldNameFromPlain(g.plainName(field)+"CRF"), " = ", fmt.Sprintf("%q", pathString))
		}
		innerIndent = strings.TrimSuffix(innerIndent, "\t")
		out.P(innerIndent, "}")
		closeGuards(out, innerIndent, closers)
		return
	default:
		leafAccess, innerIndent, closers, ok := g.renderPathAccessForGet(out, "x", segments, indent)
		if !ok {
			out.P(indent, "// skip invalid path")
			return
		}
		if field.Cardinality == typepb.Field_CARDINALITY_REPEATED {
			out.P(innerIndent, "if len(", leafAccess, ") > 0 {")
			innerIndent += "\t"
			out.P(innerIndent, "if ", casterName, " == nil {")
			out.P(innerIndent, "\tpanic(\"missing caster: ", casterName, "\")")
			out.P(innerIndent, "}")
			override, _ := g.overrideInfo(field)
			out.P(innerIndent, "out.", fieldName, " = make([]", override.name, ", len(", leafAccess, "))")
			out.P(innerIndent, "for i, el := range ", leafAccess, " {")
			valueExpr := "el"
			if enumType != "" {
				valueExpr = "protoreflect.EnumNumber(el)"
			}
			out.P(innerIndent, "\tout.", fieldName, "[i] = ", casterName, ".Cast(", valueExpr, ")")
			out.P(innerIndent, "}")
			if setCrf {
				out.P(innerIndent, "out.", goFieldNameFromPlain(g.plainName(field)+"CRF"), " = ", fmt.Sprintf("%q", pathString))
			}
			innerIndent = strings.TrimSuffix(innerIndent, "\t")
			out.P(innerIndent, "}")
			closeGuards(out, innerIndent, closers)
			return
		}

		valueExpr := leafAccess
		if enumType != "" {
			valueExpr = "protoreflect.EnumNumber(" + valueExpr + ")"
		}

		if isPointerScalarField(leaf.field) {
			out.P(innerIndent, "if ", valueExpr, " != nil {")
			innerIndent += "\t"
			valueExpr = "*" + valueExpr
		} else if !leaf.isOneof {
			cond := g.scalarPresenceExpr(leafAccess, field.Kind, enumType != "")
			if cond != "" {
				out.P(innerIndent, "if ", cond, " {")
				innerIndent += "\t"
			}
		}
		out.P(innerIndent, "if ", casterName, " == nil {")
		out.P(innerIndent, "\tpanic(\"missing caster: ", casterName, "\")")
		out.P(innerIndent, "}")
		if g.isPointerField(field) {
			valVar := g.valueVarName(field)
			out.P(innerIndent, valVar, " := ", casterName, ".Cast(", valueExpr, ")")
			out.P(innerIndent, "out.", fieldName, " = &", valVar)
		} else {
			out.P(innerIndent, "out.", fieldName, " = ", casterName, ".Cast(", valueExpr, ")")
		}
		if setCrf {
			out.P(innerIndent, "out.", goFieldNameFromPlain(g.plainName(field)+"CRF"), " = ", fmt.Sprintf("%q", pathString))
		}
		if isPointerScalarField(leaf.field) || (!leaf.isOneof && g.scalarPresenceExpr(leafAccess, field.Kind, enumType != "") != "") {
			innerIndent = strings.TrimSuffix(innerIndent, "\t")
			out.P(innerIndent, "}")
		}
		closeGuards(out, innerIndent, closers)
	}
}

func (g *Generator) renderOverrideIntoPbErr(out typeWriter, ir *TypePbIR, msg *typepb.Type, field *typepb.Field, fieldName string, segments []pbPathSegment, casterTypes casterTypes, indent string) {
	_ = msg
	casterName := g.casterParamName(ir, field, casterTypes, true)
	if casterName == "" {
		out.P(indent, "// missing caster mapping for override")
		return
	}
	if len(segments) == 0 {
		out.P(indent, "// skip invalid path")
		return
	}
	leaf := segments[len(segments)-1]
	switch field.Kind {
	case typepb.Field_TYPE_MESSAGE:
		if field.Cardinality == typepb.Field_CARDINALITY_REPEATED {
			out.P(indent, "// repeated message with override is not supported")
			return
		}
		out.P(indent, "if x.", fieldName, " != nil {")
		inner := indent + "\t"
		access, ok := g.renderEnsurePath(out, "out", segments, inner)
		if !ok {
			out.P(inner, "// skip invalid path")
			out.P(indent, "}")
			return
		}
		out.P(inner, "if ", casterName, " == nil {")
		out.P(inner, "\treturn nil, fmt.Errorf(\"missing caster: ", casterName, "\")")
		out.P(inner, "}")
		valueExpr := "x." + fieldName
		if g.isPointerField(field) {
			valueExpr = "*" + valueExpr
		}
		out.P(inner, "pbVal, err := ", casterName, ".CastErr(", valueExpr, ")")
		out.P(inner, "if err != nil {")
		out.P(inner, "\treturn nil, err")
		out.P(inner, "}")
		out.P(inner, "if pbVal != nil {")
		g.renderAssignMessageAtLeaf(out, leaf, access, "pbVal", inner+"\t")
		out.P(inner, "}")
		out.P(indent, "}")
		return
	default:
		if field.Cardinality == typepb.Field_CARDINALITY_REPEATED {
			out.P(indent, "if len(x.", fieldName, ") > 0 {")
			inner := indent + "\t"
			access, ok := g.renderEnsurePath(out, "out", segments, inner)
			if !ok {
				out.P(inner, "// skip invalid path")
				out.P(indent, "}")
				return
			}
			out.P(inner, "if ", casterName, " == nil {")
			out.P(inner, "\treturn nil, fmt.Errorf(\"missing caster: ", casterName, "\")")
			out.P(inner, "}")
			enumType := g.enumGoType(out, leaf)
			if enumType != "" {
				valVar := g.valueVarName(field) + "Slice"
				out.P(inner, valVar, " := make([]", enumType, ", len(x.", fieldName, "))")
				out.P(inner, "for i, el := range x.", fieldName, " {")
				out.P(inner, "\tval, err := ", casterName, ".CastErr(el)")
				out.P(inner, "\tif err != nil {")
				out.P(inner, "\t\treturn nil, err")
				out.P(inner, "\t}")
				out.P(inner, "\t", valVar, "[i] = ", enumType, "(val)")
				out.P(inner, "}")
				out.P(inner, access, ".", leaf.goName, " = ", valVar)
			} else {
				pbElemType, _ := g.overridePbElemType(ir, field)
				out.P(inner, "vals := make([]", pbElemType, ", len(x.", fieldName, "))")
				out.P(inner, "for i, el := range x.", fieldName, " {")
				out.P(inner, "\tval, err := ", casterName, ".CastErr(el)")
				out.P(inner, "\tif err != nil {")
				out.P(inner, "\t\treturn nil, err")
				out.P(inner, "\t}")
				out.P(inner, "\tvals[i] = val")
				out.P(inner, "}")
				out.P(inner, access, ".", leaf.goName, " = vals")
			}
			out.P(indent, "}")
			return
		}
		if g.isPointerField(field) {
			out.P(indent, "if x.", fieldName, " != nil {")
			inner := indent + "\t"
			access, ok := g.renderEnsurePath(out, "out", segments, inner)
			if !ok {
				out.P(inner, "// skip invalid path")
				out.P(indent, "}")
				return
			}
			out.P(inner, "if ", casterName, " == nil {")
			out.P(inner, "\treturn nil, fmt.Errorf(\"missing caster: ", casterName, "\")")
			out.P(inner, "}")
			out.P(inner, "val, err := ", casterName, ".CastErr(*x.", fieldName, ")")
			out.P(inner, "if err != nil {")
			out.P(inner, "\treturn nil, err")
			out.P(inner, "}")
			g.renderAssignScalarAtLeaf(out, field, leaf, access, "val", inner)
			out.P(indent, "}")
			return
		}
		access, ok := g.renderEnsurePath(out, "out", segments, indent)
		if !ok {
			out.P(indent, "// skip invalid path")
			return
		}
		out.P(indent, "if ", casterName, " == nil {")
		out.P(indent, "\treturn nil, fmt.Errorf(\"missing caster: ", casterName, "\")")
		out.P(indent, "}")
		out.P(indent, "val, err := ", casterName, ".CastErr(x.", fieldName, ")")
		out.P(indent, "if err != nil {")
		out.P(indent, "\treturn nil, err")
		out.P(indent, "}")
		g.renderAssignScalarAtLeaf(out, field, leaf, access, "val", indent)
	}
}

func (g *Generator) renderOverrideIntoPlainErr(
	out typeWriter,
	ir *TypePbIR,
	msg *typepb.Type,
	field *typepb.Field,
	fieldName string,
	segments []pbPathSegment,
	casterTypes casterTypes,
	indent string,
	pathString string,
	setCrf bool,
) {
	_ = msg
	casterName := g.casterParamName(ir, field, casterTypes, false)
	if casterName == "" {
		out.P(indent, "// missing caster mapping for override")
		return
	}
	if len(segments) == 0 {
		out.P(indent, "// skip invalid path")
		return
	}
	leaf := segments[len(segments)-1]
	enumType := g.enumGoType(out, leaf)

	switch field.Kind {
	case typepb.Field_TYPE_MESSAGE:
		if field.Cardinality == typepb.Field_CARDINALITY_REPEATED {
			out.P(indent, "// repeated message with override is not supported")
			return
		}
		leafAccess, innerIndent, closers, ok := g.renderPathAccessForGet(out, "x", segments, indent)
		if !ok {
			out.P(indent, "// skip invalid path")
			return
		}
		out.P(innerIndent, "if ", leafAccess, " != nil {")
		innerIndent += "\t"
		out.P(innerIndent, "if ", casterName, " == nil {")
		out.P(innerIndent, "\treturn nil, fmt.Errorf(\"missing caster: ", casterName, "\")")
		out.P(innerIndent, "}")
		out.P(innerIndent, "val, err := ", casterName, ".CastErr(", leafAccess, ")")
		out.P(innerIndent, "if err != nil {")
		out.P(innerIndent, "\treturn nil, err")
		out.P(innerIndent, "}")
		if g.isPointerField(field) {
			out.P(innerIndent, "out.", fieldName, " = &val")
		} else {
			out.P(innerIndent, "out.", fieldName, " = val")
		}
		if setCrf {
			out.P(innerIndent, "out.", goFieldNameFromPlain(g.plainName(field)+"CRF"), " = ", fmt.Sprintf("%q", pathString))
		}
		innerIndent = strings.TrimSuffix(innerIndent, "\t")
		out.P(innerIndent, "}")
		closeGuards(out, innerIndent, closers)
		return
	default:
		leafAccess, innerIndent, closers, ok := g.renderPathAccessForGet(out, "x", segments, indent)
		if !ok {
			out.P(indent, "// skip invalid path")
			return
		}
		if field.Cardinality == typepb.Field_CARDINALITY_REPEATED {
			out.P(innerIndent, "if len(", leafAccess, ") > 0 {")
			innerIndent += "\t"
			out.P(innerIndent, "if ", casterName, " == nil {")
			out.P(innerIndent, "\treturn nil, fmt.Errorf(\"missing caster: ", casterName, "\")")
			out.P(innerIndent, "}")
			override, _ := g.overrideInfo(field)
			out.P(innerIndent, "out.", fieldName, " = make([]", override.name, ", len(", leafAccess, "))")
			out.P(innerIndent, "for i, el := range ", leafAccess, " {")
			valueExpr := "el"
			if enumType != "" {
				valueExpr = "protoreflect.EnumNumber(el)"
			}
			out.P(innerIndent, "\tval, err := ", casterName, ".CastErr(", valueExpr, ")")
			out.P(innerIndent, "\tif err != nil {")
			out.P(innerIndent, "\t\treturn nil, err")
			out.P(innerIndent, "\t}")
			out.P(innerIndent, "\tout.", fieldName, "[i] = val")
			out.P(innerIndent, "}")
			if setCrf {
				out.P(innerIndent, "out.", goFieldNameFromPlain(g.plainName(field)+"CRF"), " = ", fmt.Sprintf("%q", pathString))
			}
			innerIndent = strings.TrimSuffix(innerIndent, "\t")
			out.P(innerIndent, "}")
			closeGuards(out, innerIndent, closers)
			return
		}

		valueExpr := leafAccess
		if enumType != "" {
			valueExpr = "protoreflect.EnumNumber(" + valueExpr + ")"
		}
		if isPointerScalarField(leaf.field) {
			out.P(innerIndent, "if ", valueExpr, " != nil {")
			innerIndent += "\t"
			valueExpr = "*" + valueExpr
		} else if !leaf.isOneof {
			cond := g.scalarPresenceExpr(leafAccess, field.Kind, enumType != "")
			if cond != "" {
				out.P(innerIndent, "if ", cond, " {")
				innerIndent += "\t"
			}
		}
		out.P(innerIndent, "if ", casterName, " == nil {")
		out.P(innerIndent, "\treturn nil, fmt.Errorf(\"missing caster: ", casterName, "\")")
		out.P(innerIndent, "}")
		out.P(innerIndent, "val, err := ", casterName, ".CastErr(", valueExpr, ")")
		out.P(innerIndent, "if err != nil {")
		out.P(innerIndent, "\treturn nil, err")
		out.P(innerIndent, "}")
		if g.isPointerField(field) {
			out.P(innerIndent, "out.", fieldName, " = &val")
		} else {
			out.P(innerIndent, "out.", fieldName, " = val")
		}
		if setCrf {
			out.P(innerIndent, "out.", goFieldNameFromPlain(g.plainName(field)+"CRF"), " = ", fmt.Sprintf("%q", pathString))
		}
		if isPointerScalarField(leaf.field) || (!leaf.isOneof && g.scalarPresenceExpr(leafAccess, field.Kind, enumType != "") != "") {
			innerIndent = strings.TrimSuffix(innerIndent, "\t")
			out.P(innerIndent, "}")
		}
		closeGuards(out, innerIndent, closers)
	}
}
