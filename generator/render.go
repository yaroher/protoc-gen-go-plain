package generator

import (
	"fmt"
	"strings"

	"github.com/iancoleman/strcase"
	"github.com/yaroher/protoc-gen-go-plain/goplain"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/reflect/protoreflect"
	"google.golang.org/protobuf/types/known/typepb"
)

type renderContext struct {
	builder *Builder
	file    *protogen.File
	g       *protogen.GeneratedFile
}

func (g *Generator) renderFile(ctx *renderContext, ir *TypePbIR) error {
	if ir == nil || len(ir.Messages) == 0 {
		return nil
	}

	ctx.g.P("// Code generated by protoc-gen-go-plain. DO NOT EDIT.")
	ctx.g.P("// source: ", ctx.file.Desc.Path())
	ctx.g.P()
	ctx.g.P("package ", ctx.file.GoPackageName)
	ctx.g.P()

	for _, msg := range ctx.file.Messages {
		if err := g.renderMessage(ctx, msg, ir.Messages); err != nil {
			return err
		}
	}

	return nil
}

func (g *Generator) renderMessage(ctx *renderContext, msg *protogen.Message, messages map[string]*TypeWrapper) error {
	if msg.Desc.IsMapEntry() {
		return nil
	}
	if !ctx.builder.shouldGenerateMessage(msg) {
		return nil
	}

	for _, child := range msg.Messages {
		if err := g.renderMessage(ctx, child, messages); err != nil {
			return err
		}
	}

	plainGoName := msg.GoIdent.GoName + g.suffix
	wrapper := messages[ctx.builder.plainFullName(msg.Desc.FullName())]
	if wrapper == nil {
		if g.Settings.JSONJX {
			if err := g.renderProtoJSONJX(ctx, msg, plainGoName, false); err != nil {
				return err
			}
			ctx.g.P()
		}
		return nil
	}

	if alias, ok := ctx.builder.aliases[string(msg.Desc.FullName())]; ok && alias != nil {
		aliasGoType := g.goTypeForAlias(ctx, alias)
		ctx.g.P("type ", plainGoName, " = ", aliasGoType)
		ctx.g.P()
		g.renderAliasConversions(ctx, msg, plainGoName, alias, aliasGoType)
		if g.Settings.JSONJX {
			if err := g.renderProtoJSONJX(ctx, msg, plainGoName, false); err != nil {
				return err
			}
			ctx.g.P()
		}
		return nil
	}

	ctx.g.P("type ", plainGoName, " struct {")
	if wrapper.CRF != nil && wrapper.CRF.HasEntries() {
		crfIdent := protogen.GoIdent{GoName: "CRF", GoImportPath: "github.com/yaroher/protoc-gen-go-plain/crf"}
		ctx.g.P("\tCRF *", ctx.g.QualifiedGoIdent(crfIdent), " `json:\"crf,omitempty\"`")
	}
	for _, fw := range wrapper.Fields {
		if fw == nil || fw.Field == nil {
			continue
		}
		goName := goFieldName(fw.Field.GetName())
		goType, err := g.goTypeForField(ctx, fw)
		if err != nil {
			return err
		}
		ctx.g.P("\t", goName, " ", goType, " `json:\"", fw.Field.GetName(), ",omitempty\"`")
	}
	ctx.g.P("}")
	ctx.g.P()

	g.renderIntoPlain(ctx, msg, plainGoName, wrapper)
	ctx.g.P()
	g.renderIntoPb(ctx, msg, plainGoName, wrapper)
	ctx.g.P()
	if g.Settings.JSONJX {
		if err := g.renderJSONJX(ctx, plainGoName, wrapper); err != nil {
			return err
		}
		ctx.g.P()
		if err := g.renderProtoJSONJX(ctx, msg, plainGoName, true); err != nil {
			return err
		}
		ctx.g.P()
	}

	return nil
}

func (g *Generator) goTypeForAlias(ctx *renderContext, alias *AliasInfo) string {
	if alias == nil {
		return "interface{}"
	}
	switch alias.Kind {
	case typepb.Field_TYPE_MESSAGE:
		full := strings.TrimPrefix(alias.TypeUrl, "type.googleapis.com/")
		if msg, ok := ctx.builder.messagesByFullName[full]; ok {
			return ctx.g.QualifiedGoIdent(msg.GoIdent)
		}
	case typepb.Field_TYPE_ENUM:
		full := strings.TrimPrefix(alias.TypeUrl, "type.googleapis.com/")
		if enum, ok := ctx.builder.enumsByFullName[full]; ok {
			return ctx.g.QualifiedGoIdent(enum.GoIdent)
		}
	}
	return scalarGoType(alias.Kind)
}

func (g *Generator) goTypeForField(ctx *renderContext, fw *FieldWrapper) (string, error) {
	if fw == nil || fw.Field == nil {
		return "interface{}", nil
	}

	if ident := g.resolveOverride(ctx, fw); ident != nil {
		return ctx.g.QualifiedGoIdent(*ident), nil
	}

	kind := fw.Field.GetKind()
	card := fw.Field.GetCardinality()

	if fw.Source != nil && fw.Source.Desc.IsMap() {
		keyField := fw.Source.Message.Fields[0]
		valField := fw.Source.Message.Fields[1]
		keyType, _ := g.goTypeFromField(ctx, keyField, nil)
		valType, _ := g.goTypeFromField(ctx, valField, fw.Oneof)
		return "map[" + keyType + "]" + valType, nil
	}

	typ, err := g.goTypeFromKind(ctx, fw, kind)
	if err != nil {
		return "", err
	}

	if kind == typepb.Field_TYPE_MESSAGE {
		if !strings.HasPrefix(typ, "*") {
			typ = "*" + typ
		}
	}

	if card == typepb.Field_CARDINALITY_REPEATED {
		return "[]" + typ, nil
	}

	if fw.Oneof != nil && !strings.HasPrefix(typ, "[]") && !strings.HasPrefix(typ, "map[") && !strings.HasPrefix(typ, "*") {
		return "*" + typ, nil
	}

	return typ, nil
}

func (g *Generator) goTypeFromKind(ctx *renderContext, fw *FieldWrapper, kind typepb.Field_Kind) (string, error) {
	switch kind {
	case typepb.Field_TYPE_MESSAGE:
		full := strings.TrimPrefix(fw.Field.GetTypeUrl(), "type.googleapis.com/")
		if msg, ok := ctx.builder.messagesByFullName[full]; ok {
			if ctx.builder.generatedMessages[full] {
				ident := protogen.GoIdent{
					GoName:       msg.GoIdent.GoName + g.suffix,
					GoImportPath: msg.GoIdent.GoImportPath,
				}
				return ctx.g.QualifiedGoIdent(ident), nil
			}
			return ctx.g.QualifiedGoIdent(msg.GoIdent), nil
		}
		return "interface{}", nil
	case typepb.Field_TYPE_ENUM:
		full := strings.TrimPrefix(fw.Field.GetTypeUrl(), "type.googleapis.com/")
		if enum, ok := ctx.builder.enumsByFullName[full]; ok {
			return ctx.g.QualifiedGoIdent(enum.GoIdent), nil
		}
		return "int32", nil
	default:
		return scalarGoType(kind), nil
	}
}

func (g *Generator) goTypeFromField(ctx *renderContext, field *protogen.Field, oneof *protogen.Oneof) (string, error) {
	wrapper := &FieldWrapper{
		Field: &typepb.Field{
			Kind:        kindFromField(field),
			Cardinality: cardinalityFromField(field),
			TypeUrl:     typeURLForField(field),
		},
		Source: field,
		Oneof:  oneof,
	}
	return g.goTypeForField(ctx, wrapper)
}

func (g *Generator) goTypeFromFieldProto(ctx *renderContext, field *protogen.Field) (string, error) {
	if field == nil {
		return "interface{}", nil
	}
	kind := kindFromField(field)
	card := cardinalityFromField(field)
	var typ string
	switch kind {
	case typepb.Field_TYPE_MESSAGE:
		if field.Message != nil {
			typ = ctx.g.QualifiedGoIdent(field.Message.GoIdent)
		} else {
			typ = "interface{}"
		}
	case typepb.Field_TYPE_ENUM:
		if field.Enum != nil {
			typ = ctx.g.QualifiedGoIdent(field.Enum.GoIdent)
		} else {
			typ = "int32"
		}
	default:
		typ = scalarGoType(kind)
	}

	if kind == typepb.Field_TYPE_MESSAGE && !strings.HasPrefix(typ, "*") {
		typ = "*" + typ
	}
	if card == typepb.Field_CARDINALITY_REPEATED {
		typ = "[]" + typ
	}
	return typ, nil
}

func (g *Generator) resolveOverride(ctx *renderContext, fw *FieldWrapper) *protogen.GoIdent {
	if fw.Source == nil {
		return nil
	}
	if fOpts, ok := fieldOptions(fw.Source.Desc.Options()); ok && fOpts.GetOverrideType() != nil {
		ident := fOpts.GetOverrideType()
		return &protogen.GoIdent{
			GoName:       ident.GetName(),
			GoImportPath: protogen.GoImportPath(ident.GetImportPath()),
		}
	}

	fullPath := string(fw.Source.Desc.FullName())
	var best *goplain.TypeOverride
	bestScore := -1
	for _, override := range ctx.builder.overrides {
		if override == nil || override.Selector == nil || override.TargetGoType == nil {
			continue
		}
		score := overrideSelectorScore(override.Selector, fw.Field, fullPath)
		if score > bestScore {
			bestScore = score
			best = override
		}
	}
	if best != nil {
		return &protogen.GoIdent{
			GoName:       best.TargetGoType.GetName(),
			GoImportPath: protogen.GoImportPath(best.TargetGoType.GetImportPath()),
		}
	}
	return nil
}

func overrideSelectorScore(sel *goplain.OverrideSelector, field *typepb.Field, fullPath string) int {
	score := 0
	if sel.GetTargetFullPath() != "" {
		if sel.GetTargetFullPath() != fullPath {
			return -1
		}
		score++
	}
	if sel.FieldKind != nil {
		if field.GetKind() != *sel.FieldKind {
			return -1
		}
		score++
	}
	if sel.FieldCardinality != nil {
		if field.GetCardinality() != *sel.FieldCardinality {
			return -1
		}
		score++
	}
	if sel.GetFieldTypeUrl() != "" {
		if field.GetTypeUrl() != sel.GetFieldTypeUrl() {
			return -1
		}
		score++
	}
	return score
}

func (g *Generator) renderAliasConversions(ctx *renderContext, msg *protogen.Message, plainName string, alias *AliasInfo, aliasGoType string) {
	ctx.g.P("func (m *", msg.GoIdent.GoName, ") IntoPlain() *", plainName, " {")
	ctx.g.P("\tif m == nil {")
	ctx.g.P("\t\treturn nil")
	ctx.g.P("\t}")
	ctx.g.P("\tvar v ", aliasGoType)
	if alias != nil && alias.Field != nil {
		ctx.g.P("\tv = m.Get", alias.Field.GoName, "()")
	}
	ctx.g.P("\treturn (*", plainName, ")(&v)")
	ctx.g.P("}")
	ctx.g.P()

	ctx.g.P("func (m *", plainName, ") IntoPb() *", msg.GoIdent.GoName, " {")
	ctx.g.P("\tif m == nil {")
	ctx.g.P("\t\treturn nil")
	ctx.g.P("\t}")
	ctx.g.P("\tout := &", msg.GoIdent.GoName, "{}")
	if alias != nil && alias.Field != nil {
		ctx.g.P("\tout.", alias.Field.GoName, " = ", aliasGoType, "(*m)")
	}
	ctx.g.P("\treturn out")
	ctx.g.P("}")
}

func (g *Generator) renderIntoPlain(ctx *renderContext, msg *protogen.Message, plainName string, wrapper *TypeWrapper) {
	ctx.g.P("func (m *", msg.GoIdent.GoName, ") IntoPlain() *", plainName, " {")
	ctx.g.P("\tout, err := m.IntoPlainErr()")
	ctx.g.P("\tif err != nil {")
	ctx.g.P("\t\tpanic(err)")
	ctx.g.P("\t}")
	ctx.g.P("\treturn out")
	ctx.g.P("}")
	ctx.g.P()

	ctx.g.P("func (m *", msg.GoIdent.GoName, ") IntoPlainErr() (*", plainName, ", error) {")
	ctx.g.P("\tif m == nil {")
	ctx.g.P("\t\treturn nil, nil")
	ctx.g.P("\t}")
	if wrapper.CRF != nil && wrapper.CRF.HasEntries() {
		g.renderCRFValidation(ctx, "m", wrapper)
	}
	ctx.g.P("\tout := &", plainName, "{}")
	if wrapper.CRF != nil && wrapper.CRF.HasEntries() {
		g.renderCRFAssign(ctx, "out", "m", wrapper)
	}

	oneofGroups := make(map[string]*oneofGroup)
	for _, fw := range wrapper.Fields {
		if fw == nil || fw.Field == nil || fw.Source == nil {
			continue
		}
		if fw.Oneof != nil {
			idx := oneofVariantIndex(fw)
			ownerPath := fw.Path[:idx]
			key := oneofGroupKey(fw.Oneof, ownerPath)
			group, ok := oneofGroups[key]
			if !ok {
				group = &oneofGroup{oneof: fw.Oneof, ownerPath: ownerPath}
				oneofGroups[key] = group
			}
			group.fields = append(group.fields, fw)
			continue
		}
		g.renderPlainAssign(ctx, "out", "m", fw)
	}

	for _, group := range oneofGroups {
		g.renderOneofIntoPlain(ctx, "out", "m", group)
	}

	ctx.g.P("\treturn out, nil")
	ctx.g.P("}")
}

func (g *Generator) renderCRFValidation(ctx *renderContext, rootVar string, wrapper *TypeWrapper) {
	if wrapper == nil || wrapper.CRF == nil || !wrapper.CRF.HasEntries() {
		return
	}
	fieldByName := make(map[string]*FieldWrapper)
	for _, fw := range wrapper.Fields {
		if fw == nil || fw.Field == nil {
			continue
		}
		fieldByName[fw.Field.GetName()] = fw
	}

	errIdent := protogen.GoIdent{GoName: "ErrFieldCollision", GoImportPath: "github.com/yaroher/protoc-gen-go-plain/crf"}
	for _, entry := range wrapper.CRF.Entries {
		fw := fieldByName[entry.Field]
		if fw == nil || len(fw.Origins) < 2 {
			continue
		}
		countVar := "crfCount" + goFieldName(entry.Field)
		ctx.g.P("\t", countVar, " := 0")
		for _, origin := range fw.Origins {
			cond := g.originPresenceExpr(rootVar, origin)
			if cond == "" {
				continue
			}
			ctx.g.P("\tif ", cond, " {")
			ctx.g.P("\t\t", countVar, "++")
			ctx.g.P("\t}")
		}
		ctx.g.P("\tif ", countVar, " > 1 {")
		ctx.g.P("\t\treturn nil, ", ctx.g.QualifiedGoIdent(errIdent), "{")
		ctx.g.P("\t\t\tField: ", fmt.Sprintf("%q", entry.Field), ",")
		if len(entry.Sources) > 0 {
			ctx.g.P("\t\t\tSources: []string{")
			for _, src := range entry.Sources {
				ctx.g.P("\t\t\t\t", fmt.Sprintf("%q", src.Path), ",")
			}
			ctx.g.P("\t\t\t},")
		}
		ctx.g.P("\t\t}")
		ctx.g.P("\t}")
	}
}

func (g *Generator) renderCRFValidationPlain(ctx *renderContext, rootVar string, wrapper *TypeWrapper) {
	if wrapper == nil || wrapper.CRF == nil || !wrapper.CRF.HasEntries() {
		return
	}
	fieldByName := make(map[string]*FieldWrapper)
	for _, fw := range wrapper.Fields {
		if fw == nil || fw.Field == nil {
			continue
		}
		fieldByName[fw.Field.GetName()] = fw
	}

	errIdent := protogen.GoIdent{GoName: "ErrFieldCollision", GoImportPath: "github.com/yaroher/protoc-gen-go-plain/crf"}
	for _, entry := range wrapper.CRF.Entries {
		fw := fieldByName[entry.Field]
		if fw == nil || len(fw.Origins) < 2 {
			continue
		}
		cond := g.plainFieldPresenceExpr(rootVar, fw)
		if cond == "" {
			continue
		}
		ctx.g.P("\tif ", cond, " {")
		ctx.g.P("\t\treturn nil, ", ctx.g.QualifiedGoIdent(errIdent), "{")
		ctx.g.P("\t\t\tField: ", fmt.Sprintf("%q", entry.Field), ",")
		if len(entry.Sources) > 0 {
			ctx.g.P("\t\t\tSources: []string{")
			for _, src := range entry.Sources {
				ctx.g.P("\t\t\t\t", fmt.Sprintf("%q", src.Path), ",")
			}
			ctx.g.P("\t\t\t},")
		}
		ctx.g.P("\t\t}")
		ctx.g.P("\t}")
	}
}

func (g *Generator) originPresenceExpr(root string, origin FieldOrigin) string {
	if origin.Source == nil || len(origin.Path) == 0 {
		return ""
	}
	leaf := origin.Path[len(origin.Path)-1]
	if leaf == nil {
		return ""
	}
	hasOneof := false
	for _, step := range origin.Path {
		if step != nil && step.Oneof != nil && !step.Oneof.Desc.IsSynthetic() {
			hasOneof = true
			break
		}
	}
	if hasOneof {
		expr := pbGetterExpr(root, origin.Path)
		if leaf.Desc.IsMap() || leaf.Desc.Cardinality() == protoreflect.Repeated {
			return "len(" + expr + ") > 0"
		}
		if leaf.Desc.Kind() == protoreflect.MessageKind {
			return expr + " != nil"
		}
		return expr + " != " + zeroValueForKind(kindFromField(leaf), false)
	}

	expr := root
	var conds []string
	for i := 0; i < len(origin.Path)-1; i++ {
		step := origin.Path[i]
		if step == nil {
			return ""
		}
		expr = expr + "." + step.GoName
		conds = append(conds, expr+" != nil")
	}
	leafExpr := expr + "." + leaf.GoName
	switch {
	case leaf.Desc.IsMap(), leaf.Desc.Cardinality() == protoreflect.Repeated:
		conds = append(conds, "len("+leafExpr+") > 0")
	case leaf.Desc.Kind() == protoreflect.MessageKind:
		conds = append(conds, leafExpr+" != nil")
	case leaf.Desc.HasPresence():
		conds = append(conds, leafExpr+" != nil")
	default:
		conds = append(conds, leafExpr+" != "+zeroValueForKind(kindFromField(leaf), false))
	}
	return strings.Join(conds, " && ")
}

func (g *Generator) plainFieldPresenceExpr(root string, fw *FieldWrapper) string {
	if fw == nil || fw.Field == nil {
		return ""
	}
	name := root + "." + goFieldName(fw.Field.GetName())
	if fw.Source != nil && fw.Source.Desc.IsMap() {
		return "len(" + name + ") > 0"
	}
	if fw.Field.GetCardinality() == typepb.Field_CARDINALITY_REPEATED {
		return "len(" + name + ") > 0"
	}
	if fw.Field.GetKind() == typepb.Field_TYPE_MESSAGE {
		return name + " != nil"
	}
	if fw.Oneof != nil {
		return name + " != nil"
	}
	zero := zeroValueForKind(fw.Field.GetKind(), false)
	return name + " != " + zero
}

func (g *Generator) renderCRFAssign(ctx *renderContext, outVar string, rootVar string, wrapper *TypeWrapper) {
	if wrapper == nil || wrapper.CRF == nil || !wrapper.CRF.HasEntries() {
		return
	}

	// Строим карту field -> FieldWrapper
	fieldByName := make(map[string]*FieldWrapper)
	for _, fw := range wrapper.Fields {
		if fw == nil || fw.Field == nil {
			continue
		}
		fieldByName[fw.Field.GetName()] = fw
	}

	crfIdent := protogen.GoIdent{GoName: "CRF", GoImportPath: "github.com/yaroher/protoc-gen-go-plain/crf"}
	entryIdent := protogen.GoIdent{GoName: "Entry", GoImportPath: "github.com/yaroher/protoc-gen-go-plain/crf"}
	sourceIdent := protogen.GoIdent{GoName: "Source", GoImportPath: "github.com/yaroher/protoc-gen-go-plain/crf"}

	// Генерируем динамическое заполнение CRF
	ctx.g.P("\t{")
	ctx.g.P("\t\tvar crfEntries []", ctx.g.QualifiedGoIdent(entryIdent))

	for _, entry := range wrapper.CRF.Entries {
		fw := fieldByName[entry.Field]
		if fw == nil || len(fw.Origins) < 2 {
			continue
		}

		// Для каждого поля генерируем проверку какой источник заполнен
		for i, origin := range fw.Origins {
			cond := g.originPresenceExpr(rootVar, origin)
			if cond == "" {
				continue
			}

			if i == 0 {
				ctx.g.P("\t\tif ", cond, " {")
			} else {
				ctx.g.P("\t\t} else if ", cond, " {")
			}
			ctx.g.P("\t\t\tcrfEntries = append(crfEntries, ", ctx.g.QualifiedGoIdent(entryIdent), "{")
			ctx.g.P("\t\t\t\tField: ", fmt.Sprintf("%q", entry.Field), ",")
			ctx.g.P("\t\t\t\tSources: []", ctx.g.QualifiedGoIdent(sourceIdent), "{{Path: ", fmt.Sprintf("%q", origin.FullName), "}},")
			ctx.g.P("\t\t\t})")
		}
		ctx.g.P("\t\t}")
	}

	ctx.g.P("\t\tif len(crfEntries) > 0 {")
	ctx.g.P("\t\t\t", outVar, ".CRF = &", ctx.g.QualifiedGoIdent(crfIdent), "{Entries: crfEntries}")
	ctx.g.P("\t\t}")
	ctx.g.P("\t}")
}

func (g *Generator) renderPlainAssign(ctx *renderContext, outVar string, srcVar string, fw *FieldWrapper) {
	if fw == nil || fw.Field == nil || fw.Source == nil {
		return
	}
	goName := goFieldName(fw.Field.GetName())
	expr := pbGetterExpr(srcVar, fw.Path)
	if fw.Source.Desc.IsMap() {
		keyField := fw.Source.Message.Fields[0]
		valField := fw.Source.Message.Fields[1]
		keyType, _ := g.goTypeFromField(ctx, keyField, nil)
		valType, _ := g.goTypeFromField(ctx, valField, nil)
		ctx.g.P("\tif ", expr, " != nil {")
		ctx.g.P("\t\t", outVar, ".", goName, " = make(map[", keyType, "]", valType, ", len(", expr, "))")
		ctx.g.P("\t\tfor k, v := range ", expr, " {")
		if valField.Desc.Kind() == protoreflect.MessageKind {
			if g.isGeneratedMessage(ctx, typeURLForField(valField)) {
				ctx.g.P("\t\t\tif v != nil {")
				ctx.g.P("\t\t\t\t", outVar, ".", goName, "[k] = v.IntoPlain()")
				ctx.g.P("\t\t\t}")
			} else {
				ctx.g.P("\t\t\t", outVar, ".", goName, "[k] = v")
			}
		} else {
			ctx.g.P("\t\t\t", outVar, ".", goName, "[k] = v")
		}
		ctx.g.P("\t\t}")
		ctx.g.P("\t}")
		return
	}

	if fw.Field.GetCardinality() == typepb.Field_CARDINALITY_REPEATED {
		if fw.Field.GetKind() == typepb.Field_TYPE_MESSAGE {
			ctx.g.P("\tfor _, v := range ", expr, " {")
			if g.isGeneratedMessage(ctx, fw.Field.GetTypeUrl()) {
				ctx.g.P("\t\t", outVar, ".", goName, " = append(", outVar, ".", goName, ", v.IntoPlain())")
			} else {
				ctx.g.P("\t\t", outVar, ".", goName, " = append(", outVar, ".", goName, ", v)")
			}
			ctx.g.P("\t}")
		} else {
			ctx.g.P("\t", outVar, ".", goName, " = append(", outVar, ".", goName, ", ", expr, "...)")
		}
		return
	}

	if fw.Field.GetKind() == typepb.Field_TYPE_MESSAGE {
		ctx.g.P("\tif ", expr, " != nil {")
		if g.isGeneratedMessage(ctx, fw.Field.GetTypeUrl()) {
			ctx.g.P("\t\t", outVar, ".", goName, " = ", expr, ".IntoPlain()")
		} else {
			ctx.g.P("\t\t", outVar, ".", goName, " = ", expr)
		}
		ctx.g.P("\t}")
		return
	}

	ctx.g.P("\t", outVar, ".", goName, " = ", expr)
}

type oneofGroup struct {
	oneof     *protogen.Oneof
	ownerPath []*protogen.Field
	fields    []*FieldWrapper
}

func oneofGroupKey(oneof *protogen.Oneof, ownerPath []*protogen.Field) string {
	var b strings.Builder
	fmt.Fprintf(&b, "%p:", oneof)
	for _, f := range ownerPath {
		b.WriteString(string(f.Desc.FullName()))
		b.WriteString("/")
	}
	return b.String()
}

func oneofOwnerVar(group *oneofGroup) string {
	if group == nil || group.oneof == nil {
		return "owner"
	}
	var b strings.Builder
	b.WriteString("owner")
	b.WriteString(group.oneof.GoName)
	for _, step := range group.ownerPath {
		if step == nil {
			continue
		}
		b.WriteString(step.GoName)
	}
	return b.String()
}

func oneofVariantIndex(fw *FieldWrapper) int {
	if fw == nil || fw.Oneof == nil {
		return 0
	}
	for i, f := range fw.Path {
		if f != nil && f.Oneof == fw.Oneof {
			return i
		}
	}
	return 0
}

func (g *Generator) renderOneofIntoPlain(ctx *renderContext, outVar, srcVar string, group *oneofGroup) {
	if group == nil || group.oneof == nil || len(group.fields) == 0 {
		return
	}

	ownerExpr := pbGetterExpr(srcVar, group.ownerPath)
	ownerVar := oneofOwnerVar(group)
	if len(group.ownerPath) > 0 {
		ctx.g.P("\t", ownerVar, " := ", ownerExpr)
		ctx.g.P("\tif ", ownerVar, " != nil {")
		ownerExpr = ownerVar
	}

	ctx.g.P("\tswitch v := ", ownerExpr, ".Get", group.oneof.GoName, "().(type) {")
	byVariant := make(map[*protogen.Field][]*FieldWrapper)
	for _, fw := range group.fields {
		if fw == nil || fw.Source == nil {
			continue
		}
		idx := oneofVariantIndex(fw)
		if idx < len(fw.Path) {
			byVariant[fw.Path[idx]] = append(byVariant[fw.Path[idx]], fw)
		}
	}
	for variant, vfields := range byVariant {
		if variant == nil {
			continue
		}
		variantType := ctx.g.QualifiedGoIdent(variant.GoIdent)
		ctx.g.P("\tcase *", variantType, ":")
		rootVar := "v." + variant.GoName
		for _, fw := range vfields {
			idx := oneofVariantIndex(fw)
			relative := fw.Path[idx+1:]
			if len(relative) == 0 {
				goName := goFieldName(fw.Field.GetName())
				if fw.Source != nil && fw.Source.Desc.IsMap() {
					keyField := fw.Source.Message.Fields[0]
					valField := fw.Source.Message.Fields[1]
					keyType, _ := g.goTypeFromField(ctx, keyField, nil)
					valType, _ := g.goTypeFromField(ctx, valField, nil)
					ctx.g.P("\t\tif ", rootVar, " != nil {")
					ctx.g.P("\t\t\t", outVar, ".", goName, " = make(map[", keyType, "]", valType, ", len(", rootVar, "))")
					ctx.g.P("\t\t\tfor k, v := range ", rootVar, " {")
					if valField.Desc.Kind() == protoreflect.MessageKind {
						if g.isGeneratedMessage(ctx, typeURLForField(valField)) {
							ctx.g.P("\t\t\t\tif v != nil {")
							ctx.g.P("\t\t\t\t\t", outVar, ".", goName, "[k] = v.IntoPlain()")
							ctx.g.P("\t\t\t\t}")
						} else {
							ctx.g.P("\t\t\t\t", outVar, ".", goName, "[k] = v")
						}
					} else {
						ctx.g.P("\t\t\t\t", outVar, ".", goName, "[k] = v")
					}
					ctx.g.P("\t\t\t}")
					ctx.g.P("\t\t}")
					continue
				}
				if fw.Field.GetCardinality() == typepb.Field_CARDINALITY_REPEATED {
					if fw.Field.GetKind() == typepb.Field_TYPE_MESSAGE {
						ctx.g.P("\t\tfor _, v := range ", rootVar, " {")
						if g.isGeneratedMessage(ctx, fw.Field.GetTypeUrl()) {
							ctx.g.P("\t\t\t", outVar, ".", goName, " = append(", outVar, ".", goName, ", v.IntoPlain())")
						} else {
							ctx.g.P("\t\t\t", outVar, ".", goName, " = append(", outVar, ".", goName, ", v)")
						}
						ctx.g.P("\t\t}")
					} else {
						ctx.g.P("\t\t", outVar, ".", goName, " = append(", outVar, ".", goName, ", ", rootVar, "...)")
					}
					continue
				}
				if fw.Field.GetKind() == typepb.Field_TYPE_MESSAGE {
					ctx.g.P("\t\tif ", rootVar, " != nil {")
					if g.isGeneratedMessage(ctx, fw.Field.GetTypeUrl()) {
						ctx.g.P("\t\t\t", outVar, ".", goName, " = ", rootVar, ".IntoPlain()")
					} else {
						ctx.g.P("\t\t\t", outVar, ".", goName, " = ", rootVar)
					}
					ctx.g.P("\t\t}")
				} else if fw.Oneof != nil {
					tmp := "tmp" + goName
					ctx.g.P("\t\t", tmp, " := ", rootVar)
					ctx.g.P("\t\t", outVar, ".", goName, " = &", tmp)
				} else {
					ctx.g.P("\t\t", outVar, ".", goName, " = ", rootVar)
				}
				continue
			}
			expr := pbGetterExpr(rootVar, relative)
			goName := goFieldName(fw.Field.GetName())
			if fw.Source != nil && fw.Source.Desc.IsMap() {
				keyField := fw.Source.Message.Fields[0]
				valField := fw.Source.Message.Fields[1]
				keyType, _ := g.goTypeFromField(ctx, keyField, nil)
				valType, _ := g.goTypeFromField(ctx, valField, nil)
				ctx.g.P("\t\tif ", expr, " != nil {")
				ctx.g.P("\t\t\t", outVar, ".", goName, " = make(map[", keyType, "]", valType, ", len(", expr, "))")
				ctx.g.P("\t\t\tfor k, v := range ", expr, " {")
				if valField.Desc.Kind() == protoreflect.MessageKind {
					if g.isGeneratedMessage(ctx, typeURLForField(valField)) {
						ctx.g.P("\t\t\t\tif v != nil {")
						ctx.g.P("\t\t\t\t\t", outVar, ".", goName, "[k] = v.IntoPlain()")
						ctx.g.P("\t\t\t\t}")
					} else {
						ctx.g.P("\t\t\t\t", outVar, ".", goName, "[k] = v")
					}
				} else {
					ctx.g.P("\t\t\t\t", outVar, ".", goName, "[k] = v")
				}
				ctx.g.P("\t\t\t}")
				ctx.g.P("\t\t}")
				continue
			}
			if fw.Field.GetCardinality() == typepb.Field_CARDINALITY_REPEATED {
				if fw.Field.GetKind() == typepb.Field_TYPE_MESSAGE {
					ctx.g.P("\t\tfor _, v := range ", expr, " {")
					if g.isGeneratedMessage(ctx, fw.Field.GetTypeUrl()) {
						ctx.g.P("\t\t\t", outVar, ".", goName, " = append(", outVar, ".", goName, ", v.IntoPlain())")
					} else {
						ctx.g.P("\t\t\t", outVar, ".", goName, " = append(", outVar, ".", goName, ", v)")
					}
					ctx.g.P("\t\t}")
				} else {
					ctx.g.P("\t\t", outVar, ".", goName, " = append(", outVar, ".", goName, ", ", expr, "...)")
				}
				continue
			}
			if fw.Field.GetKind() == typepb.Field_TYPE_MESSAGE {
				ctx.g.P("\t\tif ", expr, " != nil {")
				if g.isGeneratedMessage(ctx, fw.Field.GetTypeUrl()) {
					ctx.g.P("\t\t\t", outVar, ".", goName, " = ", expr, ".IntoPlain()")
				} else {
					ctx.g.P("\t\t\t", outVar, ".", goName, " = ", expr)
				}
				ctx.g.P("\t\t}")
			} else if fw.Oneof != nil {
				tmp := "tmp" + goName
				ctx.g.P("\t\t", tmp, " := ", expr)
				ctx.g.P("\t\t", outVar, ".", goName, " = &", tmp)
			} else {
				ctx.g.P("\t\t", outVar, ".", goName, " = ", expr)
			}
		}
	}
	ctx.g.P("\t}")
	if len(group.ownerPath) > 0 {
		ctx.g.P("\t}")
	}
}

func (g *Generator) renderIntoPb(ctx *renderContext, msg *protogen.Message, plainName string, wrapper *TypeWrapper) {
	ctx.g.P("func (m *", plainName, ") IntoPb() *", msg.GoIdent.GoName, " {")
	ctx.g.P("\tout, err := m.IntoPbErr()")
	ctx.g.P("\tif err != nil {")
	ctx.g.P("\t\tpanic(err)")
	ctx.g.P("\t}")
	ctx.g.P("\treturn out")
	ctx.g.P("}")
	ctx.g.P()

	ctx.g.P("func (m *", plainName, ") IntoPbErr() (*", msg.GoIdent.GoName, ", error) {")
	ctx.g.P("\tif m == nil {")
	ctx.g.P("\t\treturn nil, nil")
	ctx.g.P("\t}")
	if wrapper.CRF != nil && wrapper.CRF.HasEntries() {
		g.renderCRFValidationPlain(ctx, "m", wrapper)
	}
	ctx.g.P("\tout := &", msg.GoIdent.GoName, "{}")

	oneofGroups := make(map[string]*oneofGroup)
	for _, fw := range wrapper.Fields {
		if fw == nil || fw.Field == nil || fw.Source == nil {
			continue
		}
		if fw.Oneof != nil {
			idx := oneofVariantIndex(fw)
			ownerPath := fw.Path[:idx]
			key := oneofGroupKey(fw.Oneof, ownerPath)
			group, ok := oneofGroups[key]
			if !ok {
				group = &oneofGroup{oneof: fw.Oneof, ownerPath: ownerPath}
				oneofGroups[key] = group
			}
			group.fields = append(group.fields, fw)
			continue
		}
		g.renderPbAssign(ctx, "out", "m", fw)
	}

	for _, group := range oneofGroups {
		g.renderOneofIntoPb(ctx, "out", "m", group)
	}

	ctx.g.P("\treturn out, nil")
	ctx.g.P("}")
}

func (g *Generator) renderPbAssign(ctx *renderContext, outVar, srcVar string, fw *FieldWrapper) {
	if fw == nil || fw.Field == nil || fw.Source == nil {
		return
	}
	goName := goFieldName(fw.Field.GetName())
	srcField := srcVar + "." + goName

	if len(fw.Path) == 1 {
		g.renderPbAssignLeaf(ctx, outVar, fw.Source, srcField, fw)
		return
	}

	parent := outVar
	for i := 0; i < len(fw.Path)-1; i++ {
		step := fw.Path[i]
		if step.Message == nil {
			return
		}
		fieldName := step.GoName
		msgType := ctx.g.QualifiedGoIdent(step.Message.GoIdent)
		ctx.g.P("\tif ", parent, ".", fieldName, " == nil {")
		ctx.g.P("\t\t", parent, ".", fieldName, " = &", msgType, "{}")
		ctx.g.P("\t}")
		parent = parent + "." + fieldName
	}

	leaf := fw.Path[len(fw.Path)-1]
	g.renderPbAssignLeaf(ctx, parent, leaf, srcField, fw)
}

func (g *Generator) renderPbAssignLeaf(ctx *renderContext, outVar string, leaf *protogen.Field, srcField string, fw *FieldWrapper) {
	if leaf == nil {
		return
	}

	dest := outVar + "." + leaf.GoName
	if leaf.Desc.IsMap() {
		keyField := leaf.Message.Fields[0]
		valField := leaf.Message.Fields[1]
		keyType, _ := g.goTypeFromFieldProto(ctx, keyField)
		valType, _ := g.goTypeFromFieldProto(ctx, valField)
		ctx.g.P("\tif ", srcField, " != nil {")
		ctx.g.P("\t\t", dest, " = make(map[", keyType, "]", valType, ", len(", srcField, "))")
		ctx.g.P("\t\tfor k, v := range ", srcField, " {")
		if valField.Desc.Kind() == protoreflect.MessageKind {
			if g.isGeneratedMessage(ctx, typeURLForField(valField)) {
				ctx.g.P("\t\t\tif v != nil {")
				ctx.g.P("\t\t\t\t", dest, "[k] = v.IntoPb()")
				ctx.g.P("\t\t\t}")
			} else {
				ctx.g.P("\t\t\t", dest, "[k] = v")
			}
		} else {
			ctx.g.P("\t\t\t", dest, "[k] = v")
		}
		ctx.g.P("\t\t}")
		ctx.g.P("\t}")
		return
	}
	if fw.Field.GetCardinality() == typepb.Field_CARDINALITY_REPEATED {
		if fw.Field.GetKind() == typepb.Field_TYPE_MESSAGE {
			ctx.g.P("\tfor _, v := range ", srcField, " {")
			if g.isGeneratedMessage(ctx, fw.Field.GetTypeUrl()) {
				ctx.g.P("\t\t", dest, " = append(", dest, ", v.IntoPb())")
			} else {
				ctx.g.P("\t\t", dest, " = append(", dest, ", v)")
			}
			ctx.g.P("\t}")
		} else {
			ctx.g.P("\t", dest, " = append(", dest, ", ", srcField, "...)")
		}
		return
	}

	if fw.Field.GetKind() == typepb.Field_TYPE_MESSAGE {
		ctx.g.P("\tif ", srcField, " != nil {")
		if g.isGeneratedMessage(ctx, fw.Field.GetTypeUrl()) {
			ctx.g.P("\t\t", dest, " = ", srcField, ".IntoPb()")
		} else {
			ctx.g.P("\t\t", dest, " = ", srcField)
		}
		ctx.g.P("\t}")
		return
	}

	if leaf.Desc.HasPresence() && leaf.Desc.Cardinality() != protoreflect.Repeated {
		zero := zeroValueForKind(fw.Field.GetKind(), false)
		ctx.g.P("\tif ", srcField, " != ", zero, " {")
		ctx.g.P("\t\tv := ", srcField)
		ctx.g.P("\t\t", dest, " = &v")
		ctx.g.P("\t}")
		return
	}

	ctx.g.P("\t", dest, " = ", srcField)
}

func (g *Generator) renderOneofIntoPb(ctx *renderContext, outVar, srcVar string, group *oneofGroup) {
	if group == nil || group.oneof == nil || len(group.fields) == 0 {
		return
	}
	byVariant := make(map[*protogen.Field][]*FieldWrapper)
	for _, fw := range group.fields {
		if fw == nil || fw.Source == nil {
			continue
		}
		idx := oneofVariantIndex(fw)
		if idx < len(fw.Path) {
			byVariant[fw.Path[idx]] = append(byVariant[fw.Path[idx]], fw)
		}
	}

	ownerVar := outVar
	if len(group.ownerPath) > 0 {
		ownerVar = oneofOwnerVar(group)
		ctx.g.P("\t", ownerVar, " := ", outVar)
		for _, step := range group.ownerPath {
			if step.Message == nil {
				if step.Oneof == nil || step.Oneof.Desc.IsSynthetic() {
					return
				}
			}
			if step.Oneof != nil && !step.Oneof.Desc.IsSynthetic() {
				oneofName := step.Oneof.GoName
				variantType := ctx.g.QualifiedGoIdent(step.GoIdent)
				if step.Message == nil {
					ctx.g.P("\tif _, ok := ", ownerVar, ".", oneofName, ".(*", variantType, "); !ok {")
					ctx.g.P("\t\t", ownerVar, ".", oneofName, " = &", variantType, "{}")
					ctx.g.P("\t}")
					ownerVar = ownerVar + "." + oneofName + ".(*" + variantType + ")"
					continue
				}
				msgType := ctx.g.QualifiedGoIdent(step.Message.GoIdent)
				ctx.g.P("\tif _, ok := ", ownerVar, ".", oneofName, ".(*", variantType, "); !ok {")
				ctx.g.P("\t\t", ownerVar, ".", oneofName, " = &", variantType, "{", step.GoName, ": &", msgType, "{} }")
				ctx.g.P("\t}")
				ownerVar = ownerVar + "." + oneofName + ".(*" + variantType + ")." + step.GoName
				continue
			}
			fieldName := step.GoName
			msgType := ctx.g.QualifiedGoIdent(step.Message.GoIdent)
			ctx.g.P("\tif ", ownerVar, ".", fieldName, " == nil {")
			ctx.g.P("\t\t", ownerVar, ".", fieldName, " = &", msgType, "{}")
			ctx.g.P("\t}")
			ownerVar = ownerVar + "." + fieldName
		}
	}

	for variant, vfields := range byVariant {
		if variant == nil {
			continue
		}
		cond := g.plainVariantCondition(vfields)
		ctx.g.P("\tif ", cond, " {")
		idx := oneofVariantIndex(vfields[0])
		relative := vfields[0].Path[idx+1:]
		if variant.Desc.Kind() == protoreflect.MessageKind && len(vfields) > 0 && len(relative) > 0 {
			msgType := ctx.g.QualifiedGoIdent(variant.Message.GoIdent)
			ctx.g.P("\t\tvar msgVal = &", msgType, "{}")
			for _, fw := range vfields {
				idx := oneofVariantIndex(fw)
				relative := fw.Path[idx+1:]
				if len(relative) == 0 {
					continue
				}
				g.renderPbAssignPath(ctx, "msgVal", srcVar+"."+goFieldName(fw.Field.GetName()), relative, fw)
			}
			variantType := ctx.g.QualifiedGoIdent(variant.GoIdent)
			ctx.g.P("\t\t", ownerVar, ".", group.oneof.GoName, " = &", variantType, "{", variant.GoName, ": msgVal}")
		} else {
			srcField := srcVar + "." + goFieldName(vfields[0].Field.GetName())
			variantType := ctx.g.QualifiedGoIdent(variant.GoIdent)
			if g.isGeneratedMessage(ctx, vfields[0].Field.GetTypeUrl()) && vfields[0].Field.GetKind() == typepb.Field_TYPE_MESSAGE {
				ctx.g.P("\t\t", ownerVar, ".", group.oneof.GoName, " = &", variantType, "{", variant.GoName, ": ", srcField, ".IntoPb()}")
			} else if vfields[0].Oneof != nil {
				ctx.g.P("\t\t", ownerVar, ".", group.oneof.GoName, " = &", variantType, "{", variant.GoName, ": *", srcField, "}")
			} else {
				ctx.g.P("\t\t", ownerVar, ".", group.oneof.GoName, " = &", variantType, "{", variant.GoName, ": ", srcField, "}")
			}
		}
		ctx.g.P("\t}")
	}
}

func (g *Generator) renderPbAssignPath(ctx *renderContext, outVar, srcField string, path []*protogen.Field, fw *FieldWrapper) {
	if len(path) == 0 {
		return
	}
	parent := outVar
	for i := 0; i < len(path)-1; i++ {
		step := path[i]
		if step.Message == nil {
			return
		}
		fieldName := step.GoName
		msgType := ctx.g.QualifiedGoIdent(step.Message.GoIdent)
		ctx.g.P("\t\tif ", parent, ".", fieldName, " == nil {")
		ctx.g.P("\t\t\t", parent, ".", fieldName, " = &", msgType, "{}")
		ctx.g.P("\t\t}")
		parent = parent + "." + fieldName
	}
	leaf := path[len(path)-1]
	dest := parent + "." + leaf.GoName
	if leaf.Desc.IsMap() {
		keyField := leaf.Message.Fields[0]
		valField := leaf.Message.Fields[1]
		keyType, _ := g.goTypeFromFieldProto(ctx, keyField)
		valType, _ := g.goTypeFromFieldProto(ctx, valField)
		ctx.g.P("\t\tif ", srcField, " != nil {")
		ctx.g.P("\t\t\t", dest, " = make(map[", keyType, "]", valType, ", len(", srcField, "))")
		ctx.g.P("\t\t\tfor k, v := range ", srcField, " {")
		if valField.Desc.Kind() == protoreflect.MessageKind {
			if g.isGeneratedMessage(ctx, typeURLForField(valField)) {
				ctx.g.P("\t\t\t\tif v != nil {")
				ctx.g.P("\t\t\t\t\t", dest, "[k] = v.IntoPb()")
				ctx.g.P("\t\t\t\t}")
			} else {
				ctx.g.P("\t\t\t\t", dest, "[k] = v")
			}
		} else {
			ctx.g.P("\t\t\t\t", dest, "[k] = v")
		}
		ctx.g.P("\t\t\t}")
		ctx.g.P("\t\t}")
		return
	}
	if fw.Field.GetCardinality() == typepb.Field_CARDINALITY_REPEATED {
		if fw.Field.GetKind() == typepb.Field_TYPE_MESSAGE {
			ctx.g.P("\t\tfor _, v := range ", srcField, " {")
			if g.isGeneratedMessage(ctx, fw.Field.GetTypeUrl()) {
				ctx.g.P("\t\t\t", dest, " = append(", dest, ", v.IntoPb())")
			} else {
				ctx.g.P("\t\t\t", dest, " = append(", dest, ", v)")
			}
			ctx.g.P("\t\t}")
		} else {
			ctx.g.P("\t\t", dest, " = append(", dest, ", ", srcField, "...)")
		}
		return
	}
	if fw.Field.GetKind() == typepb.Field_TYPE_MESSAGE {
		ctx.g.P("\t\tif ", srcField, " != nil {")
		if g.isGeneratedMessage(ctx, fw.Field.GetTypeUrl()) {
			ctx.g.P("\t\t\t", dest, " = ", srcField, ".IntoPb()")
		} else {
			ctx.g.P("\t\t\t", dest, " = ", srcField)
		}
		ctx.g.P("\t\t}")
		return
	}
	if fw.Oneof != nil {
		if leaf.Desc.HasPresence() && leaf.Desc.Cardinality() != protoreflect.Repeated {
			ctx.g.P("\t\tif ", srcField, " != nil {")
			ctx.g.P("\t\t\t", dest, " = ", srcField)
			ctx.g.P("\t\t}")
		} else {
			ctx.g.P("\t\tif ", srcField, " != nil {")
			ctx.g.P("\t\t\t", dest, " = *", srcField)
			ctx.g.P("\t\t}")
		}
		return
	}
	if leaf.Desc.HasPresence() && leaf.Desc.Cardinality() != protoreflect.Repeated {
		zero := zeroValueForKind(fw.Field.GetKind(), false)
		ctx.g.P("\t\tif ", srcField, " != ", zero, " {")
		ctx.g.P("\t\t\tv := ", srcField)
		ctx.g.P("\t\t\t", dest, " = &v")
		ctx.g.P("\t\t}")
		return
	}
	ctx.g.P("\t\t", dest, " = ", srcField)
}

func (g *Generator) plainVariantCondition(fields []*FieldWrapper) string {
	var parts []string
	for _, fw := range fields {
		if fw == nil || fw.Field == nil {
			continue
		}
		name := "m." + goFieldName(fw.Field.GetName())
		switch fw.Field.GetCardinality() {
		case typepb.Field_CARDINALITY_REPEATED:
			parts = append(parts, "len("+name+") > 0")
		default:
			pointer := fw.Oneof != nil || fw.Field.GetKind() == typepb.Field_TYPE_MESSAGE
			parts = append(parts, name+" != "+zeroValueForKind(fw.Field.GetKind(), pointer))
		}
	}
	if len(parts) == 0 {
		return "false"
	}
	return strings.Join(parts, " || ")
}

func (g *Generator) isGeneratedMessage(ctx *renderContext, typeURL string) bool {
	full := strings.TrimPrefix(typeURL, "type.googleapis.com/")
	return ctx.builder.generatedMessages[full]
}

func pbGetterExpr(root string, path []*protogen.Field) string {
	expr := root
	for _, field := range path {
		expr = fmt.Sprintf("%s.Get%s()", expr, field.GoName)
	}
	return expr
}

func scalarGoType(kind typepb.Field_Kind) string {
	switch kind {
	case typepb.Field_TYPE_DOUBLE:
		return "float64"
	case typepb.Field_TYPE_FLOAT:
		return "float32"
	case typepb.Field_TYPE_INT64, typepb.Field_TYPE_SFIXED64, typepb.Field_TYPE_SINT64:
		return "int64"
	case typepb.Field_TYPE_UINT64, typepb.Field_TYPE_FIXED64:
		return "uint64"
	case typepb.Field_TYPE_INT32, typepb.Field_TYPE_SFIXED32, typepb.Field_TYPE_SINT32:
		return "int32"
	case typepb.Field_TYPE_UINT32, typepb.Field_TYPE_FIXED32:
		return "uint32"
	case typepb.Field_TYPE_BOOL:
		return "bool"
	case typepb.Field_TYPE_STRING:
		return "string"
	case typepb.Field_TYPE_BYTES:
		return "[]byte"
	default:
		return "interface{}"
	}
}

func zeroValueForKind(kind typepb.Field_Kind, pointer bool) string {
	if pointer {
		return "nil"
	}
	switch kind {
	case typepb.Field_TYPE_STRING:
		return "\"\""
	case typepb.Field_TYPE_BOOL:
		return "false"
	case typepb.Field_TYPE_BYTES:
		return "nil"
	default:
		return "0"
	}
}

func kindFromField(field *protogen.Field) typepb.Field_Kind {
	kind, _ := fieldKindAndURL(field)
	return kind
}

func typeURLForField(field *protogen.Field) string {
	_, url := fieldKindAndURL(field)
	return url
}

func goFieldName(name string) string {
	goName := strcase.ToCamel(name)
	if goName == "" {
		return "Field"
	}
	if isGoKeyword(goName) {
		return goName + "_"
	}
	return goName
}

func isGoKeyword(name string) bool {
	switch name {
	case "Break", "Default", "Func", "Interface", "Select", "Case", "Defer", "Go", "Map", "Struct",
		"Chan", "Else", "Goto", "Package", "Switch", "Const", "Fallthrough", "If", "Range", "Type",
		"Continue", "For", "Import", "Return", "Var":
		return true
	default:
		return false
	}
}
