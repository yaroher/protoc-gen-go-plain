package generator

import (
	"fmt"
	"sort"

	"github.com/iancoleman/strcase"
	"github.com/yaroher/protoc-gen-go-plain/generator/empath"
	"google.golang.org/protobuf/types/known/typepb"
)

func (g *Generator) RenderJXJSON(typeIRs []*TypePbIR) error {
	// Group by package to avoid duplicate helper functions
	packageMap := make(map[string][]*TypePbIR)
	for _, ir := range typeIRs {
		if ir.File == nil {
			continue
		}
		packageKey := string(ir.File.GoImportPath) + ":" + string(ir.File.GoPackageName)
		packageMap[packageKey] = append(packageMap[packageKey], ir)
	}

	for _, irs := range packageMap {
		// Use the first file's info for package name and import path
		firstIR := irs[0]
		// Generate a single file name for the package
		// Use the first file's prefix, but this could be improved
		outName := firstIR.File.GeneratedFilenamePrefix + "_plain.jx_json.go"
		out := g.Plugin.NewGeneratedFile(outName, firstIR.File.GoImportPath)

		// Collect all messages from all files in this package
		allMsgNames := make([]string, 0)
		allMessages := make(map[string]*typepb.Type)
		imports := map[string]struct{}{}
		needsProtoJSON := false
		needsStdJSON := false
		needsBytes := false

		for _, ir := range irs {
			for name, msg := range ir.Messages {
				allMsgNames = append(allMsgNames, name)
				allMessages[name] = msg
			}
			// Collect imports from all files
			for name := range ir.Messages {
				msg := ir.Messages[name]
				for _, field := range msg.Fields {
					if field.OneofIndex > 0 {
						continue
					}
					if _, ok := mapFieldInfoFor(field); ok {
						needsStdJSON = true
					}
					if override, ok := g.overrideInfo(field); ok {
						needsStdJSON = true
						if override.importPath != "" {
							imports[override.importPath] = struct{}{}
						}
					}
					if field.Kind == typepb.Field_TYPE_MESSAGE {
						if !g.isPlainMessageInIRs(ir, field.TypeUrl, typeIRs) {
							needsProtoJSON = true
							if typeName, importPath, ok := wktGoType(field.TypeUrl); ok {
								_ = typeName
								imports[importPath] = struct{}{}
							}
						} else {
							// For plain messages from other packages, add import
							_, importPath := g.resolveMessageTypeAndImport(ir, field.TypeUrl, typeIRs)
							if importPath != "" && importPath != string(firstIR.File.GoImportPath) {
								imports[importPath] = struct{}{}
							}
						}
					}
				}
				if len(msg.Oneofs) > 0 {
					needsStdJSON = true
					needsBytes = true
				}
			}
		}

		if needsStdJSON {
			imports["encoding/json"] = struct{}{}
		}
		if needsProtoJSON {
			imports["google.golang.org/protobuf/encoding/protojson"] = struct{}{}
		}
		if needsBytes {
			imports["bytes"] = struct{}{}
		}
		imports["fmt"] = struct{}{}

		// Only add jx import if there are messages to serialize
		if len(allMsgNames) > 0 {
			imports["github.com/go-faster/jx"] = struct{}{}
		}

		sort.Strings(allMsgNames)

		out.P("// Code generated by protoc-gen-go-plain. DO NOT EDIT.")
		out.P()
		out.P("package ", firstIR.File.GoPackageName)
		out.P()

		paths := make([]string, 0, len(imports))
		for path := range imports {
			paths = append(paths, path)
		}
		sort.Strings(paths)
		out.P("import (")
		for _, path := range paths {
			out.P(fmt.Sprintf("%q", path))
		}
		out.P(")")
		out.P()

		// Generate helper functions only once per package
		out.P("func jxEncodeError(field string) error {")
		out.P("\treturn fmt.Errorf(\"jx: encode %s\", field)")
		out.P("}")
		out.P("func jxDecodeError(field string, err error) error {")
		out.P("\treturn fmt.Errorf(\"jx: decode %s: %w\", field, err)")
		out.P("}")
		out.P()

		// Generate methods for all messages in the package
		for _, name := range allMsgNames {
			msg := allMessages[name]
			// Find the IR that contains this message
			var msgIR *TypePbIR
			for _, ir := range irs {
				if _, ok := ir.Messages[name]; ok {
					msgIR = ir
					break
				}
			}
			if msgIR == nil {
				continue
			}
			g.renderJXJSONForMessage(out, msgIR, msg, typeIRs, imports)
			out.P()
		}
	}
	return nil
}

func (g *Generator) renderJXJSONForMessage(out typeWriter, ir *TypePbIR, msg *typepb.Type, allIRs []*TypePbIR, imports map[string]struct{}) {
	if !g.isPbMessage(ir, msg.Name) {
		return
	}
	if g.isTypeAliasMessage(msg.Name) {
		return
	}
	msgPlain := g.plainTypeName(msg.Name)

	out.P("func (x *", msgPlain, ") MarshalJSON() ([]byte, error) {")
	out.P("\tif x == nil {")
	out.P("\t\treturn []byte(\"null\"), nil")
	out.P("\t}")
	out.P("\te := jx.GetEncoder()")
	out.P("\tdefer jx.PutEncoder(e)")
	out.P("\tif e.ObjStart() {")
	out.P("\t\treturn nil, jxEncodeError(\"", msgPlain, "\")")
	out.P("\t}")

	for _, field := range msg.Fields {
		if field.OneofIndex > 0 {
			continue
		}
		fieldName := g.fieldGoName(field)
		jsonName := jsonTagFromPlain(g.plainName(field))
		g.renderJXMarshalField(out, ir, field, fieldName, jsonName, allIRs, imports)
	}

	oneofFields := g.collectOneofFieldNames(msg)
	for _, oneof := range oneofFields {
		jsonName := oneof.tag
		fieldName := oneof.fieldName
		out.P("\tif e.FieldStart(\"", jsonName, "\") {")
		out.P("\t\treturn nil, jxEncodeError(\"", jsonName, "\")")
		out.P("\t}")
		out.P("\tif x.", fieldName, " == nil {")
		out.P("\t\te.Null()")
		out.P("\t} else {")
		out.P("\t\traw, err := json.Marshal(x.", fieldName, ")")
		out.P("\t\tif err != nil {")
		out.P("\t\t\treturn nil, jxEncodeError(\"", jsonName, "\")")
		out.P("\t\t}")
		out.P("\t\te.Raw(raw)")
		out.P("\t}")
	}

	out.P("\tif e.ObjEnd() {")
	out.P("\t\treturn nil, jxEncodeError(\"", msgPlain, "\")")
	out.P("\t}")
	out.P("\tbuf := append([]byte(nil), e.Bytes()...)")
	out.P("\treturn buf, nil")
	out.P("}")
	out.P()

	out.P("func (x *", msgPlain, ") UnmarshalJSON(data []byte) error {")
	out.P("\tif x == nil {")
	out.P("\t\treturn fmt.Errorf(\"jx: nil receiver\")")
	out.P("\t}")
	out.P("\td := jx.DecodeBytes(data)")
	out.P("\treturn d.Obj(func(d *jx.Decoder, key string) error {")
	out.P("\t\tswitch key {")

	for _, field := range msg.Fields {
		if field.OneofIndex > 0 {
			continue
		}
		fieldName := g.fieldGoName(field)
		jsonName := jsonTagFromPlain(g.plainName(field))
		out.P("\t\tcase \"", jsonName, "\":")
		g.renderJXUnmarshalField(out, ir, field, fieldName, allIRs, imports)
	}

	for _, oneof := range oneofFields {
		jsonName := oneof.tag
		out.P("\t\tcase \"", jsonName, "\":")
		g.renderJXUnmarshalOneof(out, ir, msg, oneof)
	}

	out.P("\t\tdefault:")
	out.P("\t\t\treturn d.Skip()")
	out.P("\t\t}")
	out.P("\t})")
	out.P("}")
}

func (g *Generator) renderJXMarshalField(out typeWriter, ir *TypePbIR, field *typepb.Field, fieldName, jsonName string, allIRs []*TypePbIR, imports map[string]struct{}) {
	isRepeated := field.Cardinality == typepb.Field_CARDINALITY_REPEATED
	isPointer := g.isPointerField(field) || (field.Kind == typepb.Field_TYPE_MESSAGE && field.Cardinality != typepb.Field_CARDINALITY_REPEATED)
	isOmitEmpty := isRepeated || isPointer || (hasMarker(field.TypeUrl, crfMarker) && !hasMarker(field.TypeUrl, crfForMarker))
	plainMessage := field.Kind == typepb.Field_TYPE_MESSAGE && g.isPlainMessageInIRs(ir, field.TypeUrl, allIRs)
	isProtoMessage := field.Kind == typepb.Field_TYPE_MESSAGE && !plainMessage
	_, isOverride := g.overrideInfo(field)
	if _, ok := g.typeAliasInfoForTypeURL(field.TypeUrl); ok {
		isPointer = g.isPointerField(field)
		isOmitEmpty = isRepeated || isPointer || (hasMarker(field.TypeUrl, crfMarker) && !hasMarker(field.TypeUrl, crfForMarker))
	}
	if _, ok := g.typeAliasInfoForTypeURL(field.TypeUrl); ok {
		isProtoMessage = false
		plainMessage = false
	}
	if _, ok := mapFieldInfoFor(field); ok {
		if isOmitEmpty {
			out.P("\tif len(x.", fieldName, ") > 0 {")
			out.P("\t\tif e.FieldStart(\"", jsonName, "\") {")
			out.P("\t\t\treturn nil, jxEncodeError(\"", jsonName, "\")")
			out.P("\t\t}")
			out.P("\t\traw, err := json.Marshal(x.", fieldName, ")")
			out.P("\t\tif err != nil {")
			out.P("\t\t\treturn nil, jxEncodeError(\"", jsonName, "\")")
			out.P("\t\t}")
			out.P("\t\te.Raw(raw)")
			out.P("\t}")
			return
		}
		out.P("\tif e.FieldStart(\"", jsonName, "\") {")
		out.P("\t\treturn nil, jxEncodeError(\"", jsonName, "\")")
		out.P("\t}")
		out.P("\traw, err := json.Marshal(x.", fieldName, ")")
		out.P("\tif err != nil {")
		out.P("\t\treturn nil, jxEncodeError(\"", jsonName, "\")")
		out.P("\t}")
		out.P("\te.Raw(raw)")
		return
	}

	cond := ""
	switch {
	case isRepeated:
		cond = "len(x." + fieldName + ") > 0"
	case isPointer:
		cond = "x." + fieldName + " != nil"
	case isOmitEmpty:
		cond = g.scalarPresenceExpr("x."+fieldName, field.Kind, field.Kind == typepb.Field_TYPE_ENUM)
	}

	if cond != "" {
		out.P("\tif ", cond, " {")
		out.P("\t\tif e.FieldStart(\"", jsonName, "\") {")
		out.P("\t\t\treturn nil, jxEncodeError(\"", jsonName, "\")")
		out.P("\t\t}")
		g.renderJXEncodeValue(out, ir, field, fieldName, "\t\t", allIRs, imports)
		out.P("\t}")
		return
	}

	out.P("\tif e.FieldStart(\"", jsonName, "\") {")
	out.P("\t\treturn nil, jxEncodeError(\"", jsonName, "\")")
	out.P("\t}")
	switch {
	case isOverride:
		out.P("\traw, err := json.Marshal(x.", fieldName, ")")
		out.P("\tif err != nil {")
		out.P("\t\treturn nil, jxEncodeError(\"", jsonName, "\")")
		out.P("\t}")
		out.P("\te.Raw(raw)")
	case plainMessage:
		out.P("\tif x.", fieldName, " == nil {")
		out.P("\t\te.Null()")
		out.P("\t} else {")
		out.P("\t\traw, err := x.", fieldName, ".MarshalJSON()")
		out.P("\t\tif err != nil {")
		out.P("\t\t\treturn nil, jxEncodeError(\"", jsonName, "\")")
		out.P("\t\t}")
		out.P("\t\te.Raw(raw)")
		out.P("\t}")
	case isProtoMessage:
		out.P("\tif x.", fieldName, " == nil {")
		out.P("\t\te.Null()")
		out.P("\t} else {")
		out.P("\t\traw, err := protojson.Marshal(x.", fieldName, ")")
		out.P("\t\tif err != nil {")
		out.P("\t\t\treturn nil, jxEncodeError(\"", jsonName, "\")")
		out.P("\t\t}")
		out.P("\t\te.Raw(raw)")
		out.P("\t}")
	default:
		g.renderJXEncodeValue(out, ir, field, fieldName, "\t", allIRs, imports)
	}
}

func (g *Generator) renderJXEncodeValue(out typeWriter, ir *TypePbIR, field *typepb.Field, fieldName, indent string, allIRs []*TypePbIR, imports map[string]struct{}) {
	isRepeated := field.Cardinality == typepb.Field_CARDINALITY_REPEATED
	plainMessage := field.Kind == typepb.Field_TYPE_MESSAGE && g.isPlainMessageInIRs(ir, field.TypeUrl, allIRs)
	isProtoMessage := field.Kind == typepb.Field_TYPE_MESSAGE && !plainMessage
	_, isOverride := g.overrideInfo(field)
	alias, isAlias := g.typeAliasInfoForTypeURL(field.TypeUrl)

	if isRepeated {
		if isAlias {
			out.P(indent, "if e.ArrStart() {")
			out.P(indent, "\treturn nil, jxEncodeError(\"", fieldName, "\")")
			out.P(indent, "}")
			out.P(indent, "for _, el := range x.", fieldName, " {")
			g.renderJXEncodeScalar(out, &typepb.Field{Kind: alias.kind}, "el", indent+"\t")
			out.P(indent, "}")
			out.P(indent, "if e.ArrEnd() {")
			out.P(indent, "\treturn nil, jxEncodeError(\"", fieldName, "\")")
			out.P(indent, "}")
			return
		}
		out.P(indent, "if e.ArrStart() {")
		out.P(indent, "\treturn nil, jxEncodeError(\"", fieldName, "\")")
		out.P(indent, "}")
		out.P(indent, "for _, el := range x.", fieldName, " {")
		switch {
		case isOverride:
			out.P(indent, "\traw, err := json.Marshal(el)")
			out.P(indent, "\tif err != nil {")
			out.P(indent, "\t\treturn nil, jxEncodeError(\"", fieldName, "\")")
			out.P(indent, "\t}")
			out.P(indent, "\te.Raw(raw)")
		case plainMessage:
			out.P(indent, "\traw, err := el.MarshalJSON()")
			out.P(indent, "\tif err != nil {")
			out.P(indent, "\t\treturn nil, jxEncodeError(\"", fieldName, "\")")
			out.P(indent, "\t}")
			out.P(indent, "\te.Raw(raw)")
		case isProtoMessage:
			out.P(indent, "\traw, err := protojson.Marshal(el)")
			out.P(indent, "\tif err != nil {")
			out.P(indent, "\t\treturn nil, jxEncodeError(\"", fieldName, "\")")
			out.P(indent, "\t}")
			out.P(indent, "\te.Raw(raw)")
		default:
			g.renderJXEncodeScalar(out, field, "el", indent+"\t")
		}
		out.P(indent, "}")
		out.P(indent, "if e.ArrEnd() {")
		out.P(indent, "\treturn nil, jxEncodeError(\"", fieldName, "\")")
		out.P(indent, "}")
		return
	}

	if g.isPointerField(field) {
		out.P(indent, "if x.", fieldName, " == nil {")
		out.P(indent, "\te.Null()")
		out.P(indent, "} else {")
		if isAlias {
			g.renderJXEncodeScalar(out, &typepb.Field{Kind: alias.kind}, "*x."+fieldName, indent+"\t")
			out.P(indent, "}")
			return
		}
		switch {
		case isOverride:
			out.P(indent, "\traw, err := json.Marshal(x.", fieldName, ")")
			out.P(indent, "\tif err != nil {")
			out.P(indent, "\t\treturn nil, jxEncodeError(\"", fieldName, "\")")
			out.P(indent, "\t}")
			out.P(indent, "\te.Raw(raw)")
		case plainMessage:
			out.P(indent, "\traw, err := x.", fieldName, ".MarshalJSON()")
			out.P(indent, "\tif err != nil {")
			out.P(indent, "\t\treturn nil, jxEncodeError(\"", fieldName, "\")")
			out.P(indent, "\t}")
			out.P(indent, "\te.Raw(raw)")
		case isProtoMessage:
			out.P(indent, "\traw, err := protojson.Marshal(x.", fieldName, ")")
			out.P(indent, "\tif err != nil {")
			out.P(indent, "\t\treturn nil, jxEncodeError(\"", fieldName, "\")")
			out.P(indent, "\t}")
			out.P(indent, "\te.Raw(raw)")
		default:
			g.renderJXEncodeScalar(out, field, "*x."+fieldName, indent+"\t")
		}
		out.P(indent, "}")
		return
	}

	switch {
	case isAlias:
		g.renderJXEncodeScalar(out, &typepb.Field{Kind: alias.kind}, "x."+fieldName, indent)
	case isOverride:
		out.P(indent, "raw, err := json.Marshal(x.", fieldName, ")")
		out.P(indent, "if err != nil {")
		out.P(indent, "\treturn nil, jxEncodeError(\"", fieldName, "\")")
		out.P(indent, "}")
		out.P(indent, "e.Raw(raw)")
	case plainMessage:
		out.P(indent, "if x.", fieldName, " == nil {")
		out.P(indent, "\te.Null()")
		out.P(indent, "} else {")
		out.P(indent, "\traw, err := x.", fieldName, ".MarshalJSON()")
		out.P(indent, "\tif err != nil {")
		out.P(indent, "\t\treturn nil, jxEncodeError(\"", fieldName, "\")")
		out.P(indent, "\t}")
		out.P(indent, "\te.Raw(raw)")
		out.P(indent, "}")
	case isProtoMessage:
		out.P(indent, "if x.", fieldName, " == nil {")
		out.P(indent, "\te.Null()")
		out.P(indent, "} else {")
		out.P(indent, "\traw, err := protojson.Marshal(x.", fieldName, ")")
		out.P(indent, "\tif err != nil {")
		out.P(indent, "\t\treturn nil, jxEncodeError(\"", fieldName, "\")")
		out.P(indent, "\t}")
		out.P(indent, "\te.Raw(raw)")
		out.P(indent, "}")
	default:
		g.renderJXEncodeScalar(out, field, "x."+fieldName, indent)
	}
}

func (g *Generator) renderJXEncodeScalar(out typeWriter, field *typepb.Field, valueExpr, indent string) {
	switch field.Kind {
	case typepb.Field_TYPE_STRING:
		out.P(indent, "e.Str(", valueExpr, ")")
	case typepb.Field_TYPE_BOOL:
		out.P(indent, "e.Bool(", valueExpr, ")")
	case typepb.Field_TYPE_INT32, typepb.Field_TYPE_SINT32, typepb.Field_TYPE_SFIXED32:
		out.P(indent, "e.Int32(", valueExpr, ")")
	case typepb.Field_TYPE_UINT32, typepb.Field_TYPE_FIXED32:
		out.P(indent, "e.UInt32(", valueExpr, ")")
	case typepb.Field_TYPE_INT64, typepb.Field_TYPE_SINT64, typepb.Field_TYPE_SFIXED64:
		out.P(indent, "e.Int64(", valueExpr, ")")
	case typepb.Field_TYPE_UINT64, typepb.Field_TYPE_FIXED64:
		out.P(indent, "e.UInt64(", valueExpr, ")")
	case typepb.Field_TYPE_FLOAT:
		out.P(indent, "e.Float32(", valueExpr, ")")
	case typepb.Field_TYPE_DOUBLE:
		out.P(indent, "e.Float64(", valueExpr, ")")
	case typepb.Field_TYPE_BYTES:
		out.P(indent, "e.Base64(", valueExpr, ")")
	case typepb.Field_TYPE_ENUM:
		out.P(indent, "e.Int32(", valueExpr, ")")
	default:
		out.P(indent, "e.Raw([]byte(\"null\"))")
	}
}

func (g *Generator) renderJXUnmarshalField(out typeWriter, ir *TypePbIR, field *typepb.Field, fieldName string, allIRs []*TypePbIR, imports map[string]struct{}) {
	isRepeated := field.Cardinality == typepb.Field_CARDINALITY_REPEATED
	isPointer := g.isPointerField(field) || (field.Kind == typepb.Field_TYPE_MESSAGE && field.Cardinality != typepb.Field_CARDINALITY_REPEATED)
	plainMessage := field.Kind == typepb.Field_TYPE_MESSAGE && g.isPlainMessageInIRs(ir, field.TypeUrl, allIRs)
	isProtoMessage := field.Kind == typepb.Field_TYPE_MESSAGE && !plainMessage
	override, isOverride := g.overrideInfo(field)
	alias, isAlias := g.typeAliasInfoForTypeURL(field.TypeUrl)
	if isAlias {
		isProtoMessage = false
		plainMessage = false
		isPointer = g.isPointerField(field)
	}
	if info, ok := mapFieldInfoFor(field); ok {
		out.P("\t\t\traw, err := d.Raw()")
		out.P("\t\t\tif err != nil {")
		out.P("\t\t\t\treturn jxDecodeError(\"", fieldName, "\", err)")
		out.P("\t\t\t}")
		valueType := mapScalarGoType(info.valueKind)
		if info.valueKind == typepb.Field_TYPE_MESSAGE {
			plainType := g.plainTypeName(info.valueType)
			if plainType != "" {
				valueType = "*" + plainType
			}
		}
		out.P("\t\t\tvar outVal map[", mapScalarGoType(info.keyKind), "]", valueType)
		out.P("\t\t\tif err := json.Unmarshal(raw, &outVal); err != nil {")
		out.P("\t\t\t\treturn jxDecodeError(\"", fieldName, "\", err)")
		out.P("\t\t\t}")
		out.P("\t\t\tx.", fieldName, " = outVal")
		out.P("\t\t\treturn nil")
		return
	}

	if isRepeated {
		if isAlias {
			out.P("\t\t\tvar outVal []", g.scalarGoType(&typepb.Field{Kind: alias.kind}))
			out.P("\t\t\tif err := d.Arr(func(d *jx.Decoder) error {")
			out.P("\t\t\t\tval, err := ", g.jxDecodeExpr(&typepb.Field{Kind: alias.kind}), "(d)")
			out.P("\t\t\t\tif err != nil {")
			out.P("\t\t\t\t\treturn err")
			out.P("\t\t\t\t}")
			out.P("\t\t\t\toutVal = append(outVal, val)")
			out.P("\t\t\t\treturn nil")
			out.P("\t\t\t}); err != nil {")
			out.P("\t\t\t\treturn jxDecodeError(\"", fieldName, "\", err)")
			out.P("\t\t\t}")
			out.P("\t\t\tx.", fieldName, " = outVal")
			out.P("\t\t\treturn nil")
			return
		}
		switch {
		case isOverride:
			out.P("\t\t\tvar outVal []", override.name)
			out.P("\t\t\traw, err := d.Raw()")
			out.P("\t\t\tif err != nil {")
			out.P("\t\t\t\treturn jxDecodeError(\"", fieldName, "\", err)")
			out.P("\t\t\t}")
			out.P("\t\t\tif err := json.Unmarshal(raw, &outVal); err != nil {")
			out.P("\t\t\t\treturn jxDecodeError(\"", fieldName, "\", err)")
			out.P("\t\t\t}")
			out.P("\t\t\tx.", fieldName, " = outVal")
			out.P("\t\t\treturn nil")
			return
		case plainMessage:
			typeName := g.resolveMessageType(ir, field.TypeUrl, allIRs, imports)
			out.P("\t\t\tvar outVal []", typeName)
			out.P("\t\t\tif err := d.Arr(func(d *jx.Decoder) error {")
			out.P("\t\t\t\traw, err := d.Raw()")
			out.P("\t\t\t\tif err != nil {")
			out.P("\t\t\t\t\treturn err")
			out.P("\t\t\t\t}")
			out.P("\t\t\t\tvar el ", typeName)
			out.P("\t\t\t\tif err := el.UnmarshalJSON(raw); err != nil {")
			out.P("\t\t\t\t\treturn err")
			out.P("\t\t\t\t}")
			out.P("\t\t\t\toutVal = append(outVal, el)")
			out.P("\t\t\t\treturn nil")
			out.P("\t\t\t}); err != nil {")
			out.P("\t\t\t\treturn jxDecodeError(\"", fieldName, "\", err)")
			out.P("\t\t\t}")
			out.P("\t\t\tx.", fieldName, " = outVal")
			out.P("\t\t\treturn nil")
			return
		case isProtoMessage:
			pbType := g.resolvePbTypeName(ir, field.TypeUrl)
			out.P("\t\t\tvar outVal []*", pbType)
			out.P("\t\t\tif err := d.Arr(func(d *jx.Decoder) error {")
			out.P("\t\t\t\traw, err := d.Raw()")
			out.P("\t\t\t\tif err != nil {")
			out.P("\t\t\t\t\treturn err")
			out.P("\t\t\t\t}")
			out.P("\t\t\t\tel := &", pbType, "{}")
			out.P("\t\t\t\tif err := protojson.Unmarshal(raw, el); err != nil {")
			out.P("\t\t\t\t\treturn err")
			out.P("\t\t\t\t}")
			out.P("\t\t\t\toutVal = append(outVal, el)")
			out.P("\t\t\t\treturn nil")
			out.P("\t\t\t}); err != nil {")
			out.P("\t\t\t\treturn jxDecodeError(\"", fieldName, "\", err)")
			out.P("\t\t\t}")
			out.P("\t\t\tx.", fieldName, " = outVal")
			out.P("\t\t\treturn nil")
			return
		default:
			out.P("\t\t\tvar outVal []", g.scalarGoType(field))
			out.P("\t\t\tif err := d.Arr(func(d *jx.Decoder) error {")
			out.P("\t\t\t\tval, err := ", g.jxDecodeExpr(field), "(d)")
			out.P("\t\t\t\tif err != nil {")
			out.P("\t\t\t\t\treturn err")
			out.P("\t\t\t\t}")
			out.P("\t\t\t\toutVal = append(outVal, val)")
			out.P("\t\t\t\treturn nil")
			out.P("\t\t\t}); err != nil {")
			out.P("\t\t\t\treturn jxDecodeError(\"", fieldName, "\", err)")
			out.P("\t\t\t}")
			out.P("\t\t\tx.", fieldName, " = outVal")
			out.P("\t\t\treturn nil")
			return
		}
	}

	if isPointer {
		out.P("\t\t\tif d.Next() == jx.Null {")
		out.P("\t\t\t\tif err := d.Null(); err != nil {")
		out.P("\t\t\t\t\treturn jxDecodeError(\"", fieldName, "\", err)")
		out.P("\t\t\t\t}")
		out.P("\t\t\t\tx.", fieldName, " = nil")
		out.P("\t\t\t\treturn nil")
		out.P("\t\t\t}")
	}

	switch {
	case isOverride:
		out.P("\t\t\traw, err := d.Raw()")
		out.P("\t\t\tif err != nil {")
		out.P("\t\t\t\treturn jxDecodeError(\"", fieldName, "\", err)")
		out.P("\t\t\t}")
		out.P("\t\t\tvar outVal ", override.name)
		out.P("\t\t\tif err := json.Unmarshal(raw, &outVal); err != nil {")
		out.P("\t\t\t\treturn jxDecodeError(\"", fieldName, "\", err)")
		out.P("\t\t\t}")
		if isPointer {
			out.P("\t\t\tx.", fieldName, " = &outVal")
		} else {
			out.P("\t\t\tx.", fieldName, " = outVal")
		}
	case plainMessage:
		typeName := g.resolveMessageType(ir, field.TypeUrl, allIRs, imports)
		out.P("\t\t\traw, err := d.Raw()")
		out.P("\t\t\tif err != nil {")
		out.P("\t\t\t\treturn jxDecodeError(\"", fieldName, "\", err)")
		out.P("\t\t\t}")
		out.P("\t\t\tvar outVal ", typeName)
		out.P("\t\t\tif err := outVal.UnmarshalJSON(raw); err != nil {")
		out.P("\t\t\t\treturn jxDecodeError(\"", fieldName, "\", err)")
		out.P("\t\t\t}")
		out.P("\t\t\tx.", fieldName, " = &outVal")
	case isProtoMessage:
		pbType := g.resolvePbTypeName(ir, field.TypeUrl)
		if typeName, _, ok := wktGoType(field.TypeUrl); ok {
			pbType = typeName
		}
		out.P("\t\t\traw, err := d.Raw()")
		out.P("\t\t\tif err != nil {")
		out.P("\t\t\t\treturn jxDecodeError(\"", fieldName, "\", err)")
		out.P("\t\t\t}")
		out.P("\t\t\toutVal := &", pbType, "{}")
		out.P("\t\t\tif err := protojson.Unmarshal(raw, outVal); err != nil {")
		out.P("\t\t\t\treturn jxDecodeError(\"", fieldName, "\", err)")
		out.P("\t\t\t}")
		out.P("\t\t\tx.", fieldName, " = outVal")
	default:
		if isAlias {
			out.P("\t\t\tval, err := ", g.jxDecodeExpr(&typepb.Field{Kind: alias.kind}), "(d)")
			out.P("\t\t\tif err != nil {")
			out.P("\t\t\t\treturn jxDecodeError(\"", fieldName, "\", err)")
			out.P("\t\t\t}")
			if isPointer {
				out.P("\t\t\tx.", fieldName, " = &val")
			} else {
				out.P("\t\t\tx.", fieldName, " = val")
			}
			out.P("\t\t\treturn nil")
			return
		}
		out.P("\t\t\tval, err := ", g.jxDecodeExpr(field), "(d)")
		out.P("\t\t\tif err != nil {")
		out.P("\t\t\t\treturn jxDecodeError(\"", fieldName, "\", err)")
		out.P("\t\t\t}")
		if isPointer {
			out.P("\t\t\tx.", fieldName, " = &val")
		} else {
			out.P("\t\t\tx.", fieldName, " = val")
		}
	}
	out.P("\t\t\treturn nil")
}

func (g *Generator) renderJXUnmarshalOneof(out typeWriter, ir *TypePbIR, msg *typepb.Type, oneof oneofField) {
	_ = ir
	msgGo := getShortName(msg.Name)
	out.P("\t\t\traw, err := d.Raw()")
	out.P("\t\t\tif err != nil {")
	out.P("\t\t\t\treturn jxDecodeError(\"", oneof.tag, "\", err)")
	out.P("\t\t\t}")
	out.P("\t\t\tif bytes.Equal(raw, []byte(\"null\")) {")
	out.P("\t\t\t\tx.", oneof.fieldName, " = nil")
	out.P("\t\t\t\treturn nil")
	out.P("\t\t\t}")
	out.P("\t\t\tvar payload map[string]json.RawMessage")
	out.P("\t\t\tif err := json.Unmarshal(raw, &payload); err != nil {")
	out.P("\t\t\t\treturn jxDecodeError(\"", oneof.tag, "\", err)")
	out.P("\t\t\t}")

	fields := g.fieldsForOneof(msg, oneof.fieldName)
	for _, field := range fields {
		fieldGo := strcase.ToCamel(getShortName(field.Name))
		jsonName := field.JsonName
		if jsonName == "" {
			jsonName = strcase.ToLowerCamel(getShortName(field.Name))
		}
		out.P("\t\t\tif _, ok := payload[\"", jsonName, "\"]; ok {")
		out.P("\t\t\t\tvar wrapper ", msgGo, "_", fieldGo)
		out.P("\t\t\t\tif err := json.Unmarshal(raw, &wrapper); err != nil {")
		out.P("\t\t\t\t\treturn jxDecodeError(\"", oneof.tag, "\", err)")
		out.P("\t\t\t\t}")
		out.P("\t\t\t\tx.", oneof.fieldName, " = &wrapper")
		out.P("\t\t\t\treturn nil")
		out.P("\t\t\t}")
	}
	out.P("\t\t\treturn nil")
}

func (g *Generator) fieldsForOneof(msg *typepb.Type, oneofFieldName string) []*typepb.Field {
	if msg == nil {
		return nil
	}
	var fields []*typepb.Field
	for _, field := range msg.Fields {
		if field.OneofIndex == 0 {
			continue
		}
		oneofIdx := int(field.OneofIndex) - 1
		if oneofIdx < 0 || oneofIdx >= len(msg.Oneofs) {
			continue
		}
		oneofName := strcase.ToCamel(getShortName(msg.Oneofs[oneofIdx]))
		if oneofName == oneofFieldName {
			fields = append(fields, field)
		}
	}
	return fields
}

func (g *Generator) isPlainMessage(ir *TypePbIR, typeURL string) bool {
	return g.isPlainMessageInIRs(ir, typeURL, nil)
}

func (g *Generator) isPlainMessageInIRs(ir *TypePbIR, typeURL string, allIRs []*TypePbIR) bool {
	target := empath.Parse(typeURL).Last().Value()
	if g.isTypeAliasMessage(target) {
		return false
	}
	_, ok := g.findMessage(ir, typeURL)
	if ok {
		return true
	}
	// If not found in current IR, search in all IRs
	if allIRs != nil {
		for _, otherIR := range allIRs {
			if otherIR.File == nil {
				continue
			}
			_, ok := g.findMessage(otherIR, typeURL)
			if ok {
				return true
			}
		}
	}
	return false
}

func (g *Generator) scalarGoType(field *typepb.Field) string {
	switch field.Kind {
	case typepb.Field_TYPE_STRING:
		return "string"
	case typepb.Field_TYPE_BOOL:
		return "bool"
	case typepb.Field_TYPE_INT32, typepb.Field_TYPE_SINT32, typepb.Field_TYPE_SFIXED32:
		return "int32"
	case typepb.Field_TYPE_UINT32, typepb.Field_TYPE_FIXED32:
		return "uint32"
	case typepb.Field_TYPE_INT64, typepb.Field_TYPE_SINT64, typepb.Field_TYPE_SFIXED64:
		return "int64"
	case typepb.Field_TYPE_UINT64, typepb.Field_TYPE_FIXED64:
		return "uint64"
	case typepb.Field_TYPE_FLOAT:
		return "float32"
	case typepb.Field_TYPE_DOUBLE:
		return "float64"
	case typepb.Field_TYPE_BYTES:
		return "[]byte"
	case typepb.Field_TYPE_ENUM:
		return "int32"
	default:
		return "any"
	}
}

func (g *Generator) jxDecodeExpr(field *typepb.Field) string {
	switch field.Kind {
	case typepb.Field_TYPE_STRING:
		return "(*jx.Decoder).Str"
	case typepb.Field_TYPE_BOOL:
		return "(*jx.Decoder).Bool"
	case typepb.Field_TYPE_INT32, typepb.Field_TYPE_SINT32, typepb.Field_TYPE_SFIXED32:
		return "(*jx.Decoder).Int32"
	case typepb.Field_TYPE_UINT32, typepb.Field_TYPE_FIXED32:
		return "(*jx.Decoder).UInt32"
	case typepb.Field_TYPE_INT64, typepb.Field_TYPE_SINT64, typepb.Field_TYPE_SFIXED64:
		return "(*jx.Decoder).Int64"
	case typepb.Field_TYPE_UINT64, typepb.Field_TYPE_FIXED64:
		return "(*jx.Decoder).UInt64"
	case typepb.Field_TYPE_FLOAT:
		return "(*jx.Decoder).Float32"
	case typepb.Field_TYPE_DOUBLE:
		return "(*jx.Decoder).Float64"
	case typepb.Field_TYPE_BYTES:
		return "(*jx.Decoder).Base64"
	case typepb.Field_TYPE_ENUM:
		return "(*jx.Decoder).Int32"
	default:
		return "(*jx.Decoder).Skip"
	}
}
