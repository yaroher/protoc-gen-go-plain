package generator

import (
	"strings"

	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/reflect/protoreflect"
)

type Generator struct {
	Settings *PluginSettings
	Plugin   *protogen.Plugin
}

func NewGenerator(p *protogen.Plugin) (*Generator, error) {
	settings, err := NewPluginSettingsFromPlugin(p)
	if err != nil {
		return nil, err
	}
	return &Generator{
		Settings: settings,
		Plugin:   p,
	}, nil
}

func (g *Generator) writeEmpty() error {
	for _, f := range g.Plugin.Files {
		if !strings.Contains(string(f.Desc.Package()), "naukograd") {
			continue
		}
		naukogradFile := g.Plugin.NewGeneratedFile(f.GeneratedFilenamePrefix+".pb.empty_initialized.go", f.GoImportPath)
		naukogradFile.P("// Code generated by protoc-gen-naukograd. DO NOT EDIT.\n\n")
		naukogradFile.P("package " + f.GoPackageName + "\n\n")
		genCount := 0
		writeMessageEmpty := func(m *protogen.Message) {
			naukogradFile.P("func (m *" + m.GoIdent.GoName + ") EmptyInitialized() *" + m.GoIdent.GoName + " {")
			naukogradFile.P("	return &" + m.GoIdent.GoName + "{")
			for _, field := range m.Fields {
				if field.Desc.Kind() == protoreflect.MessageKind && !field.Desc.IsList() && !field.Desc.IsMap() {
					sufix := ".EmptyInitialized(),"
					if isKnownType(field) {
						sufix = ","
					}
					naukogradFile.P("" + field.GoName + ": (&" + naukogradFile.QualifiedGoIdent(field.Message.GoIdent) + "{})" + sufix)
					continue
				}
				if field.Desc.IsMap() {
					keyType := getFieldGoType(field.Message.Fields[0])
					valType := getFieldGoType(field.Message.Fields[1])
					naukogradFile.P("" + field.GoName + ": make(map[" + keyType + "]" + valType + "),")
					continue
				}
			}
			naukogradFile.P("}")
			naukogradFile.P("}\n")
		}

		for _, m := range f.Messages {
			genCount++
			writeMessageEmpty(m)
			for _, inM := range m.Messages {
				writeMessageEmpty(inM)
			}
		}
		if genCount == 0 {
			naukogradFile.Skip()
		}
	}
	return nil
}

func (g *Generator) Generate() error {
	err := g.writeEmpty()
	if err != nil {
		return err
	}
	for _, f := range g.Plugin.Files {
		if !f.Generate {
			continue
		}
		fg := newFileGen(g, f)
		fg.genFile()
	}
	return nil
}
