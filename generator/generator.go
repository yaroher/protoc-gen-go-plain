package generator

import (
	"github.com/yaroher/protoc-gen-go-plain/goplain"
	"github.com/yaroher/protoc-gen-plain/converter"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/types/descriptorpb"
)

type Generator struct {
	Settings *PluginSettings
	Plugin   *protogen.Plugin
	suffix   string

	overrides []*goplain.TypeOverride
}

type Option func(*Generator) error

func WithPlainSuffix(suffix string) Option {
	return func(g *Generator) error {
		g.suffix = suffix
		return nil
	}
}

func WithTypeOverrides(overrides []*goplain.TypeOverride) Option {
	return func(g *Generator) error {
		g.overrides = overrides
		return nil
	}
}

func NewGenerator(p *protogen.Plugin, opts ...Option) (*Generator, error) {
	settings, err := NewPluginSettingsFromPlugin(p)
	if err != nil {
		return nil, err
	}
	g := &Generator{
		Settings: settings,
		Plugin:   p,
		suffix:   "Plain",
	}
	for _, opt := range opts {
		if opt == nil {
			continue
		}
		if err := opt(g); err != nil {
			return nil, err
		}
	}
	g.overrides = mergeOverrides(g.overrides, getPluginOverrides(g.Plugin))
	return g, nil
}

func (g *Generator) GetOverrides() []*goplain.TypeOverride {
	return g.overrides
}

func (g *Generator) AddOverride(override *goplain.TypeOverride) {
	g.overrides = append(g.overrides, override)
}

func (g *Generator) Generate() error {
	// Собираем type alias overrides ДО конверсии
	typeAliasOverrides := buildTypeAliasOverrides(g.Plugin)

	newPlugin, metadata, err := converter.Convert(g.Plugin, converter.WithPlainSuffix(g.suffix))
	if err != nil {
		return err
	}

	for _, fd := range newPlugin.Files {
		plainFile := g.Plugin.NewGeneratedFile(fd.GeneratedFilenamePrefix+".pb.go_plain.go", fd.GoImportPath)
		plainFile.P("// Code generated by protoc-gen-go-plain. DO NOT EDIT.\n\n")
		plainFile.P("package " + fd.GoPackageName + "\n\n")
		genCounter := 0

		for _, m := range fd.Messages {
			msgOpts := m.Desc.Options().(*descriptorpb.MessageOptions)
			msgGenerate := proto.GetExtension(msgOpts, goplain.E_Message).(*goplain.MessageOptions)
			if !msgGenerate.GetGenerate() {
				continue
			}
			msgMeta := metadata.GetMessageMetadata(string(m.Desc.FullName()))
			if msgMeta == nil || msgMeta.OriginalMessage == nil {
				continue
			}

			genCounter++

			// Генерируем структуру и методы для сообщения
			generateMessageAndMethods(plainFile, m, msgMeta, typeAliasOverrides)
		}
		if genCounter == 0 {
			plainFile.Skip()
		}
	}
	return nil
}

// generateMessageAndMethods генерирует структуру и методы конверсии для сообщения
func generateMessageAndMethods(g *protogen.GeneratedFile, m *protogen.Message, msgMeta *converter.MessageMetadata, typeAliasOverrides map[string]*goplain.GoIdent) {
	// Генерируем структуру
	g.P("type " + m.GoIdent.GoName + " struct {\n")
	for _, f := range m.Fields {
		fieldType := getFieldGoTypeWithMetadata(g, f, msgMeta)
		g.P("\t" + f.GoName + " " + fieldType)
	}
	g.P("}\n\n")

	// Генерируем методы конверсии
	if msgMeta != nil && msgMeta.OriginalMessage != nil {
		generateConverterMethods(g, m, msgMeta, typeAliasOverrides)
	}
}
