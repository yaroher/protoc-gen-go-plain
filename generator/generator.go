package generator

import (
	"encoding/json"
	"fmt"
	"strings"

	"github.com/yaroher/protoc-gen-go-plain/goplain"
	"github.com/yaroher/protoc-gen-go-plain/ir"
	"github.com/yaroher/protoc-gen-go-plain/logger"
	"go.uber.org/zap"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/types/descriptorpb"
	"google.golang.org/protobuf/types/pluginpb"
)

type Generator struct {
	Settings *PluginSettings
	Plugin   *protogen.Plugin
	suffix   string

	overrides []*goplain.TypeOverride
}

type Option func(*Generator) error

func WithPlainSuffix(suffix string) Option {
	return func(g *Generator) error {
		g.suffix = suffix
		return nil
	}
}

func WithTypeOverrides(overrides []*goplain.TypeOverride) Option {
	return func(g *Generator) error {
		g.overrides = overrides
		return nil
	}
}

func NewGenerator(p *protogen.Plugin, opts ...Option) (*Generator, error) {
	settings, err := NewPluginSettingsFromPlugin(p)
	if err != nil {
		return nil, err
	}
	g := &Generator{
		Settings: settings,
		Plugin:   p,
		suffix:   "Plain",
	}
	for _, opt := range opts {
		if opt == nil {
			continue
		}
		if err := opt(g); err != nil {
			return nil, err
		}
	}
	return g, nil
}

func (g *Generator) GetOverrides() []*goplain.TypeOverride {
	return g.overrides
}

func (g *Generator) AddOverride(override *goplain.TypeOverride) {
	g.overrides = append(g.overrides, override)
}

func (g *Generator) Generate() error {
	origReq := proto.Clone(g.Plugin.Request).(*pluginpb.CodeGeneratorRequest)
	origPlugin, origErr := protogen.Options{}.New(origReq)
	if origErr != nil {
		logger.Error("Build original plugin failed", zap.Error(origErr))
	}

	plan, err := ir.BuildIR(g.Plugin, ir.IRConfig{PlainSuffix: g.suffix})
	if err != nil {
		logger.Error("BuildIR failed", zap.Error(err))
	}
	newPlugin, applyErr := ir.ApplyIR(g.Plugin, plan)
	if applyErr != nil {
		logger.Error("ApplyIR failed", zap.Error(applyErr))
		return applyErr
	}

	encoded, encErr := json.MarshalIndent(plan, "", "  ")
	if encErr != nil {
		logger.Error("IR marshal failed", zap.Error(encErr))
	} else {
		logger.Info("IR", zap.String("plan", string(encoded)))
	}

	generatedEnums := buildGeneratedEnumSet(plan)
	origMsgs := buildMessageMap(origPlugin)
	enumValues := buildEnumValueMap(origPlugin)

	genCount := 0
	for _, fd := range newPlugin.Files {
		if !fd.Generate {
			continue
		}
		plainFile := g.Plugin.NewGeneratedFile(fd.GeneratedFilenamePrefix+".pb.go_plain.go", fd.GoImportPath)
		plainFile.P("// Code generated by protoc-gen-go-plain. DO NOT EDIT.\n\n")
		plainFile.P("package " + fd.GoPackageName + "\n\n")

		fileCount := 0
		// build IR lookup by new full name for this file
		irByNew := make(map[string]*ir.MessageIR)
		for _, msgIR := range plan.Messages {
			if msgIR == nil {
				continue
			}
			if msgIR.File == fd.Desc.Path() && msgIR.Generate {
				key := msgIR.NewFullName
				irByNew[key] = msgIR
				irByNew[strings.TrimPrefix(key, ".")] = msgIR
			}
		}

		for _, m := range fd.Messages {
			if m.Desc.Parent() != m.Desc.ParentFile() {
				continue
			}
			msgOpts := m.Desc.Options().(*descriptorpb.MessageOptions)
			if !proto.HasExtension(msgOpts, goplain.E_Message) {
				continue
			}
			msgGenerate := proto.GetExtension(msgOpts, goplain.E_Message).(*goplain.MessageOptions)
			if !msgGenerate.GetGenerate() {
				continue
			}
			fileCount++
			genCount++
			msgIR := irByNew[string(m.Desc.FullName())]
			generateModel(plainFile, m, generatedEnums, msgIR)
			pbFull := strings.TrimSuffix(string(m.Desc.FullName()), g.suffix)
			pbMsg := origMsgs[pbFull]
			if pbMsg != nil {
				generateConverters(plainFile, m, pbMsg, msgIR, generatedEnums, enumValues)
			}
		}
		if fileCount == 0 {
			plainFile.Skip()
		}
	}

	logger.Info("Generated models", zap.Int("count", genCount))
	return err
}

func buildGeneratedEnumSet(plan *ir.IR) map[string]struct{} {
	result := make(map[string]struct{})
	for _, msg := range plan.Messages {
		for _, e := range msg.GeneratedEnums {
			if e == nil {
				continue
			}
			full := strings.TrimPrefix(msg.NewFullName+"."+e.Name, ".")
			result[full] = struct{}{}
		}
	}
	return result
}

func buildEnumValueMap(p *protogen.Plugin) map[string]*protogen.EnumValue {
	result := make(map[string]*protogen.EnumValue)
	if p == nil {
		return result
	}
	for _, f := range p.Files {
		for _, e := range f.Enums {
			registerEnumValues(result, e)
		}
		for _, m := range f.Messages {
			registerMessageEnums(result, m)
		}
	}
	return result
}

func registerMessageEnums(result map[string]*protogen.EnumValue, m *protogen.Message) {
	if m == nil {
		return
	}
	for _, e := range m.Enums {
		registerEnumValues(result, e)
	}
	for _, nested := range m.Messages {
		registerMessageEnums(result, nested)
	}
}

func registerEnumValues(result map[string]*protogen.EnumValue, e *protogen.Enum) {
	if e == nil {
		return
	}
	for _, v := range e.Values {
		full := "." + string(v.Desc.FullName())
		result[full] = v
	}
}

func generateModel(g *protogen.GeneratedFile, m *protogen.Message, generatedEnums map[string]struct{}, msgIR *ir.MessageIR) {
	parentGoName := m.GoIdent.GoName
	origParentGoName := strings.TrimSuffix(parentGoName, "Plain")

	for _, enum := range m.Enums {
		if _, ok := generatedEnums[string(enum.Desc.FullName())]; !ok {
			continue
		}
		generateEnum(g, enum)
	}

	g.P("type " + m.GoIdent.GoName + " struct {\n")
	irFields := make(map[string]*ir.FieldPlan)
	if msgIR != nil {
		for _, fp := range msgIR.FieldPlan {
			if fp == nil {
				continue
			}
			irFields[fp.NewField.Name] = fp
		}
	}

	for _, f := range m.Fields {
		fieldType := getFieldGoTypeForGenWithEnums(g, f, parentGoName, origParentGoName, generatedEnums)
		if fp := irFields[string(f.Desc.Name())]; fp != nil && hasOverride(fp) {
			fieldType = getOverrideGoType(g, f, fp)
		}
		comment := buildFieldComment(f, irFields, origParentGoName)
		if comment != "" {
			g.P("\t// " + comment)
			g.P("\t" + f.GoName + " " + fieldType)
		} else {
			g.P("\t" + f.GoName + " " + fieldType)
		}
	}
	g.P("}\n\n")
}

func buildFieldComment(field *protogen.Field, irFields map[string]*ir.FieldPlan, origParentGoName string) string {
	if field == nil {
		return ""
	}
	fp, ok := irFields[string(field.Desc.Name())]
	if !ok {
		return ""
	}
	transform := describeTransform(fp)
	if fp.OrigField == nil {
		return "src: <virtual>; transform: " + transform
	}
	origName := fp.OrigField.FieldName
	origMsg := fp.OrigField.MessageFullName
	if fp.Origin.IsEmbedded && fp.Origin.EmbedSource != nil {
		return "src: " + origMsg + "." + origName + "; transform: " + transform
	}
	return "src: " + origMsg + "." + origName + "; transform: " + transform
}

func describeTransform(fp *ir.FieldPlan) string {
	if fp == nil {
		return "none"
	}
	parts := make([]string, 0, 4)
	if fp.Origin.IsEmbedded {
		parts = append(parts, "embed")
	}
	if fp.Origin.IsSerialized {
		parts = append(parts, "serialize")
	}
	if fp.Origin.IsTypeAlias {
		parts = append(parts, "type_alias")
	}
	if fp.Origin.IsVirtual {
		parts = append(parts, "virtual")
	}
	if fp.Origin.IsOneof {
		parts = append(parts, "oneof")
	}
	for _, op := range fp.Ops {
		if op.Kind == ir.OpOverrideType {
			parts = append(parts, "override_type")
			break
		}
	}
	if len(parts) == 0 {
		return "none"
	}
	return strings.Join(parts, "|")
}

func generateEnum(g *protogen.GeneratedFile, e *protogen.Enum) {
	g.P("type " + e.GoIdent.GoName + " int32\n\n")
	g.P("const (")
	for _, v := range e.Values {
		g.P("\t" + v.GoIdent.GoName + " " + e.GoIdent.GoName + " = " + fmt.Sprintf("%d", v.Desc.Number()))
	}
	g.P(")\n\n")
}
