package generator

import (
	"fmt"
	"strings"

	"github.com/yaroher/protoc-gen-go-plain/goplain"
	"github.com/yaroher/protoc-gen-go-plain/logger"
	"go.uber.org/zap"
	"google.golang.org/protobuf/compiler/protogen"
)

type Generator struct {
	Settings *PluginSettings
	Plugin   *protogen.Plugin
	suffix   string

	overrides []*goplain.TypeOverride

	// castersAsStruct - временное поле для текущего файла
	castersAsStruct bool
}

type Option func(*Generator) error

func WithPlainSuffix(suffix string) Option {
	return func(g *Generator) error {
		g.suffix = suffix
		return nil
	}
}

func WithTypeOverrides(overrides []*goplain.TypeOverride) Option {
	return func(g *Generator) error {
		g.overrides = overrides
		return nil
	}
}

func NewGenerator(p *protogen.Plugin, opts ...Option) (*Generator, error) {
	settings, err := NewPluginSettingsFromPlugin(p)
	if err != nil {
		return nil, err
	}
	g := &Generator{
		Settings: settings,
		Plugin:   p,
		suffix:   "Plain",
	}
	for _, opt := range opts {
		if opt == nil {
			continue
		}
		if err := opt(g); err != nil {
			return nil, err
		}
	}
	return g, nil
}

func (g *Generator) GetOverrides() []*goplain.TypeOverride {
	return g.overrides
}

func (g *Generator) AddOverride(override *goplain.TypeOverride) {
	g.overrides = append(g.overrides, override)
}

func (g *Generator) Generate() error {
	logger.Info("generate start", zap.Int("files", len(g.Plugin.Files)))

	for _, f := range g.Plugin.Files {
		if !f.Generate {
			continue
		}

		logger.Debug("processing file", zap.String("path", f.Desc.Path()))

		// Generate JX methods for protobuf types if enabled
		if g.Settings.JXPB && len(f.Messages) > 0 {
			if err := g.generatePbJXFile(f); err != nil {
				return fmt.Errorf("failed to generate pb jx for %s: %w", f.Desc.Path(), err)
			}
		}

		// Build IR
		builder := NewIRBuilder(g.suffix)
		builder.GlobalOverrides = g.overrides

		irFile, err := builder.BuildFile(f)
		if err != nil {
			logger.Error("failed to build IR", zap.Error(err), zap.String("file", f.Desc.Path()))
			return fmt.Errorf("failed to build IR for %s: %w", f.Desc.Path(), err)
		}

		// Skip files without plain messages
		if len(irFile.Messages) == 0 {
			logger.Debug("no plain messages to generate", zap.String("file", f.Desc.Path()))
			continue
		}

		// Fail on collisions
		if len(builder.Collisions) > 0 {
			for _, collision := range builder.Collisions {
				logger.Error("field collision detected",
					zap.String("message", collision.Message.Name),
					zap.String("field", collision.FieldName),
					zap.String("existing_origin", collision.ExistingField.Origin.String()),
					zap.String("existing_empath", collision.ExistingField.EmPath),
					zap.String("new_origin", collision.NewField.Origin.String()),
					zap.String("new_empath", collision.NewField.EmPath),
				)
			}
			return fmt.Errorf("field collisions detected in %s: %d collision(s), first: %s",
				f.Desc.Path(), len(builder.Collisions), builder.Collisions[0].Error())
		}

		// Log IR for debugging
		logger.Debug("IR built", zap.String("dump", irFile.Dump()))

		// Generate Go code
		if err := g.generateFile(f, irFile); err != nil {
			return fmt.Errorf("failed to generate %s: %w", f.Desc.Path(), err)
		}
	}

	logger.Info("generate complete")
	return nil
}

// generatePbJXFile generates JX methods for all protobuf messages in a file
func (g *Generator) generatePbJXFile(f *protogen.File) error {
	filename := f.GeneratedFilenamePrefix + "_jx.pb.go"
	gf := g.Plugin.NewGeneratedFile(filename, f.GoImportPath)

	logger.Debug("generating pb jx file", zap.String("filename", filename))

	// Write header
	gf.P("// Code generated by protoc-gen-go-plain. DO NOT EDIT.")
	gf.P("// source: ", f.Desc.Path())
	gf.P()
	gf.P("package ", f.GoPackageName)
	gf.P()

	// Generate JX methods for all messages (including nested)
	for _, msg := range f.Messages {
		g.generatePbJXForMessage(gf, msg, f)
	}

	return nil
}

// generatePbJXForMessage generates JX methods for a message and its nested messages
func (g *Generator) generatePbJXForMessage(gf *protogen.GeneratedFile, msg *protogen.Message, f *protogen.File) {
	// Skip map entry messages
	if msg.Desc.IsMapEntry() {
		return
	}

	g.generatePbJXMethods(gf, msg, f)

	// Generate for nested messages
	for _, nested := range msg.Messages {
		g.generatePbJXForMessage(gf, nested, f)
	}
}

func (g *Generator) generateFile(f *protogen.File, irFile *IRFile) error {
	// Create output file with _plain.pb.go suffix
	filename := f.GeneratedFilenamePrefix + "_plain.pb.go"
	gf := g.Plugin.NewGeneratedFile(filename, f.GoImportPath)

	// Set casters mode from plugin settings (global flag)
	g.castersAsStruct = g.Settings.CastersAsStruct

	logger.Debug("generating file", zap.String("filename", filename))

	// Write header
	gf.P("// Code generated by protoc-gen-go-plain. DO NOT EDIT.")
	gf.P("// source: ", f.Desc.Path())
	gf.P()
	gf.P("package ", f.GoPackageName)
	gf.P()

	// Generate structs (imports will be added automatically by protogen)
	for _, msg := range irFile.Messages {
		g.generateMessage(gf, msg, f, irFile)
	}

	return nil
}

func (g *Generator) generateMessage(gf *protogen.GeneratedFile, msg *IRMessage, f *protogen.File, irFile *IRFile) {
	// Generate comment
	if msg.Comment != "" {
		for _, line := range strings.Split(strings.TrimSpace(msg.Comment), "\n") {
			gf.P("// ", strings.TrimPrefix(line, "// "))
		}
	}

	// Generate struct
	gf.P("type ", msg.GoName, " struct {")

	for _, field := range msg.Fields {
		g.generateField(gf, field, f)
	}

	// Generate oneof case fields
	for _, eo := range msg.EmbeddedOneofs {
		gf.P("\t// ", eo.CaseFieldName, " indicates which variant of ", eo.Name, " oneof is set")
		gf.P("\t", eo.CaseFieldName, " string `json:\"", eo.JSONName, ",omitempty\"`")
	}

	// Generate _src field for sparse serialization (indices of populated fields)
	gf.P("\t// Src_ contains indices of populated fields for sparse serialization")
	gf.P("\tSrc_ []uint16 `json:\"_src,omitempty\"`")

	gf.P("}")
	gf.P()

	// Generate conversion methods
	g.generateConversionMethods(gf, msg, f, irFile)

	// Generate JSON methods
	if g.Settings.JSONJX {
		g.generateJSONMethods(gf, msg, f)
	}

	// Generate Pool methods
	if g.Settings.GeneratePool {
		g.generatePoolMethods(gf, msg)
	}

	// Generate nested messages
	for _, nested := range msg.Nested {
		g.generateMessage(gf, nested, f, irFile)
	}
}

func (g *Generator) generateField(gf *protogen.GeneratedFile, field *IRField, f *protogen.File) {
	// Build type string using QualifiedGoIdent for proper import handling
	typeStr := g.buildTypeString(gf, field, f)

	// Build JSON tag
	jsonTag := field.JSONName
	if field.IsOptional {
		jsonTag += ",omitempty"
	}

	// Build comment with origin info
	comment := ""
	if field.EmPath != "" {
		comment = fmt.Sprintf(" // origin: %s, empath: %s", field.Origin, field.EmPath)
	}

	gf.P("\t", field.GoName, " ", typeStr, " `json:\"", jsonTag, "\"`", comment)
}

func (g *Generator) buildTypeString(gf *protogen.GeneratedFile, field *IRField, f *protogen.File) string {
	var sb strings.Builder

	if field.IsRepeated && !field.GoType.IsSlice {
		sb.WriteString("[]")
	}

	if field.GoType.IsSlice {
		sb.WriteString("[]")
	}

	if field.GoType.IsPointer {
		sb.WriteString("*")
	}

	// Handle map types
	if field.Kind == KindMap && field.MapKey != nil && field.MapValue != nil {
		sb.WriteString("map[")
		sb.WriteString(g.qualifyType(gf, field.MapKey.GoType, f))
		sb.WriteString("]")
		if field.MapValue.GoType.IsPointer {
			sb.WriteString("*")
		}
		sb.WriteString(g.qualifyType(gf, field.MapValue.GoType, f))
		return sb.String()
	}

	sb.WriteString(g.qualifyType(gf, field.GoType, f))

	return sb.String()
}

// qualifyType returns the qualified type name, using protogen's import system
func (g *Generator) qualifyType(gf *protogen.GeneratedFile, goType GoType, f *protogen.File) string {
	// If no import path or same package, return just the name
	if goType.ImportPath == "" || goType.ImportPath == string(f.GoImportPath) {
		return goType.Name
	}

	// Use QualifiedGoIdent for proper import handling with aliases
	ident := protogen.GoIdent{
		GoName:       goType.Name,
		GoImportPath: protogen.GoImportPath(goType.ImportPath),
	}
	return gf.QualifiedGoIdent(ident)
}
