package generator

import (
	"strings"

	"github.com/yaroher/protoc-gen-go-plain/goplain"
	"github.com/yaroher/protoc-gen-plain/converter"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/types/descriptorpb"
)

type Generator struct {
	Settings *PluginSettings
	Plugin   *protogen.Plugin
	suffix   string

	overrides []*goplain.TypeOverride
}

type Option func(*Generator) error

func WithPlainSuffix(suffix string) Option {
	return func(g *Generator) error {
		g.suffix = suffix
		return nil
	}
}

func WithTypeOverrides(overrides []*goplain.TypeOverride) Option {
	return func(g *Generator) error {
		g.overrides = overrides
		return nil
	}
}

func NewGenerator(p *protogen.Plugin, opts ...Option) (*Generator, error) {
	settings, err := NewPluginSettingsFromPlugin(p)
	if err != nil {
		return nil, err
	}
	g := &Generator{
		Settings: settings,
		Plugin:   p,
		suffix:   "Plain",
	}
	for _, opt := range opts {
		if opt == nil {
			continue
		}
		if err := opt(g); err != nil {
			return nil, err
		}
	}
	g.overrides = mergeOverrides(g.overrides, getPluginOverrides(g.Plugin))
	return g, nil
}

func (g *Generator) GetOverrides() []*goplain.TypeOverride {
	return g.overrides
}

func (g *Generator) AddOverride(override *goplain.TypeOverride) {
	g.overrides = append(g.overrides, override)
}

func (g *Generator) Generate() error {
	// Собираем type alias overrides ДО конверсии
	typeAliasOverrides := buildTypeAliasOverrides(g.Plugin)

	// Собираем pb messages ДО конверсии
	pbMessages := make(map[string]*protogen.Message)
	for _, fd := range g.Plugin.Files {
		if fd.Generate {
			collectMessages(fd.Messages, pbMessages)
		}
	}

	newPlugin, err := converter.Convert(g.Plugin, converter.WithPlainSuffix(g.suffix))
	if err != nil {
		return err
	}

	// Строим мапу plain message -> pb message
	plainToPbMap := linkPlainMessagesWithPb(newPlugin, pbMessages)

	for _, fd := range newPlugin.Files {
		plainFile := g.Plugin.NewGeneratedFile(fd.GeneratedFilenamePrefix+".pb.go_plain.go", fd.GoImportPath)
		plainFile.P("// Code generated by protoc-gen-go-plain. DO NOT EDIT.\n\n")
		plainFile.P("package " + fd.GoPackageName + "\n\n")
		genCounter := 0

		for _, m := range fd.Messages {
			msgOpts := m.Desc.Options().(*descriptorpb.MessageOptions)
			msgGenerate := proto.GetExtension(msgOpts, goplain.E_Message).(*goplain.MessageOptions)
			if !msgGenerate.GetGenerate() {
				continue
			}
			genCounter++

			// Генерируем структуру и методы для сообщения
			generateMessageAndMethods(plainFile, m, plainToPbMap, typeAliasOverrides)
		}
		if genCounter == 0 {
			plainFile.Skip()
		}
	}
	return nil
}

// linkPlainMessagesWithPb создает мапу plain message name -> pb message
func linkPlainMessagesWithPb(plainPlugin *protogen.Plugin, pbMessages map[string]*protogen.Message) map[string]*protogen.Message {
	result := make(map[string]*protogen.Message)

	// Связываем plain messages с pb messages
	for _, fd := range plainPlugin.Files {
		if fd.Generate {
			linkPlainToPb(fd.Messages, pbMessages, result)
		}
	}

	return result
}

// collectMessages рекурсивно собирает все pb сообщения
func collectMessages(messages []*protogen.Message, pbMessages map[string]*protogen.Message) {
	for _, m := range messages {
		pbMessages[m.GoIdent.GoName] = m
		// Рекурсивно обрабатываем вложенные сообщения
		collectMessages(m.Messages, pbMessages)
	}
}

// linkPlainToPb рекурсивно связывает plain messages с pb messages
func linkPlainToPb(messages []*protogen.Message, pbMessages map[string]*protogen.Message, result map[string]*protogen.Message) {
	for _, m := range messages {
		// Убираем суффикс "Plain" из конца имени
		goName := m.GoIdent.GoName
		if strings.HasSuffix(goName, "Plain") {
			pbName := strings.TrimSuffix(goName, "Plain")
			if pbMsg, ok := pbMessages[pbName]; ok {
				result[goName] = pbMsg
			}
		}
		// Рекурсивно обрабатываем вложенные сообщения
		linkPlainToPb(m.Messages, pbMessages, result)
	}
}

// generateMessageAndMethods генерирует структуру и методы конверсии для сообщения
func generateMessageAndMethods(g *protogen.GeneratedFile, m *protogen.Message, plainToPbMap map[string]*protogen.Message, typeAliasOverrides map[string]*goplain.GoIdent) {
	// Генерируем структуру
	g.P("type " + m.GoIdent.GoName + " struct {\n")
	for _, f := range m.Fields {
		fieldType := getFieldGoTypeWithFile(g, f, typeAliasOverrides)
		g.P("\t" + f.GoName + " " + fieldType)
	}
	g.P("}\n\n")

	// Генерируем методы конверсии
	if pbMsg, ok := plainToPbMap[m.GoIdent.GoName]; ok {
		generateConverterMethods(g, m, pbMsg, typeAliasOverrides)
	}
}
