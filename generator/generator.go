package generator

import (
	"fmt"
	"strings"

	"github.com/yaroher/protoc-gen-go-plain/goplain"
	"github.com/yaroher/protoc-gen-go-plain/logger"
	"go.uber.org/zap"
	"google.golang.org/protobuf/compiler/protogen"
)

type Generator struct {
	Settings *PluginSettings
	Plugin   *protogen.Plugin
	suffix   string

	overrides []*goplain.TypeOverride
}

type Option func(*Generator) error

func WithPlainSuffix(suffix string) Option {
	return func(g *Generator) error {
		g.suffix = suffix
		return nil
	}
}

func WithTypeOverrides(overrides []*goplain.TypeOverride) Option {
	return func(g *Generator) error {
		g.overrides = overrides
		return nil
	}
}

func NewGenerator(p *protogen.Plugin, opts ...Option) (*Generator, error) {
	settings, err := NewPluginSettingsFromPlugin(p)
	if err != nil {
		return nil, err
	}
	g := &Generator{
		Settings: settings,
		Plugin:   p,
		suffix:   "Plain",
	}
	for _, opt := range opts {
		if opt == nil {
			continue
		}
		if err := opt(g); err != nil {
			return nil, err
		}
	}
	return g, nil
}

func (g *Generator) GetOverrides() []*goplain.TypeOverride {
	return g.overrides
}

func (g *Generator) AddOverride(override *goplain.TypeOverride) {
	g.overrides = append(g.overrides, override)
}

func (g *Generator) Generate() error {
	logger.Info("generate start", zap.Int("files", len(g.Plugin.Files)))

	for _, f := range g.Plugin.Files {
		if !f.Generate {
			continue
		}

		logger.Debug("processing file", zap.String("path", f.Desc.Path()))

		// Build IR
		builder := NewIRBuilder(g.suffix)
		builder.GlobalOverrides = g.overrides

		irFile, err := builder.BuildFile(f)
		if err != nil {
			logger.Error("failed to build IR", zap.Error(err), zap.String("file", f.Desc.Path()))
			return fmt.Errorf("failed to build IR for %s: %w", f.Desc.Path(), err)
		}

		// Skip files without plain messages
		if len(irFile.Messages) == 0 {
			logger.Debug("no plain messages to generate", zap.String("file", f.Desc.Path()))
			continue
		}

		// Fail on collisions
		if len(builder.Collisions) > 0 {
			for _, collision := range builder.Collisions {
				logger.Error("field collision detected",
					zap.String("message", collision.Message.Name),
					zap.String("field", collision.FieldName),
					zap.String("existing_origin", collision.ExistingField.Origin.String()),
					zap.String("existing_empath", collision.ExistingField.EmPath),
					zap.String("new_origin", collision.NewField.Origin.String()),
					zap.String("new_empath", collision.NewField.EmPath),
				)
			}
			return fmt.Errorf("field collisions detected in %s: %d collision(s), first: %s",
				f.Desc.Path(), len(builder.Collisions), builder.Collisions[0].Error())
		}

		// Log IR for debugging
		logger.Debug("IR built", zap.String("dump", irFile.Dump()))

		// Generate Go code
		if err := g.generateFile(f, irFile); err != nil {
			return fmt.Errorf("failed to generate %s: %w", f.Desc.Path(), err)
		}
	}

	logger.Info("generate complete")
	return nil
}

func (g *Generator) generateFile(f *protogen.File, irFile *IRFile) error {
	// Create output file with _plain.pb.go suffix
	filename := f.GeneratedFilenamePrefix + "_plain.pb.go"
	gf := g.Plugin.NewGeneratedFile(filename, f.GoImportPath)

	logger.Debug("generating file", zap.String("filename", filename))

	// Write header
	gf.P("// Code generated by protoc-gen-go-plain. DO NOT EDIT.")
	gf.P("// source: ", f.Desc.Path())
	gf.P()
	gf.P("package ", f.GoPackageName)
	gf.P()

	// Generate structs (imports will be added automatically by protogen)
	for _, msg := range irFile.Messages {
		g.generateMessage(gf, msg, f)
	}

	return nil
}

func (g *Generator) generateMessage(gf *protogen.GeneratedFile, msg *IRMessage, f *protogen.File) {
	// Generate comment
	if msg.Comment != "" {
		for _, line := range strings.Split(strings.TrimSpace(msg.Comment), "\n") {
			gf.P("// ", strings.TrimPrefix(line, "// "))
		}
	}

	// Generate struct
	gf.P("type ", msg.GoName, " struct {")

	for _, field := range msg.Fields {
		g.generateField(gf, field, f)
	}

	// Generate oneof case fields
	for _, eo := range msg.EmbeddedOneofs {
		gf.P("\t// ", eo.CaseFieldName, " indicates which variant of ", eo.Name, " oneof is set")
		gf.P("\t", eo.CaseFieldName, " string `json:\"", eo.JSONName, ",omitempty\"`")
	}

	// Generate _src field for sparse serialization (indices of populated fields)
	gf.P("\t// Src_ contains indices of populated fields for sparse serialization")
	gf.P("\tSrc_ []uint16 `json:\"_src,omitempty\"`")

	gf.P("}")
	gf.P()

	// Generate metadata
	g.generateMetadata(gf, msg)

	// Generate conversion methods
	g.generateConversionMethods(gf, msg, f)

	// Generate JSON methods
	if g.Settings.JSONJX {
		g.generateJSONMethods(gf, msg, f)
	}

	// Generate nested messages
	for _, nested := range msg.Nested {
		g.generateMessage(gf, nested, f)
	}
}

// generateMetadata generates metadata variables for a message
func (g *Generator) generateMetadata(gf *protogen.GeneratedFile, msg *IRMessage) {
	// Import runtime package
	runtimePkg := protogen.GoImportPath("github.com/yaroher/protoc-gen-go-plain/runtime")

	// Generate field metadata array
	gf.P("// _", msg.GoName, "_meta contains field metadata (origin, depth, pathIndex)")
	gf.P("var _", msg.GoName, "_meta = [...]", gf.QualifiedGoIdent(runtimePkg.Ident("FieldMeta")), "{")
	for _, field := range msg.Fields {
		meta := g.computeFieldMeta(field, msg)
		gf.P("\t", fmt.Sprintf("0x%04X", meta), ", // ", field.GoName, ": origin=", field.Origin, ", depth=", len(field.PathNumbers), ", pathIdx=", g.getPathIndex(field, msg))
	}
	gf.P("}")
	gf.P()

	// Generate path table
	if len(msg.PathTable) > 0 {
		gf.P("// _", msg.GoName, "_paths contains field number paths for navigation")
		gf.P("var _", msg.GoName, "_paths = [...]uint16{")
		for i := 0; i < len(msg.PathTable); i += 8 {
			end := i + 8
			if end > len(msg.PathTable) {
				end = len(msg.PathTable)
			}
			line := "\t"
			for j := i; j < end; j++ {
				line += fmt.Sprintf("%d, ", msg.PathTable[j])
			}
			gf.P(line)
		}
		gf.P("}")
		gf.P()
	}

	// Generate JSON field names
	gf.P("// _", msg.GoName, "_jsonNames contains JSON field names")
	gf.P("var _", msg.GoName, "_jsonNames = [...]string{")
	for _, field := range msg.Fields {
		gf.P("\t", `"`, field.JSONName, `",`)
	}
	gf.P("}")
	gf.P()

	// Generate PlainTypeInfo variable
	gf.P("// ", msg.GoName, "TypeInfo provides metadata for ", msg.GoName)
	gf.P("var ", msg.GoName, "TypeInfo = ", gf.QualifiedGoIdent(runtimePkg.Ident("PlainTypeInfo")), "{")
	gf.P("\tFields:    _", msg.GoName, "_meta[:],")
	if len(msg.PathTable) > 0 {
		gf.P("\tPaths:     _", msg.GoName, "_paths[:],")
	}
	gf.P("\tJSONNames: _", msg.GoName, "_jsonNames[:],")
	gf.P("}")
	gf.P()
}

// computeFieldMeta computes the uint16 metadata value for a field
func (g *Generator) computeFieldMeta(field *IRField, msg *IRMessage) uint16 {
	var origin uint16
	switch field.Origin {
	case OriginDirect:
		origin = 0
	case OriginEmbed:
		origin = 1
	case OriginOneofEmbed:
		origin = 2
	case OriginVirtual:
		origin = 3
	case OriginSerialized:
		origin = 4
	case OriginTypeAlias:
		origin = 5
	}

	depth := uint16(len(field.PathNumbers))
	if depth > 3 {
		depth = 3
	}

	pathIndex := uint16(g.getPathIndex(field, msg))
	if pathIndex > 2047 {
		pathIndex = 2047
	}

	return (origin << 13) | (depth << 11) | pathIndex
}

// getPathIndex returns the index of field's path in PathTable
func (g *Generator) getPathIndex(field *IRField, msg *IRMessage) int {
	if len(field.PathNumbers) == 0 {
		return 0
	}

	// Find the path in PathTable
	for i := 0; i <= len(msg.PathTable)-len(field.PathNumbers); i++ {
		match := true
		for j, num := range field.PathNumbers {
			if msg.PathTable[i+j] != num {
				match = false
				break
			}
		}
		if match {
			return i
		}
	}
	return 0
}

func (g *Generator) generateField(gf *protogen.GeneratedFile, field *IRField, f *protogen.File) {
	// Build type string using QualifiedGoIdent for proper import handling
	typeStr := g.buildTypeString(gf, field, f)

	// Build JSON tag
	jsonTag := field.JSONName
	if field.IsOptional {
		jsonTag += ",omitempty"
	}

	// Build comment with origin info
	comment := ""
	if field.EmPath != "" {
		comment = fmt.Sprintf(" // origin: %s, empath: %s", field.Origin, field.EmPath)
	}

	gf.P("\t", field.GoName, " ", typeStr, " `json:\"", jsonTag, "\"`", comment)
}

func (g *Generator) buildTypeString(gf *protogen.GeneratedFile, field *IRField, f *protogen.File) string {
	var sb strings.Builder

	if field.IsRepeated && !field.GoType.IsSlice {
		sb.WriteString("[]")
	}

	if field.GoType.IsSlice {
		sb.WriteString("[]")
	}

	if field.GoType.IsPointer {
		sb.WriteString("*")
	}

	// Handle map types
	if field.Kind == KindMap && field.MapKey != nil && field.MapValue != nil {
		sb.WriteString("map[")
		sb.WriteString(g.qualifyType(gf, field.MapKey.GoType, f))
		sb.WriteString("]")
		if field.MapValue.GoType.IsPointer {
			sb.WriteString("*")
		}
		sb.WriteString(g.qualifyType(gf, field.MapValue.GoType, f))
		return sb.String()
	}

	sb.WriteString(g.qualifyType(gf, field.GoType, f))

	return sb.String()
}

// qualifyType returns the qualified type name, using protogen's import system
func (g *Generator) qualifyType(gf *protogen.GeneratedFile, goType GoType, f *protogen.File) string {
	// If no import path or same package, return just the name
	if goType.ImportPath == "" || goType.ImportPath == string(f.GoImportPath) {
		return goType.Name
	}

	// Use QualifiedGoIdent for proper import handling with aliases
	ident := protogen.GoIdent{
		GoName:       goType.Name,
		GoImportPath: protogen.GoImportPath(goType.ImportPath),
	}
	return gf.QualifiedGoIdent(ident)
}
