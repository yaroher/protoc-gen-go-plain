// Code generated by protoc-gen-go-plain. DO NOT EDIT.

package full

import (
	"encoding/json"
	"fmt"
	"github.com/go-faster/jx"
	"github.com/google/uuid"
	"google.golang.org/protobuf/encoding/protojson"
	"google.golang.org/protobuf/types/known/timestamppb"
	"google.golang.org/protobuf/types/known/wrapperspb"
)

func jxEncodeError(field string) error {
	return fmt.Errorf("jx: encode %s", field)
}
func jxDecodeError(field string, err error) error {
	return fmt.Errorf("jx: decode %s: %w", field, err)
}

func (x *BasePlain) MarshalJSON() ([]byte, error) {
	if x == nil {
		return []byte("null"), nil
	}
	e := jx.GetEncoder()
	defer jx.PutEncoder(e)
	if e.ObjStart() {
		return nil, jxEncodeError("BasePlain")
	}
	if e.FieldStart("id") {
		return nil, jxEncodeError("id")
	}
	e.Str(x.Id)
	if e.FieldStart("source") {
		return nil, jxEncodeError("source")
	}
	e.Str(x.Source)
	if e.ObjEnd() {
		return nil, jxEncodeError("BasePlain")
	}
	buf := append([]byte(nil), e.Bytes()...)
	return buf, nil
}

func (x *BasePlain) UnmarshalJSON(data []byte) error {
	if x == nil {
		return fmt.Errorf("jx: nil receiver")
	}
	d := jx.DecodeBytes(data)
	return d.Obj(func(d *jx.Decoder, key string) error {
		switch key {
		case "id":
			val, err := (*jx.Decoder).Str(d)
			if err != nil {
				return jxDecodeError("Id", err)
			}
			x.Id = val
			return nil
		case "source":
			val, err := (*jx.Decoder).Str(d)
			if err != nil {
				return jxDecodeError("Source", err)
			}
			x.Source = val
			return nil
		default:
			return d.Skip()
		}
	})
}

func (x *ComplexPlain) MarshalJSON() ([]byte, error) {
	if x == nil {
		return []byte("null"), nil
	}
	e := jx.GetEncoder()
	defer jx.PutEncoder(e)
	if e.ObjStart() {
		return nil, jxEncodeError("ComplexPlain")
	}
	if e.FieldStart("raw") {
		return nil, jxEncodeError("raw")
	}
	e.Base64(x.Raw)
	if len(x.RawList) > 0 {
		if e.FieldStart("rawList") {
			return nil, jxEncodeError("rawList")
		}
		if e.ArrStart() {
			return nil, jxEncodeError("RawList")
		}
		for _, el := range x.RawList {
			e.Base64(el)
		}
		if e.ArrEnd() {
			return nil, jxEncodeError("RawList")
		}
	}
	if x.Comment != nil {
		if e.FieldStart("comment") {
			return nil, jxEncodeError("comment")
		}
		if x.Comment == nil {
			e.Null()
		} else {
			raw, err := protojson.Marshal(x.Comment)
			if err != nil {
				return nil, jxEncodeError("Comment")
			}
			e.Raw(raw)
		}
	}
	if x.ContactEmail != nil {
		if e.FieldStart("contactEmail") {
			return nil, jxEncodeError("contactEmail")
		}
		if x.ContactEmail == nil {
			e.Null()
		} else {
			e.Str(*x.ContactEmail)
		}
	}
	if len(x.AliasList) > 0 {
		if e.FieldStart("aliasList") {
			return nil, jxEncodeError("aliasList")
		}
		if e.ArrStart() {
			return nil, jxEncodeError("AliasList")
		}
		for _, el := range x.AliasList {
			e.Str(el)
		}
		if e.ArrEnd() {
			return nil, jxEncodeError("AliasList")
		}
	}
	if x.Id != nil {
		if e.FieldStart("id") {
			return nil, jxEncodeError("id")
		}
		if x.Id == nil {
			e.Null()
		} else {
			e.Str(*x.Id)
		}
	}
	if e.FieldStart("idCRF") {
		return nil, jxEncodeError("idCRF")
	}
	e.Str(x.IdCRF)
	if e.FieldStart("tag") {
		return nil, jxEncodeError("tag")
	}
	e.Str(x.Tag)
	if x.CreatedAt != nil {
		if e.FieldStart("createdAt") {
			return nil, jxEncodeError("createdAt")
		}
		if x.CreatedAt == nil {
			e.Null()
		} else {
			raw, err := protojson.Marshal(x.CreatedAt)
			if err != nil {
				return nil, jxEncodeError("CreatedAt")
			}
			e.Raw(raw)
		}
	}
	if e.FieldStart("source") {
		return nil, jxEncodeError("source")
	}
	e.Str(x.Source)
	if x.Note != nil {
		if e.FieldStart("note") {
			return nil, jxEncodeError("note")
		}
		if x.Note == nil {
			e.Null()
		} else {
			e.Str(*x.Note)
		}
	}
	if len(x.Meta) > 0 {
		if e.FieldStart("meta") {
			return nil, jxEncodeError("meta")
		}
		raw, err := json.Marshal(x.Meta)
		if err != nil {
			return nil, jxEncodeError("meta")
		}
		e.Raw(raw)
	}
	if x.ContactPhone != nil {
		if e.FieldStart("contactPhone") {
			return nil, jxEncodeError("contactPhone")
		}
		if x.ContactPhone == nil {
			e.Null()
		} else {
			e.Str(*x.ContactPhone)
		}
	}
	if len(x.StatusList) > 0 {
		if e.FieldStart("statusList") {
			return nil, jxEncodeError("statusList")
		}
		if e.ArrStart() {
			return nil, jxEncodeError("StatusList")
		}
		for _, el := range x.StatusList {
			e.Int32(el)
		}
		if e.ArrEnd() {
			return nil, jxEncodeError("StatusList")
		}
	}
	if e.FieldStart("customId") {
		return nil, jxEncodeError("customId")
	}
	raw, err := json.Marshal(x.CustomId)
	if err != nil {
		return nil, jxEncodeError("customId")
	}
	e.Raw(raw)
	if e.FieldStart("aliasId") {
		return nil, jxEncodeError("aliasId")
	}
	e.Str(x.AliasId)
	if e.FieldStart("name") {
		return nil, jxEncodeError("name")
	}
	e.Str(x.Name)
	if x.Archived != nil {
		if e.FieldStart("archived") {
			return nil, jxEncodeError("archived")
		}
		if x.Archived == nil {
			e.Null()
		} else {
			e.Bool(*x.Archived)
		}
	}
	if len(x.Counters) > 0 {
		if e.FieldStart("counters") {
			return nil, jxEncodeError("counters")
		}
		raw, err := json.Marshal(x.Counters)
		if err != nil {
			return nil, jxEncodeError("counters")
		}
		e.Raw(raw)
	}
	if e.FieldStart("status") {
		return nil, jxEncodeError("status")
	}
	e.Int32(x.Status)
	if e.FieldStart("virtualNote") {
		return nil, jxEncodeError("virtualNote")
	}
	e.Str(x.VirtualNote)
	if len(x.Labels) > 0 {
		if e.FieldStart("labels") {
			return nil, jxEncodeError("labels")
		}
		if e.ArrStart() {
			return nil, jxEncodeError("Labels")
		}
		for _, el := range x.Labels {
			e.Str(el)
		}
		if e.ArrEnd() {
			return nil, jxEncodeError("Labels")
		}
	}
	if e.ObjEnd() {
		return nil, jxEncodeError("ComplexPlain")
	}
	buf := append([]byte(nil), e.Bytes()...)
	return buf, nil
}

func (x *ComplexPlain) UnmarshalJSON(data []byte) error {
	if x == nil {
		return fmt.Errorf("jx: nil receiver")
	}
	d := jx.DecodeBytes(data)
	return d.Obj(func(d *jx.Decoder, key string) error {
		switch key {
		case "raw":
			val, err := (*jx.Decoder).Base64(d)
			if err != nil {
				return jxDecodeError("Raw", err)
			}
			x.Raw = val
			return nil
		case "rawList":
			var outVal [][]byte
			if err := d.Arr(func(d *jx.Decoder) error {
				val, err := (*jx.Decoder).Base64(d)
				if err != nil {
					return err
				}
				outVal = append(outVal, val)
				return nil
			}); err != nil {
				return jxDecodeError("RawList", err)
			}
			x.RawList = outVal
			return nil
		case "comment":
			if d.Next() == jx.Null {
				if err := d.Null(); err != nil {
					return jxDecodeError("Comment", err)
				}
				x.Comment = nil
				return nil
			}
			raw, err := d.Raw()
			if err != nil {
				return jxDecodeError("Comment", err)
			}
			outVal := &wrapperspb.StringValue{}
			if err := protojson.Unmarshal(raw, outVal); err != nil {
				return jxDecodeError("Comment", err)
			}
			x.Comment = outVal
			return nil
		case "contactEmail":
			if d.Next() == jx.Null {
				if err := d.Null(); err != nil {
					return jxDecodeError("ContactEmail", err)
				}
				x.ContactEmail = nil
				return nil
			}
			val, err := (*jx.Decoder).Str(d)
			if err != nil {
				return jxDecodeError("ContactEmail", err)
			}
			x.ContactEmail = &val
			return nil
		case "aliasList":
			var outVal []string
			if err := d.Arr(func(d *jx.Decoder) error {
				val, err := (*jx.Decoder).Str(d)
				if err != nil {
					return err
				}
				outVal = append(outVal, val)
				return nil
			}); err != nil {
				return jxDecodeError("AliasList", err)
			}
			x.AliasList = outVal
			return nil
		case "id":
			if d.Next() == jx.Null {
				if err := d.Null(); err != nil {
					return jxDecodeError("Id", err)
				}
				x.Id = nil
				return nil
			}
			val, err := (*jx.Decoder).Str(d)
			if err != nil {
				return jxDecodeError("Id", err)
			}
			x.Id = &val
			return nil
		case "idCRF":
			val, err := (*jx.Decoder).Str(d)
			if err != nil {
				return jxDecodeError("IdCRF", err)
			}
			x.IdCRF = val
			return nil
		case "tag":
			val, err := (*jx.Decoder).Str(d)
			if err != nil {
				return jxDecodeError("Tag", err)
			}
			x.Tag = val
			return nil
		case "createdAt":
			if d.Next() == jx.Null {
				if err := d.Null(); err != nil {
					return jxDecodeError("CreatedAt", err)
				}
				x.CreatedAt = nil
				return nil
			}
			raw, err := d.Raw()
			if err != nil {
				return jxDecodeError("CreatedAt", err)
			}
			outVal := &timestamppb.Timestamp{}
			if err := protojson.Unmarshal(raw, outVal); err != nil {
				return jxDecodeError("CreatedAt", err)
			}
			x.CreatedAt = outVal
			return nil
		case "source":
			val, err := (*jx.Decoder).Str(d)
			if err != nil {
				return jxDecodeError("Source", err)
			}
			x.Source = val
			return nil
		case "note":
			if d.Next() == jx.Null {
				if err := d.Null(); err != nil {
					return jxDecodeError("Note", err)
				}
				x.Note = nil
				return nil
			}
			val, err := (*jx.Decoder).Str(d)
			if err != nil {
				return jxDecodeError("Note", err)
			}
			x.Note = &val
			return nil
		case "meta":
			raw, err := d.Raw()
			if err != nil {
				return jxDecodeError("Meta", err)
			}
			var outVal map[string]string
			if err := json.Unmarshal(raw, &outVal); err != nil {
				return jxDecodeError("Meta", err)
			}
			x.Meta = outVal
			return nil
		case "contactPhone":
			if d.Next() == jx.Null {
				if err := d.Null(); err != nil {
					return jxDecodeError("ContactPhone", err)
				}
				x.ContactPhone = nil
				return nil
			}
			val, err := (*jx.Decoder).Str(d)
			if err != nil {
				return jxDecodeError("ContactPhone", err)
			}
			x.ContactPhone = &val
			return nil
		case "statusList":
			var outVal []int32
			if err := d.Arr(func(d *jx.Decoder) error {
				val, err := (*jx.Decoder).Int32(d)
				if err != nil {
					return err
				}
				outVal = append(outVal, val)
				return nil
			}); err != nil {
				return jxDecodeError("StatusList", err)
			}
			x.StatusList = outVal
			return nil
		case "customId":
			raw, err := d.Raw()
			if err != nil {
				return jxDecodeError("CustomId", err)
			}
			var outVal uuid.UUID
			if err := json.Unmarshal(raw, &outVal); err != nil {
				return jxDecodeError("CustomId", err)
			}
			x.CustomId = outVal
			return nil
		case "aliasId":
			val, err := (*jx.Decoder).Str(d)
			if err != nil {
				return jxDecodeError("AliasId", err)
			}
			x.AliasId = val
			return nil
		case "name":
			val, err := (*jx.Decoder).Str(d)
			if err != nil {
				return jxDecodeError("Name", err)
			}
			x.Name = val
			return nil
		case "archived":
			if d.Next() == jx.Null {
				if err := d.Null(); err != nil {
					return jxDecodeError("Archived", err)
				}
				x.Archived = nil
				return nil
			}
			val, err := (*jx.Decoder).Bool(d)
			if err != nil {
				return jxDecodeError("Archived", err)
			}
			x.Archived = &val
			return nil
		case "counters":
			raw, err := d.Raw()
			if err != nil {
				return jxDecodeError("Counters", err)
			}
			var outVal map[string]int32
			if err := json.Unmarshal(raw, &outVal); err != nil {
				return jxDecodeError("Counters", err)
			}
			x.Counters = outVal
			return nil
		case "status":
			val, err := (*jx.Decoder).Int32(d)
			if err != nil {
				return jxDecodeError("Status", err)
			}
			x.Status = val
			return nil
		case "virtualNote":
			val, err := (*jx.Decoder).Str(d)
			if err != nil {
				return jxDecodeError("VirtualNote", err)
			}
			x.VirtualNote = val
			return nil
		case "labels":
			var outVal []string
			if err := d.Arr(func(d *jx.Decoder) error {
				val, err := (*jx.Decoder).Str(d)
				if err != nil {
					return err
				}
				outVal = append(outVal, val)
				return nil
			}); err != nil {
				return jxDecodeError("Labels", err)
			}
			x.Labels = outVal
			return nil
		default:
			return d.Skip()
		}
	})
}

func (x *ExtraPlain) MarshalJSON() ([]byte, error) {
	if x == nil {
		return []byte("null"), nil
	}
	e := jx.GetEncoder()
	defer jx.PutEncoder(e)
	if e.ObjStart() {
		return nil, jxEncodeError("ExtraPlain")
	}
	if e.FieldStart("id") {
		return nil, jxEncodeError("id")
	}
	e.Str(x.Id)
	if e.FieldStart("tag") {
		return nil, jxEncodeError("tag")
	}
	e.Str(x.Tag)
	if e.ObjEnd() {
		return nil, jxEncodeError("ExtraPlain")
	}
	buf := append([]byte(nil), e.Bytes()...)
	return buf, nil
}

func (x *ExtraPlain) UnmarshalJSON(data []byte) error {
	if x == nil {
		return fmt.Errorf("jx: nil receiver")
	}
	d := jx.DecodeBytes(data)
	return d.Obj(func(d *jx.Decoder, key string) error {
		switch key {
		case "id":
			val, err := (*jx.Decoder).Str(d)
			if err != nil {
				return jxDecodeError("Id", err)
			}
			x.Id = val
			return nil
		case "tag":
			val, err := (*jx.Decoder).Str(d)
			if err != nil {
				return jxDecodeError("Tag", err)
			}
			x.Tag = val
			return nil
		default:
			return d.Skip()
		}
	})
}
