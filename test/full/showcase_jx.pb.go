// Code generated by protoc-gen-go-plain. DO NOT EDIT.
// source: test/full/showcase.proto

package full

import (
	fmt "fmt"
	jx "github.com/go-faster/jx"
	protojson "google.golang.org/protobuf/encoding/protojson"
	anypb "google.golang.org/protobuf/types/known/anypb"
	durationpb "google.golang.org/protobuf/types/known/durationpb"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
	structpb "google.golang.org/protobuf/types/known/structpb"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
	wrapperspb "google.golang.org/protobuf/types/known/wrapperspb"
	strconv "strconv"
)

// MarshalJX encodes StringValue to JSON using jx.Encoder
func (p *StringValue) MarshalJX(e *jx.Encoder) {
	if p == nil {
		e.Null()
		return
	}

	e.ObjStart()
	if p.GetValue() != "" {
		e.FieldStart("value")
		e.Str(p.GetValue())
	}
	e.ObjEnd()
}

// UnmarshalJX decodes StringValue from JSON using jx.Decoder
func (p *StringValue) UnmarshalJX(d *jx.Decoder) error {
	if p == nil {
		return nil
	}

	return d.Obj(func(d *jx.Decoder, key string) error {
		switch key {
		case "value":
			v, err := d.Str()
			if err != nil {
				return err
			}
			p.Value = v
		default:
			return d.Skip()
		}
		return nil
	})
}

// MarshalJX encodes Int64Value to JSON using jx.Encoder
func (p *Int64Value) MarshalJX(e *jx.Encoder) {
	if p == nil {
		e.Null()
		return
	}

	e.ObjStart()
	if p.GetValue() != 0 {
		e.FieldStart("value")
		e.Int64(p.GetValue())
	}
	e.ObjEnd()
}

// UnmarshalJX decodes Int64Value from JSON using jx.Decoder
func (p *Int64Value) UnmarshalJX(d *jx.Decoder) error {
	if p == nil {
		return nil
	}

	return d.Obj(func(d *jx.Decoder, key string) error {
		switch key {
		case "value":
			v, err := d.Int64()
			if err != nil {
				return err
			}
			p.Value = v
		default:
			return d.Skip()
		}
		return nil
	})
}

// MarshalJX encodes BoolValue to JSON using jx.Encoder
func (p *BoolValue) MarshalJX(e *jx.Encoder) {
	if p == nil {
		e.Null()
		return
	}

	e.ObjStart()
	if p.GetValue() {
		e.FieldStart("value")
		e.Bool(p.GetValue())
	}
	e.ObjEnd()
}

// UnmarshalJX decodes BoolValue from JSON using jx.Decoder
func (p *BoolValue) UnmarshalJX(d *jx.Decoder) error {
	if p == nil {
		return nil
	}

	return d.Obj(func(d *jx.Decoder, key string) error {
		switch key {
		case "value":
			v, err := d.Bool()
			if err != nil {
				return err
			}
			p.Value = v
		default:
			return d.Skip()
		}
		return nil
	})
}

// MarshalJX encodes Address to JSON using jx.Encoder
func (p *Address) MarshalJX(e *jx.Encoder) {
	if p == nil {
		e.Null()
		return
	}

	e.ObjStart()
	if p.GetStreet() != "" {
		e.FieldStart("street")
		e.Str(p.GetStreet())
	}
	if p.GetCity() != "" {
		e.FieldStart("city")
		e.Str(p.GetCity())
	}
	if p.GetCountry() != "" {
		e.FieldStart("country")
		e.Str(p.GetCountry())
	}
	if p.GetPostalCode() != "" {
		e.FieldStart("postalCode")
		e.Str(p.GetPostalCode())
	}
	e.ObjEnd()
}

// UnmarshalJX decodes Address from JSON using jx.Decoder
func (p *Address) UnmarshalJX(d *jx.Decoder) error {
	if p == nil {
		return nil
	}

	return d.Obj(func(d *jx.Decoder, key string) error {
		switch key {
		case "street":
			v, err := d.Str()
			if err != nil {
				return err
			}
			p.Street = v
		case "city":
			v, err := d.Str()
			if err != nil {
				return err
			}
			p.City = v
		case "country":
			v, err := d.Str()
			if err != nil {
				return err
			}
			p.Country = v
		case "postalCode":
			v, err := d.Str()
			if err != nil {
				return err
			}
			p.PostalCode = v
		default:
			return d.Skip()
		}
		return nil
	})
}

// MarshalJX encodes ContactInfo to JSON using jx.Encoder
func (p *ContactInfo) MarshalJX(e *jx.Encoder) {
	if p == nil {
		e.Null()
		return
	}

	e.ObjStart()
	if p.GetEmail() != "" {
		e.FieldStart("email")
		e.Str(p.GetEmail())
	}
	if p.GetPhone() != "" {
		e.FieldStart("phone")
		e.Str(p.GetPhone())
	}
	if p.GetAddress() != nil {
		e.FieldStart("address")
		p.GetAddress().MarshalJX(e)
	}
	e.ObjEnd()
}

// UnmarshalJX decodes ContactInfo from JSON using jx.Decoder
func (p *ContactInfo) UnmarshalJX(d *jx.Decoder) error {
	if p == nil {
		return nil
	}

	return d.Obj(func(d *jx.Decoder, key string) error {
		switch key {
		case "email":
			v, err := d.Str()
			if err != nil {
				return err
			}
			p.Email = v
		case "phone":
			v, err := d.Str()
			if err != nil {
				return err
			}
			p.Phone = v
		case "address":
			p.Address = &Address{}
			if err := p.Address.UnmarshalJX(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// MarshalJX encodes Metadata to JSON using jx.Encoder
func (p *Metadata) MarshalJX(e *jx.Encoder) {
	if p == nil {
		e.Null()
		return
	}

	e.ObjStart()
	if p.GetCreatedBy() != "" {
		e.FieldStart("createdBy")
		e.Str(p.GetCreatedBy())
	}
	if p.GetCreatedAt() != 0 {
		e.FieldStart("createdAt")
		e.Int64(p.GetCreatedAt())
	}
	if p.GetModifiedBy() != "" {
		e.FieldStart("modifiedBy")
		e.Str(p.GetModifiedBy())
	}
	if p.GetModifiedAt() != 0 {
		e.FieldStart("modifiedAt")
		e.Int64(p.GetModifiedAt())
	}
	if len(p.GetLabels()) > 0 {
		e.FieldStart("labels")
		e.ObjStart()
		for k, v := range p.GetLabels() {
			e.FieldStart(k)
			e.Str(v)
		}
		e.ObjEnd()
	}
	if len(p.GetTags()) > 0 {
		e.FieldStart("tags")
		e.ArrStart()
		for _, v := range p.GetTags() {
			e.Str(v)
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

// UnmarshalJX decodes Metadata from JSON using jx.Decoder
func (p *Metadata) UnmarshalJX(d *jx.Decoder) error {
	if p == nil {
		return nil
	}

	return d.Obj(func(d *jx.Decoder, key string) error {
		switch key {
		case "createdBy":
			v, err := d.Str()
			if err != nil {
				return err
			}
			p.CreatedBy = v
		case "createdAt":
			v, err := d.Int64()
			if err != nil {
				return err
			}
			p.CreatedAt = v
		case "modifiedBy":
			v, err := d.Str()
			if err != nil {
				return err
			}
			p.ModifiedBy = v
		case "modifiedAt":
			v, err := d.Int64()
			if err != nil {
				return err
			}
			p.ModifiedAt = v
		case "labels":
			if p.Labels == nil {
				p.Labels = make(map[string]string)
			}
			return d.Obj(func(d *jx.Decoder, key string) error {
				v, err := d.Str()
				if err != nil {
					return err
				}
				p.Labels[key] = v
				return nil
			})
		case "tags":
			return d.Arr(func(d *jx.Decoder) error {
				v, err := d.Str()
				if err != nil {
					return err
				}
				p.Tags = append(p.Tags, v)
				return nil
			})
		default:
			return d.Skip()
		}
		return nil
	})
}

// MarshalJX encodes Level5 to JSON using jx.Encoder
func (p *Level5) MarshalJX(e *jx.Encoder) {
	if p == nil {
		e.Null()
		return
	}

	e.ObjStart()
	if p.GetLeafValue() != "" {
		e.FieldStart("leafValue")
		e.Str(p.GetLeafValue())
	}
	if p.GetLeafNumber() != 0 {
		e.FieldStart("leafNumber")
		e.Int32(p.GetLeafNumber())
	}
	if len(p.GetLeafData()) > 0 {
		e.FieldStart("leafData")
		e.Base64(p.GetLeafData())
	}
	e.ObjEnd()
}

// UnmarshalJX decodes Level5 from JSON using jx.Decoder
func (p *Level5) UnmarshalJX(d *jx.Decoder) error {
	if p == nil {
		return nil
	}

	return d.Obj(func(d *jx.Decoder, key string) error {
		switch key {
		case "leafValue":
			v, err := d.Str()
			if err != nil {
				return err
			}
			p.LeafValue = v
		case "leafNumber":
			v, err := d.Int32()
			if err != nil {
				return err
			}
			p.LeafNumber = v
		case "leafData":
			v, err := d.Base64()
			if err != nil {
				return err
			}
			p.LeafData = v
		default:
			return d.Skip()
		}
		return nil
	})
}

// MarshalJX encodes Level4 to JSON using jx.Encoder
func (p *Level4) MarshalJX(e *jx.Encoder) {
	if p == nil {
		e.Null()
		return
	}

	e.ObjStart()
	if p.GetName() != "" {
		e.FieldStart("name")
		e.Str(p.GetName())
	}
	if p.GetDeep() != nil {
		e.FieldStart("deep")
		p.GetDeep().MarshalJX(e)
	}
	if len(p.GetItems()) > 0 {
		e.FieldStart("items")
		e.ArrStart()
		for _, v := range p.GetItems() {
			v.MarshalJX(e)
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

// UnmarshalJX decodes Level4 from JSON using jx.Decoder
func (p *Level4) UnmarshalJX(d *jx.Decoder) error {
	if p == nil {
		return nil
	}

	return d.Obj(func(d *jx.Decoder, key string) error {
		switch key {
		case "name":
			v, err := d.Str()
			if err != nil {
				return err
			}
			p.Name = v
		case "deep":
			p.Deep = &Level5{}
			if err := p.Deep.UnmarshalJX(d); err != nil {
				return err
			}
		case "items":
			return d.Arr(func(d *jx.Decoder) error {
				v := &Level5{}
				if err := v.UnmarshalJX(d); err != nil {
					return err
				}
				p.Items = append(p.Items, v)
				return nil
			})
		default:
			return d.Skip()
		}
		return nil
	})
}

// MarshalJX encodes Level3 to JSON using jx.Encoder
func (p *Level3) MarshalJX(e *jx.Encoder) {
	if p == nil {
		e.Null()
		return
	}

	e.ObjStart()
	if p.GetIdentifier() != "" {
		e.FieldStart("identifier")
		e.Str(p.GetIdentifier())
	}
	if p.GetNested() != nil {
		e.FieldStart("nested")
		p.GetNested().MarshalJX(e)
	}
	if len(p.GetChildren()) > 0 {
		e.FieldStart("children")
		e.ObjStart()
		for k, v := range p.GetChildren() {
			e.FieldStart(k)
			v.MarshalJX(e)
		}
		e.ObjEnd()
	}
	e.ObjEnd()
}

// UnmarshalJX decodes Level3 from JSON using jx.Decoder
func (p *Level3) UnmarshalJX(d *jx.Decoder) error {
	if p == nil {
		return nil
	}

	return d.Obj(func(d *jx.Decoder, key string) error {
		switch key {
		case "identifier":
			v, err := d.Str()
			if err != nil {
				return err
			}
			p.Identifier = v
		case "nested":
			p.Nested = &Level4{}
			if err := p.Nested.UnmarshalJX(d); err != nil {
				return err
			}
		case "children":
			if p.Children == nil {
				p.Children = make(map[string]*Level4)
			}
			return d.Obj(func(d *jx.Decoder, key string) error {
				v := &Level4{}
				if err := v.UnmarshalJX(d); err != nil {
					return err
				}
				p.Children[key] = v
				return nil
			})
		default:
			return d.Skip()
		}
		return nil
	})
}

// MarshalJX encodes Level2 to JSON using jx.Encoder
func (p *Level2) MarshalJX(e *jx.Encoder) {
	if p == nil {
		e.Null()
		return
	}

	e.ObjStart()
	if p.GetLabel() != "" {
		e.FieldStart("label")
		e.Str(p.GetLabel())
	}
	if p.GetContent() != nil {
		e.FieldStart("content")
		p.GetContent().MarshalJX(e)
	}
	if len(p.GetSections()) > 0 {
		e.FieldStart("sections")
		e.ArrStart()
		for _, v := range p.GetSections() {
			v.MarshalJX(e)
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

// UnmarshalJX decodes Level2 from JSON using jx.Decoder
func (p *Level2) UnmarshalJX(d *jx.Decoder) error {
	if p == nil {
		return nil
	}

	return d.Obj(func(d *jx.Decoder, key string) error {
		switch key {
		case "label":
			v, err := d.Str()
			if err != nil {
				return err
			}
			p.Label = v
		case "content":
			p.Content = &Level3{}
			if err := p.Content.UnmarshalJX(d); err != nil {
				return err
			}
		case "sections":
			return d.Arr(func(d *jx.Decoder) error {
				v := &Level3{}
				if err := v.UnmarshalJX(d); err != nil {
					return err
				}
				p.Sections = append(p.Sections, v)
				return nil
			})
		default:
			return d.Skip()
		}
		return nil
	})
}

// MarshalJX encodes Level1 to JSON using jx.Encoder
func (p *Level1) MarshalJX(e *jx.Encoder) {
	if p == nil {
		e.Null()
		return
	}

	e.ObjStart()
	if p.GetTitle() != "" {
		e.FieldStart("title")
		e.Str(p.GetTitle())
	}
	if p.GetBody() != nil {
		e.FieldStart("body")
		p.GetBody().MarshalJX(e)
	}
	if p.GetMeta() != nil {
		e.FieldStart("meta")
		p.GetMeta().MarshalJX(e)
	}
	e.ObjEnd()
}

// UnmarshalJX decodes Level1 from JSON using jx.Decoder
func (p *Level1) UnmarshalJX(d *jx.Decoder) error {
	if p == nil {
		return nil
	}

	return d.Obj(func(d *jx.Decoder, key string) error {
		switch key {
		case "title":
			v, err := d.Str()
			if err != nil {
				return err
			}
			p.Title = v
		case "body":
			p.Body = &Level2{}
			if err := p.Body.UnmarshalJX(d); err != nil {
				return err
			}
		case "meta":
			p.Meta = &Metadata{}
			if err := p.Meta.UnmarshalJX(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// MarshalJX encodes Metrics to JSON using jx.Encoder
func (p *Metrics) MarshalJX(e *jx.Encoder) {
	if p == nil {
		e.Null()
		return
	}

	e.ObjStart()
	if p.GetDurationNs() != 0 {
		e.FieldStart("durationNs")
		e.Int64(p.GetDurationNs())
	}
	if p.GetTimestampUnix() != 0 {
		e.FieldStart("timestampUnix")
		e.Int64(p.GetTimestampUnix())
	}
	if p.GetBytesProcessed() != 0 {
		e.FieldStart("bytesProcessed")
		e.Int64(p.GetBytesProcessed())
	}
	if p.GetRequestsCount() != 0 {
		e.FieldStart("requestsCount")
		e.Int32(p.GetRequestsCount())
	}
	if p.GetSuccessRate() != 0 {
		e.FieldStart("successRate")
		e.Float64(p.GetSuccessRate())
	}
	e.ObjEnd()
}

// UnmarshalJX decodes Metrics from JSON using jx.Decoder
func (p *Metrics) UnmarshalJX(d *jx.Decoder) error {
	if p == nil {
		return nil
	}

	return d.Obj(func(d *jx.Decoder, key string) error {
		switch key {
		case "durationNs":
			v, err := d.Int64()
			if err != nil {
				return err
			}
			p.DurationNs = v
		case "timestampUnix":
			v, err := d.Int64()
			if err != nil {
				return err
			}
			p.TimestampUnix = v
		case "bytesProcessed":
			v, err := d.Int64()
			if err != nil {
				return err
			}
			p.BytesProcessed = v
		case "requestsCount":
			v, err := d.Int32()
			if err != nil {
				return err
			}
			p.RequestsCount = v
		case "successRate":
			v, err := d.Float64()
			if err != nil {
				return err
			}
			p.SuccessRate = v
		default:
			return d.Skip()
		}
		return nil
	})
}

// MarshalJX encodes MyString to JSON using jx.Encoder
func (p *MyString) MarshalJX(e *jx.Encoder) {
	if p == nil {
		e.Null()
		return
	}

	e.ObjStart()
	if p.GetValue() != "" {
		e.FieldStart("value")
		e.Str(p.GetValue())
	}
	e.ObjEnd()
}

// UnmarshalJX decodes MyString from JSON using jx.Decoder
func (p *MyString) UnmarshalJX(d *jx.Decoder) error {
	if p == nil {
		return nil
	}

	return d.Obj(func(d *jx.Decoder, key string) error {
		switch key {
		case "value":
			v, err := d.Str()
			if err != nil {
				return err
			}
			p.Value = v
		default:
			return d.Skip()
		}
		return nil
	})
}

// MarshalJX encodes CustomTypes to JSON using jx.Encoder
func (p *CustomTypes) MarshalJX(e *jx.Encoder) {
	if p == nil {
		e.Null()
		return
	}

	e.ObjStart()
	if len(p.GetRawJson()) > 0 {
		e.FieldStart("rawJson")
		e.Base64(p.GetRawJson())
	}
	if p.GetName() != "" {
		e.FieldStart("name")
		e.Str(p.GetName())
	}
	if p.GetCount() != 0 {
		e.FieldStart("count")
		e.Int64(p.GetCount())
	}
	if p.GetLabel() != nil {
		e.FieldStart("label")
		p.GetLabel().MarshalJX(e)
	}
	e.ObjEnd()
}

// UnmarshalJX decodes CustomTypes from JSON using jx.Decoder
func (p *CustomTypes) UnmarshalJX(d *jx.Decoder) error {
	if p == nil {
		return nil
	}

	return d.Obj(func(d *jx.Decoder, key string) error {
		switch key {
		case "rawJson":
			v, err := d.Base64()
			if err != nil {
				return err
			}
			p.RawJson = v
		case "name":
			v, err := d.Str()
			if err != nil {
				return err
			}
			p.Name = v
		case "count":
			v, err := d.Int64()
			if err != nil {
				return err
			}
			p.Count = v
		case "label":
			p.Label = &MyString{}
			if err := p.Label.UnmarshalJX(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// MarshalJX encodes TextContent to JSON using jx.Encoder
func (p *TextContent) MarshalJX(e *jx.Encoder) {
	if p == nil {
		e.Null()
		return
	}

	e.ObjStart()
	if p.GetText() != "" {
		e.FieldStart("text")
		e.Str(p.GetText())
	}
	if p.GetFormat() != "" {
		e.FieldStart("format")
		e.Str(p.GetFormat())
	}
	e.ObjEnd()
}

// UnmarshalJX decodes TextContent from JSON using jx.Decoder
func (p *TextContent) UnmarshalJX(d *jx.Decoder) error {
	if p == nil {
		return nil
	}

	return d.Obj(func(d *jx.Decoder, key string) error {
		switch key {
		case "text":
			v, err := d.Str()
			if err != nil {
				return err
			}
			p.Text = v
		case "format":
			v, err := d.Str()
			if err != nil {
				return err
			}
			p.Format = v
		default:
			return d.Skip()
		}
		return nil
	})
}

// MarshalJX encodes ImageContent to JSON using jx.Encoder
func (p *ImageContent) MarshalJX(e *jx.Encoder) {
	if p == nil {
		e.Null()
		return
	}

	e.ObjStart()
	if p.GetUrl() != "" {
		e.FieldStart("url")
		e.Str(p.GetUrl())
	}
	if p.GetWidth() != 0 {
		e.FieldStart("width")
		e.Int32(p.GetWidth())
	}
	if p.GetHeight() != 0 {
		e.FieldStart("height")
		e.Int32(p.GetHeight())
	}
	if p.GetAltText() != "" {
		e.FieldStart("altText")
		e.Str(p.GetAltText())
	}
	e.ObjEnd()
}

// UnmarshalJX decodes ImageContent from JSON using jx.Decoder
func (p *ImageContent) UnmarshalJX(d *jx.Decoder) error {
	if p == nil {
		return nil
	}

	return d.Obj(func(d *jx.Decoder, key string) error {
		switch key {
		case "url":
			v, err := d.Str()
			if err != nil {
				return err
			}
			p.Url = v
		case "width":
			v, err := d.Int32()
			if err != nil {
				return err
			}
			p.Width = v
		case "height":
			v, err := d.Int32()
			if err != nil {
				return err
			}
			p.Height = v
		case "altText":
			v, err := d.Str()
			if err != nil {
				return err
			}
			p.AltText = v
		default:
			return d.Skip()
		}
		return nil
	})
}

// MarshalJX encodes VideoContent to JSON using jx.Encoder
func (p *VideoContent) MarshalJX(e *jx.Encoder) {
	if p == nil {
		e.Null()
		return
	}

	e.ObjStart()
	if p.GetUrl() != "" {
		e.FieldStart("url")
		e.Str(p.GetUrl())
	}
	if p.GetDurationSeconds() != 0 {
		e.FieldStart("durationSeconds")
		e.Int32(p.GetDurationSeconds())
	}
	if p.GetThumbnailUrl() != "" {
		e.FieldStart("thumbnailUrl")
		e.Str(p.GetThumbnailUrl())
	}
	e.ObjEnd()
}

// UnmarshalJX decodes VideoContent from JSON using jx.Decoder
func (p *VideoContent) UnmarshalJX(d *jx.Decoder) error {
	if p == nil {
		return nil
	}

	return d.Obj(func(d *jx.Decoder, key string) error {
		switch key {
		case "url":
			v, err := d.Str()
			if err != nil {
				return err
			}
			p.Url = v
		case "durationSeconds":
			v, err := d.Int32()
			if err != nil {
				return err
			}
			p.DurationSeconds = v
		case "thumbnailUrl":
			v, err := d.Str()
			if err != nil {
				return err
			}
			p.ThumbnailUrl = v
		default:
			return d.Skip()
		}
		return nil
	})
}

// MarshalJX encodes CodeContent to JSON using jx.Encoder
func (p *CodeContent) MarshalJX(e *jx.Encoder) {
	if p == nil {
		e.Null()
		return
	}

	e.ObjStart()
	if p.GetCode() != "" {
		e.FieldStart("code")
		e.Str(p.GetCode())
	}
	if p.GetLanguage() != "" {
		e.FieldStart("language")
		e.Str(p.GetLanguage())
	}
	if p.GetHighlighted() {
		e.FieldStart("highlighted")
		e.Bool(p.GetHighlighted())
	}
	e.ObjEnd()
}

// UnmarshalJX decodes CodeContent from JSON using jx.Decoder
func (p *CodeContent) UnmarshalJX(d *jx.Decoder) error {
	if p == nil {
		return nil
	}

	return d.Obj(func(d *jx.Decoder, key string) error {
		switch key {
		case "code":
			v, err := d.Str()
			if err != nil {
				return err
			}
			p.Code = v
		case "language":
			v, err := d.Str()
			if err != nil {
				return err
			}
			p.Language = v
		case "highlighted":
			v, err := d.Bool()
			if err != nil {
				return err
			}
			p.Highlighted = v
		default:
			return d.Skip()
		}
		return nil
	})
}

// MarshalJX encodes TableContent to JSON using jx.Encoder
func (p *TableContent) MarshalJX(e *jx.Encoder) {
	if p == nil {
		e.Null()
		return
	}

	e.ObjStart()
	if len(p.GetHeaders()) > 0 {
		e.FieldStart("headers")
		e.ArrStart()
		for _, v := range p.GetHeaders() {
			e.Str(v)
		}
		e.ArrEnd()
	}
	if len(p.GetRows()) > 0 {
		e.FieldStart("rows")
		e.ArrStart()
		for _, v := range p.GetRows() {
			e.Str(v)
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

// UnmarshalJX decodes TableContent from JSON using jx.Decoder
func (p *TableContent) UnmarshalJX(d *jx.Decoder) error {
	if p == nil {
		return nil
	}

	return d.Obj(func(d *jx.Decoder, key string) error {
		switch key {
		case "headers":
			return d.Arr(func(d *jx.Decoder) error {
				v, err := d.Str()
				if err != nil {
					return err
				}
				p.Headers = append(p.Headers, v)
				return nil
			})
		case "rows":
			return d.Arr(func(d *jx.Decoder) error {
				v, err := d.Str()
				if err != nil {
					return err
				}
				p.Rows = append(p.Rows, v)
				return nil
			})
		default:
			return d.Skip()
		}
		return nil
	})
}

// MarshalJX encodes Document to JSON using jx.Encoder
func (p *Document) MarshalJX(e *jx.Encoder) {
	if p == nil {
		e.Null()
		return
	}

	e.ObjStart()
	if p.GetId() != "" {
		e.FieldStart("id")
		e.Str(p.GetId())
	}
	if p.GetTitle() != "" {
		e.FieldStart("title")
		e.Str(p.GetTitle())
	}
	e.FieldStart("status")
	e.Int32(int32(p.GetStatus()))
	e.FieldStart("priority")
	e.Int32(int32(p.GetPriority()))
	if p.GetDescription() != nil {
		e.FieldStart("description")
		p.GetDescription().MarshalJX(e)
	}
	if p.GetVersion() != nil {
		e.FieldStart("version")
		p.GetVersion().MarshalJX(e)
	}
	if p.GetIsPublic() != nil {
		e.FieldStart("isPublic")
		p.GetIsPublic().MarshalJX(e)
	}
	if p.GetAuthor() != nil {
		e.FieldStart("author")
		p.GetAuthor().MarshalJX(e)
	}
	if p.GetMetadata() != nil {
		e.FieldStart("metadata")
		p.GetMetadata().MarshalJX(e)
	}
	if p.GetPerformance() != nil {
		e.FieldStart("performance")
		p.GetPerformance().MarshalJX(e)
	}
	if len(p.GetKeywords()) > 0 {
		e.FieldStart("keywords")
		e.ArrStart()
		for _, v := range p.GetKeywords() {
			e.Str(v)
		}
		e.ArrEnd()
	}
	if len(p.GetAttributes()) > 0 {
		e.FieldStart("attributes")
		e.ObjStart()
		for k, v := range p.GetAttributes() {
			e.FieldStart(k)
			e.Str(v)
		}
		e.ObjEnd()
	}
	if len(p.GetLocations()) > 0 {
		e.FieldStart("locations")
		e.ArrStart()
		for _, v := range p.GetLocations() {
			v.MarshalJX(e)
		}
		e.ArrEnd()
	}
	if p.GetStructure() != nil {
		e.FieldStart("structure")
		p.GetStructure().MarshalJX(e)
	}
	if len(p.GetChildren()) > 0 {
		e.FieldStart("children")
		e.ArrStart()
		for _, v := range p.GetChildren() {
			v.MarshalJX(e)
		}
		e.ArrEnd()
	}
	if p.GetParent() != nil {
		e.FieldStart("parent")
		p.GetParent().MarshalJX(e)
	}
	switch v := p.GetContent().(type) {
	case *Document_TextContent:
		e.FieldStart("textContent")
		v.TextContent.MarshalJX(e)
	case *Document_ImageContent:
		e.FieldStart("imageContent")
		v.ImageContent.MarshalJX(e)
	case *Document_VideoContent:
		e.FieldStart("videoContent")
		v.VideoContent.MarshalJX(e)
	case *Document_CodeContent:
		e.FieldStart("codeContent")
		v.CodeContent.MarshalJX(e)
	case *Document_TableContent:
		e.FieldStart("tableContent")
		v.TableContent.MarshalJX(e)
	}
	switch v := p.GetSource().(type) {
	case *Document_Url:
		e.FieldStart("url")
		e.Str(v.Url)
	case *Document_FilePath:
		e.FieldStart("filePath")
		e.Str(v.FilePath)
	case *Document_RawData:
		e.FieldStart("rawData")
		e.Base64(v.RawData)
	}
	e.ObjEnd()
}

// UnmarshalJX decodes Document from JSON using jx.Decoder
func (p *Document) UnmarshalJX(d *jx.Decoder) error {
	if p == nil {
		return nil
	}

	return d.Obj(func(d *jx.Decoder, key string) error {
		switch key {
		case "id":
			v, err := d.Str()
			if err != nil {
				return err
			}
			p.Id = v
		case "title":
			v, err := d.Str()
			if err != nil {
				return err
			}
			p.Title = v
		case "status":
			v, err := d.Int32()
			if err != nil {
				return err
			}
			p.Status = Status(v)
		case "priority":
			v, err := d.Int32()
			if err != nil {
				return err
			}
			p.Priority = Priority(v)
		case "description":
			p.Description = &StringValue{}
			if err := p.Description.UnmarshalJX(d); err != nil {
				return err
			}
		case "version":
			p.Version = &Int64Value{}
			if err := p.Version.UnmarshalJX(d); err != nil {
				return err
			}
		case "isPublic":
			p.IsPublic = &BoolValue{}
			if err := p.IsPublic.UnmarshalJX(d); err != nil {
				return err
			}
		case "author":
			p.Author = &ContactInfo{}
			if err := p.Author.UnmarshalJX(d); err != nil {
				return err
			}
		case "metadata":
			p.Metadata = &Metadata{}
			if err := p.Metadata.UnmarshalJX(d); err != nil {
				return err
			}
		case "performance":
			p.Performance = &Metrics{}
			if err := p.Performance.UnmarshalJX(d); err != nil {
				return err
			}
		case "keywords":
			return d.Arr(func(d *jx.Decoder) error {
				v, err := d.Str()
				if err != nil {
					return err
				}
				p.Keywords = append(p.Keywords, v)
				return nil
			})
		case "attributes":
			if p.Attributes == nil {
				p.Attributes = make(map[string]string)
			}
			return d.Obj(func(d *jx.Decoder, key string) error {
				v, err := d.Str()
				if err != nil {
					return err
				}
				p.Attributes[key] = v
				return nil
			})
		case "locations":
			return d.Arr(func(d *jx.Decoder) error {
				v := &Address{}
				if err := v.UnmarshalJX(d); err != nil {
					return err
				}
				p.Locations = append(p.Locations, v)
				return nil
			})
		case "structure":
			p.Structure = &Level1{}
			if err := p.Structure.UnmarshalJX(d); err != nil {
				return err
			}
		case "children":
			return d.Arr(func(d *jx.Decoder) error {
				v := &Document{}
				if err := v.UnmarshalJX(d); err != nil {
					return err
				}
				p.Children = append(p.Children, v)
				return nil
			})
		case "parent":
			p.Parent = &Document{}
			if err := p.Parent.UnmarshalJX(d); err != nil {
				return err
			}
		case "textContent":
			v := &TextContent{}
			if err := v.UnmarshalJX(d); err != nil {
				return err
			}
			p.Content = &Document_TextContent{TextContent: v}
		case "imageContent":
			v := &ImageContent{}
			if err := v.UnmarshalJX(d); err != nil {
				return err
			}
			p.Content = &Document_ImageContent{ImageContent: v}
		case "videoContent":
			v := &VideoContent{}
			if err := v.UnmarshalJX(d); err != nil {
				return err
			}
			p.Content = &Document_VideoContent{VideoContent: v}
		case "codeContent":
			v := &CodeContent{}
			if err := v.UnmarshalJX(d); err != nil {
				return err
			}
			p.Content = &Document_CodeContent{CodeContent: v}
		case "tableContent":
			v := &TableContent{}
			if err := v.UnmarshalJX(d); err != nil {
				return err
			}
			p.Content = &Document_TableContent{TableContent: v}
		case "url":
			v, err := d.Str()
			if err != nil {
				return err
			}
			p.Source = &Document_Url{Url: v}
		case "filePath":
			v, err := d.Str()
			if err != nil {
				return err
			}
			p.Source = &Document_FilePath{FilePath: v}
		case "rawData":
			return d.Skip()
		default:
			return d.Skip()
		}
		return nil
	})
}

// MarshalJX encodes TreeNode to JSON using jx.Encoder
func (p *TreeNode) MarshalJX(e *jx.Encoder) {
	if p == nil {
		e.Null()
		return
	}

	e.ObjStart()
	if p.GetId() != "" {
		e.FieldStart("id")
		e.Str(p.GetId())
	}
	if p.GetName() != "" {
		e.FieldStart("name")
		e.Str(p.GetName())
	}
	if p.GetType() != "" {
		e.FieldStart("type")
		e.Str(p.GetType())
	}
	if len(p.GetChildren()) > 0 {
		e.FieldStart("children")
		e.ArrStart()
		for _, v := range p.GetChildren() {
			v.MarshalJX(e)
		}
		e.ArrEnd()
	}
	if p.GetParent() != nil {
		e.FieldStart("parent")
		p.GetParent().MarshalJX(e)
	}
	if p.GetInfo() != nil {
		e.FieldStart("info")
		p.GetInfo().MarshalJX(e)
	}
	switch v := p.GetPayload().(type) {
	case *TreeNode_Text:
		e.FieldStart("text")
		v.Text.MarshalJX(e)
	case *TreeNode_Image:
		e.FieldStart("image")
		v.Image.MarshalJX(e)
	case *TreeNode_Code:
		e.FieldStart("code")
		v.Code.MarshalJX(e)
	}
	e.ObjEnd()
}

// UnmarshalJX decodes TreeNode from JSON using jx.Decoder
func (p *TreeNode) UnmarshalJX(d *jx.Decoder) error {
	if p == nil {
		return nil
	}

	return d.Obj(func(d *jx.Decoder, key string) error {
		switch key {
		case "id":
			v, err := d.Str()
			if err != nil {
				return err
			}
			p.Id = v
		case "name":
			v, err := d.Str()
			if err != nil {
				return err
			}
			p.Name = v
		case "type":
			v, err := d.Str()
			if err != nil {
				return err
			}
			p.Type = v
		case "children":
			return d.Arr(func(d *jx.Decoder) error {
				v := &TreeNode{}
				if err := v.UnmarshalJX(d); err != nil {
					return err
				}
				p.Children = append(p.Children, v)
				return nil
			})
		case "parent":
			p.Parent = &TreeNode{}
			if err := p.Parent.UnmarshalJX(d); err != nil {
				return err
			}
		case "info":
			p.Info = &Metadata{}
			if err := p.Info.UnmarshalJX(d); err != nil {
				return err
			}
		case "text":
			v := &TextContent{}
			if err := v.UnmarshalJX(d); err != nil {
				return err
			}
			p.Payload = &TreeNode_Text{Text: v}
		case "image":
			v := &ImageContent{}
			if err := v.UnmarshalJX(d); err != nil {
				return err
			}
			p.Payload = &TreeNode_Image{Image: v}
		case "code":
			v := &CodeContent{}
			if err := v.UnmarshalJX(d); err != nil {
				return err
			}
			p.Payload = &TreeNode_Code{Code: v}
		default:
			return d.Skip()
		}
		return nil
	})
}

// MarshalJX encodes UserCreatedEvent to JSON using jx.Encoder
func (p *UserCreatedEvent) MarshalJX(e *jx.Encoder) {
	if p == nil {
		e.Null()
		return
	}

	e.ObjStart()
	if p.GetUserId() != "" {
		e.FieldStart("userId")
		e.Str(p.GetUserId())
	}
	if p.GetUsername() != "" {
		e.FieldStart("username")
		e.Str(p.GetUsername())
	}
	if p.GetEmail() != "" {
		e.FieldStart("email")
		e.Str(p.GetEmail())
	}
	e.ObjEnd()
}

// UnmarshalJX decodes UserCreatedEvent from JSON using jx.Decoder
func (p *UserCreatedEvent) UnmarshalJX(d *jx.Decoder) error {
	if p == nil {
		return nil
	}

	return d.Obj(func(d *jx.Decoder, key string) error {
		switch key {
		case "userId":
			v, err := d.Str()
			if err != nil {
				return err
			}
			p.UserId = v
		case "username":
			v, err := d.Str()
			if err != nil {
				return err
			}
			p.Username = v
		case "email":
			v, err := d.Str()
			if err != nil {
				return err
			}
			p.Email = v
		default:
			return d.Skip()
		}
		return nil
	})
}

// MarshalJX encodes UserUpdatedEvent to JSON using jx.Encoder
func (p *UserUpdatedEvent) MarshalJX(e *jx.Encoder) {
	if p == nil {
		e.Null()
		return
	}

	e.ObjStart()
	if p.GetUserId() != "" {
		e.FieldStart("userId")
		e.Str(p.GetUserId())
	}
	if len(p.GetChanges()) > 0 {
		e.FieldStart("changes")
		e.ObjStart()
		for k, v := range p.GetChanges() {
			e.FieldStart(k)
			e.Str(v)
		}
		e.ObjEnd()
	}
	e.ObjEnd()
}

// UnmarshalJX decodes UserUpdatedEvent from JSON using jx.Decoder
func (p *UserUpdatedEvent) UnmarshalJX(d *jx.Decoder) error {
	if p == nil {
		return nil
	}

	return d.Obj(func(d *jx.Decoder, key string) error {
		switch key {
		case "userId":
			v, err := d.Str()
			if err != nil {
				return err
			}
			p.UserId = v
		case "changes":
			if p.Changes == nil {
				p.Changes = make(map[string]string)
			}
			return d.Obj(func(d *jx.Decoder, key string) error {
				v, err := d.Str()
				if err != nil {
					return err
				}
				p.Changes[key] = v
				return nil
			})
		default:
			return d.Skip()
		}
		return nil
	})
}

// MarshalJX encodes UserDeletedEvent to JSON using jx.Encoder
func (p *UserDeletedEvent) MarshalJX(e *jx.Encoder) {
	if p == nil {
		e.Null()
		return
	}

	e.ObjStart()
	if p.GetUserId() != "" {
		e.FieldStart("userId")
		e.Str(p.GetUserId())
	}
	if p.GetReason() != "" {
		e.FieldStart("reason")
		e.Str(p.GetReason())
	}
	e.ObjEnd()
}

// UnmarshalJX decodes UserDeletedEvent from JSON using jx.Decoder
func (p *UserDeletedEvent) UnmarshalJX(d *jx.Decoder) error {
	if p == nil {
		return nil
	}

	return d.Obj(func(d *jx.Decoder, key string) error {
		switch key {
		case "userId":
			v, err := d.Str()
			if err != nil {
				return err
			}
			p.UserId = v
		case "reason":
			v, err := d.Str()
			if err != nil {
				return err
			}
			p.Reason = v
		default:
			return d.Skip()
		}
		return nil
	})
}

// MarshalJX encodes OrderCreatedEvent to JSON using jx.Encoder
func (p *OrderCreatedEvent) MarshalJX(e *jx.Encoder) {
	if p == nil {
		e.Null()
		return
	}

	e.ObjStart()
	if p.GetOrderId() != "" {
		e.FieldStart("orderId")
		e.Str(p.GetOrderId())
	}
	if p.GetUserId() != "" {
		e.FieldStart("userId")
		e.Str(p.GetUserId())
	}
	if len(p.GetItemIds()) > 0 {
		e.FieldStart("itemIds")
		e.ArrStart()
		for _, v := range p.GetItemIds() {
			e.Str(v)
		}
		e.ArrEnd()
	}
	if p.GetTotalAmount() != 0 {
		e.FieldStart("totalAmount")
		e.Float64(p.GetTotalAmount())
	}
	e.ObjEnd()
}

// UnmarshalJX decodes OrderCreatedEvent from JSON using jx.Decoder
func (p *OrderCreatedEvent) UnmarshalJX(d *jx.Decoder) error {
	if p == nil {
		return nil
	}

	return d.Obj(func(d *jx.Decoder, key string) error {
		switch key {
		case "orderId":
			v, err := d.Str()
			if err != nil {
				return err
			}
			p.OrderId = v
		case "userId":
			v, err := d.Str()
			if err != nil {
				return err
			}
			p.UserId = v
		case "itemIds":
			return d.Arr(func(d *jx.Decoder) error {
				v, err := d.Str()
				if err != nil {
					return err
				}
				p.ItemIds = append(p.ItemIds, v)
				return nil
			})
		case "totalAmount":
			v, err := d.Float64()
			if err != nil {
				return err
			}
			p.TotalAmount = v
		default:
			return d.Skip()
		}
		return nil
	})
}

// MarshalJX encodes OrderCompletedEvent to JSON using jx.Encoder
func (p *OrderCompletedEvent) MarshalJX(e *jx.Encoder) {
	if p == nil {
		e.Null()
		return
	}

	e.ObjStart()
	if p.GetOrderId() != "" {
		e.FieldStart("orderId")
		e.Str(p.GetOrderId())
	}
	if p.GetCompletedAt() != 0 {
		e.FieldStart("completedAt")
		e.Int64(p.GetCompletedAt())
	}
	e.ObjEnd()
}

// UnmarshalJX decodes OrderCompletedEvent from JSON using jx.Decoder
func (p *OrderCompletedEvent) UnmarshalJX(d *jx.Decoder) error {
	if p == nil {
		return nil
	}

	return d.Obj(func(d *jx.Decoder, key string) error {
		switch key {
		case "orderId":
			v, err := d.Str()
			if err != nil {
				return err
			}
			p.OrderId = v
		case "completedAt":
			v, err := d.Int64()
			if err != nil {
				return err
			}
			p.CompletedAt = v
		default:
			return d.Skip()
		}
		return nil
	})
}

// MarshalJX encodes Event to JSON using jx.Encoder
func (p *Event) MarshalJX(e *jx.Encoder) {
	if p == nil {
		e.Null()
		return
	}

	e.ObjStart()
	if p.GetEventId() != "" {
		e.FieldStart("eventId")
		e.Str(p.GetEventId())
	}
	if p.GetEventType() != "" {
		e.FieldStart("eventType")
		e.Str(p.GetEventType())
	}
	if p.GetTimestamp() != 0 {
		e.FieldStart("timestamp")
		e.Int64(p.GetTimestamp())
	}
	if p.GetSource() != "" {
		e.FieldStart("source")
		e.Str(p.GetSource())
	}
	if p.GetMeta() != nil {
		e.FieldStart("meta")
		p.GetMeta().MarshalJX(e)
	}
	switch v := p.GetPayload().(type) {
	case *Event_UserCreated:
		e.FieldStart("userCreated")
		v.UserCreated.MarshalJX(e)
	case *Event_UserUpdated:
		e.FieldStart("userUpdated")
		v.UserUpdated.MarshalJX(e)
	case *Event_UserDeleted:
		e.FieldStart("userDeleted")
		v.UserDeleted.MarshalJX(e)
	case *Event_OrderCreated:
		e.FieldStart("orderCreated")
		v.OrderCreated.MarshalJX(e)
	case *Event_OrderCompleted:
		e.FieldStart("orderCompleted")
		v.OrderCompleted.MarshalJX(e)
	}
	e.ObjEnd()
}

// UnmarshalJX decodes Event from JSON using jx.Decoder
func (p *Event) UnmarshalJX(d *jx.Decoder) error {
	if p == nil {
		return nil
	}

	return d.Obj(func(d *jx.Decoder, key string) error {
		switch key {
		case "eventId":
			v, err := d.Str()
			if err != nil {
				return err
			}
			p.EventId = v
		case "eventType":
			v, err := d.Str()
			if err != nil {
				return err
			}
			p.EventType = v
		case "timestamp":
			v, err := d.Int64()
			if err != nil {
				return err
			}
			p.Timestamp = v
		case "source":
			v, err := d.Str()
			if err != nil {
				return err
			}
			p.Source = v
		case "meta":
			p.Meta = &Metadata{}
			if err := p.Meta.UnmarshalJX(d); err != nil {
				return err
			}
		case "userCreated":
			v := &UserCreatedEvent{}
			if err := v.UnmarshalJX(d); err != nil {
				return err
			}
			p.Payload = &Event_UserCreated{UserCreated: v}
		case "userUpdated":
			v := &UserUpdatedEvent{}
			if err := v.UnmarshalJX(d); err != nil {
				return err
			}
			p.Payload = &Event_UserUpdated{UserUpdated: v}
		case "userDeleted":
			v := &UserDeletedEvent{}
			if err := v.UnmarshalJX(d); err != nil {
				return err
			}
			p.Payload = &Event_UserDeleted{UserDeleted: v}
		case "orderCreated":
			v := &OrderCreatedEvent{}
			if err := v.UnmarshalJX(d); err != nil {
				return err
			}
			p.Payload = &Event_OrderCreated{OrderCreated: v}
		case "orderCompleted":
			v := &OrderCompletedEvent{}
			if err := v.UnmarshalJX(d); err != nil {
				return err
			}
			p.Payload = &Event_OrderCompleted{OrderCompleted: v}
		default:
			return d.Skip()
		}
		return nil
	})
}

// MarshalJX encodes Config to JSON using jx.Encoder
func (p *Config) MarshalJX(e *jx.Encoder) {
	if p == nil {
		e.Null()
		return
	}

	e.ObjStart()
	if p.GetDoubleVal() != 0 {
		e.FieldStart("doubleVal")
		e.Float64(p.GetDoubleVal())
	}
	if p.GetFloatVal() != 0 {
		e.FieldStart("floatVal")
		e.Float32(p.GetFloatVal())
	}
	if p.GetInt32Val() != 0 {
		e.FieldStart("int32Val")
		e.Int32(p.GetInt32Val())
	}
	if p.GetInt64Val() != 0 {
		e.FieldStart("int64Val")
		e.Int64(p.GetInt64Val())
	}
	if p.GetUint32Val() != 0 {
		e.FieldStart("uint32Val")
		e.UInt32(p.GetUint32Val())
	}
	if p.GetUint64Val() != 0 {
		e.FieldStart("uint64Val")
		e.UInt64(p.GetUint64Val())
	}
	if p.GetSint32Val() != 0 {
		e.FieldStart("sint32Val")
		e.Int32(p.GetSint32Val())
	}
	if p.GetSint64Val() != 0 {
		e.FieldStart("sint64Val")
		e.Int64(p.GetSint64Val())
	}
	if p.GetFixed32Val() != 0 {
		e.FieldStart("fixed32Val")
		e.UInt32(p.GetFixed32Val())
	}
	if p.GetFixed64Val() != 0 {
		e.FieldStart("fixed64Val")
		e.UInt64(p.GetFixed64Val())
	}
	if p.GetSfixed32Val() != 0 {
		e.FieldStart("sfixed32Val")
		e.Int32(p.GetSfixed32Val())
	}
	if p.GetSfixed64Val() != 0 {
		e.FieldStart("sfixed64Val")
		e.Int64(p.GetSfixed64Val())
	}
	if p.GetBoolVal() {
		e.FieldStart("boolVal")
		e.Bool(p.GetBoolVal())
	}
	if p.GetStringVal() != "" {
		e.FieldStart("stringVal")
		e.Str(p.GetStringVal())
	}
	if len(p.GetBytesVal()) > 0 {
		e.FieldStart("bytesVal")
		e.Base64(p.GetBytesVal())
	}
	if p.OptionalString != nil {
		e.FieldStart("optionalString")
		e.Str(*p.OptionalString)
	}
	if p.OptionalInt != nil {
		e.FieldStart("optionalInt")
		e.Int32(*p.OptionalInt)
	}
	if p.OptionalBool != nil {
		e.FieldStart("optionalBool")
		e.Bool(*p.OptionalBool)
	}
	if p.OptionalDouble != nil {
		e.FieldStart("optionalDouble")
		e.Float64(*p.OptionalDouble)
	}
	if len(p.OptionalBytes) > 0 {
		e.FieldStart("optionalBytes")
		e.Base64(p.OptionalBytes)
	}
	if len(p.GetStringList()) > 0 {
		e.FieldStart("stringList")
		e.ArrStart()
		for _, v := range p.GetStringList() {
			e.Str(v)
		}
		e.ArrEnd()
	}
	if len(p.GetIntList()) > 0 {
		e.FieldStart("intList")
		e.ArrStart()
		for _, v := range p.GetIntList() {
			e.Int32(v)
		}
		e.ArrEnd()
	}
	if len(p.GetDoubleList()) > 0 {
		e.FieldStart("doubleList")
		e.ArrStart()
		for _, v := range p.GetDoubleList() {
			e.Float64(v)
		}
		e.ArrEnd()
	}
	if len(p.GetBytesList()) > 0 {
		e.FieldStart("bytesList")
		e.ArrStart()
		for _, v := range p.GetBytesList() {
			e.Base64(v)
		}
		e.ArrEnd()
	}
	if len(p.GetBoolList()) > 0 {
		e.FieldStart("boolList")
		e.ArrStart()
		for _, v := range p.GetBoolList() {
			e.Bool(v)
		}
		e.ArrEnd()
	}
	if len(p.GetFloatList()) > 0 {
		e.FieldStart("floatList")
		e.ArrStart()
		for _, v := range p.GetFloatList() {
			e.Float32(v)
		}
		e.ArrEnd()
	}
	if len(p.GetInt64List()) > 0 {
		e.FieldStart("int64List")
		e.ArrStart()
		for _, v := range p.GetInt64List() {
			e.Int64(v)
		}
		e.ArrEnd()
	}
	if len(p.GetUint32List()) > 0 {
		e.FieldStart("uint32List")
		e.ArrStart()
		for _, v := range p.GetUint32List() {
			e.UInt32(v)
		}
		e.ArrEnd()
	}
	if len(p.GetUint64List()) > 0 {
		e.FieldStart("uint64List")
		e.ArrStart()
		for _, v := range p.GetUint64List() {
			e.UInt64(v)
		}
		e.ArrEnd()
	}
	if len(p.GetStringMap()) > 0 {
		e.FieldStart("stringMap")
		e.ObjStart()
		for k, v := range p.GetStringMap() {
			e.FieldStart(k)
			e.Str(v)
		}
		e.ObjEnd()
	}
	if len(p.GetIntMap()) > 0 {
		e.FieldStart("intMap")
		e.ObjStart()
		for k, v := range p.GetIntMap() {
			e.FieldStart(k)
			e.Int32(v)
		}
		e.ObjEnd()
	}
	if len(p.GetIntKeyMap()) > 0 {
		e.FieldStart("intKeyMap")
		e.ObjStart()
		for k, v := range p.GetIntKeyMap() {
			e.FieldStart(fmt.Sprint(k))
			e.Str(v)
		}
		e.ObjEnd()
	}
	if len(p.GetNestedMap()) > 0 {
		e.FieldStart("nestedMap")
		e.ObjStart()
		for k, v := range p.GetNestedMap() {
			e.FieldStart(k)
			v.MarshalJX(e)
		}
		e.ObjEnd()
	}
	if len(p.GetInt64KeyMap()) > 0 {
		e.FieldStart("int64KeyMap")
		e.ObjStart()
		for k, v := range p.GetInt64KeyMap() {
			e.FieldStart(fmt.Sprint(k))
			e.Str(v)
		}
		e.ObjEnd()
	}
	if len(p.GetUint32KeyMap()) > 0 {
		e.FieldStart("uint32KeyMap")
		e.ObjStart()
		for k, v := range p.GetUint32KeyMap() {
			e.FieldStart(fmt.Sprint(k))
			e.Str(v)
		}
		e.ObjEnd()
	}
	if len(p.GetUint64KeyMap()) > 0 {
		e.FieldStart("uint64KeyMap")
		e.ObjStart()
		for k, v := range p.GetUint64KeyMap() {
			e.FieldStart(fmt.Sprint(k))
			e.Str(v)
		}
		e.ObjEnd()
	}
	if len(p.GetSint32KeyMap()) > 0 {
		e.FieldStart("sint32KeyMap")
		e.ObjStart()
		for k, v := range p.GetSint32KeyMap() {
			e.FieldStart(fmt.Sprint(k))
			e.Str(v)
		}
		e.ObjEnd()
	}
	if len(p.GetSint64KeyMap()) > 0 {
		e.FieldStart("sint64KeyMap")
		e.ObjStart()
		for k, v := range p.GetSint64KeyMap() {
			e.FieldStart(fmt.Sprint(k))
			e.Str(v)
		}
		e.ObjEnd()
	}
	if len(p.GetFixed32KeyMap()) > 0 {
		e.FieldStart("fixed32KeyMap")
		e.ObjStart()
		for k, v := range p.GetFixed32KeyMap() {
			e.FieldStart(fmt.Sprint(k))
			e.Str(v)
		}
		e.ObjEnd()
	}
	if len(p.GetFixed64KeyMap()) > 0 {
		e.FieldStart("fixed64KeyMap")
		e.ObjStart()
		for k, v := range p.GetFixed64KeyMap() {
			e.FieldStart(fmt.Sprint(k))
			e.Str(v)
		}
		e.ObjEnd()
	}
	if len(p.GetSfixed32KeyMap()) > 0 {
		e.FieldStart("sfixed32KeyMap")
		e.ObjStart()
		for k, v := range p.GetSfixed32KeyMap() {
			e.FieldStart(fmt.Sprint(k))
			e.Str(v)
		}
		e.ObjEnd()
	}
	if len(p.GetSfixed64KeyMap()) > 0 {
		e.FieldStart("sfixed64KeyMap")
		e.ObjStart()
		for k, v := range p.GetSfixed64KeyMap() {
			e.FieldStart(fmt.Sprint(k))
			e.Str(v)
		}
		e.ObjEnd()
	}
	if len(p.GetBoolKeyMap()) > 0 {
		e.FieldStart("boolKeyMap")
		e.ObjStart()
		for k, v := range p.GetBoolKeyMap() {
			e.FieldStart(fmt.Sprint(k))
			e.Str(v)
		}
		e.ObjEnd()
	}
	if len(p.GetDoubleMap()) > 0 {
		e.FieldStart("doubleMap")
		e.ObjStart()
		for k, v := range p.GetDoubleMap() {
			e.FieldStart(k)
			e.Float64(v)
		}
		e.ObjEnd()
	}
	if len(p.GetBytesMap()) > 0 {
		e.FieldStart("bytesMap")
		e.ObjStart()
		for k, v := range p.GetBytesMap() {
			e.FieldStart(k)
			e.Base64(v)
		}
		e.ObjEnd()
	}
	if len(p.GetBoolMap()) > 0 {
		e.FieldStart("boolMap")
		e.ObjStart()
		for k, v := range p.GetBoolMap() {
			e.FieldStart(k)
			e.Bool(v)
		}
		e.ObjEnd()
	}
	if len(p.GetFloatMap()) > 0 {
		e.FieldStart("floatMap")
		e.ObjStart()
		for k, v := range p.GetFloatMap() {
			e.FieldStart(k)
			e.Float32(v)
		}
		e.ObjEnd()
	}
	e.FieldStart("status")
	e.Int32(int32(p.GetStatus()))
	if len(p.GetStatusList()) > 0 {
		e.FieldStart("statusList")
		e.ArrStart()
		for _, v := range p.GetStatusList() {
			e.Int32(int32(v))
		}
		e.ArrEnd()
	}
	if len(p.GetStatusMap()) > 0 {
		e.FieldStart("statusMap")
		e.ObjStart()
		for k, v := range p.GetStatusMap() {
			e.FieldStart(k)
			e.Int32(int32(v))
		}
		e.ObjEnd()
	}
	if p.OptionalStatus != nil {
		e.FieldStart("optionalStatus")
		e.Int32(int32(*p.OptionalStatus))
	}
	e.FieldStart("nestedEnum")
	e.Int32(int32(p.GetNestedEnum()))
	if len(p.GetNestedEnumList()) > 0 {
		e.FieldStart("nestedEnumList")
		e.ArrStart()
		for _, v := range p.GetNestedEnumList() {
			e.Int32(int32(v))
		}
		e.ArrEnd()
	}
	if p.GetNestedConfig() != nil {
		e.FieldStart("nestedConfig")
		p.GetNestedConfig().MarshalJX(e)
	}
	if len(p.GetNestedConfigList()) > 0 {
		e.FieldStart("nestedConfigList")
		e.ArrStart()
		for _, v := range p.GetNestedConfigList() {
			v.MarshalJX(e)
		}
		e.ArrEnd()
	}
	if len(p.GetNestedConfigMap()) > 0 {
		e.FieldStart("nestedConfigMap")
		e.ObjStart()
		for k, v := range p.GetNestedConfigMap() {
			e.FieldStart(k)
			v.MarshalJX(e)
		}
		e.ObjEnd()
	}
	if p.GetParent() != nil {
		e.FieldStart("parent")
		p.GetParent().MarshalJX(e)
	}
	if len(p.GetChildren()) > 0 {
		e.FieldStart("children")
		e.ArrStart()
		for _, v := range p.GetChildren() {
			v.MarshalJX(e)
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

// UnmarshalJX decodes Config from JSON using jx.Decoder
func (p *Config) UnmarshalJX(d *jx.Decoder) error {
	if p == nil {
		return nil
	}

	return d.Obj(func(d *jx.Decoder, key string) error {
		switch key {
		case "doubleVal":
			v, err := d.Float64()
			if err != nil {
				return err
			}
			p.DoubleVal = v
		case "floatVal":
			v, err := d.Float32()
			if err != nil {
				return err
			}
			p.FloatVal = v
		case "int32Val":
			v, err := d.Int32()
			if err != nil {
				return err
			}
			p.Int32Val = v
		case "int64Val":
			v, err := d.Int64()
			if err != nil {
				return err
			}
			p.Int64Val = v
		case "uint32Val":
			v, err := d.UInt32()
			if err != nil {
				return err
			}
			p.Uint32Val = v
		case "uint64Val":
			v, err := d.UInt64()
			if err != nil {
				return err
			}
			p.Uint64Val = v
		case "sint32Val":
			v, err := d.Int32()
			if err != nil {
				return err
			}
			p.Sint32Val = v
		case "sint64Val":
			v, err := d.Int64()
			if err != nil {
				return err
			}
			p.Sint64Val = v
		case "fixed32Val":
			v, err := d.UInt32()
			if err != nil {
				return err
			}
			p.Fixed32Val = v
		case "fixed64Val":
			v, err := d.UInt64()
			if err != nil {
				return err
			}
			p.Fixed64Val = v
		case "sfixed32Val":
			v, err := d.Int32()
			if err != nil {
				return err
			}
			p.Sfixed32Val = v
		case "sfixed64Val":
			v, err := d.Int64()
			if err != nil {
				return err
			}
			p.Sfixed64Val = v
		case "boolVal":
			v, err := d.Bool()
			if err != nil {
				return err
			}
			p.BoolVal = v
		case "stringVal":
			v, err := d.Str()
			if err != nil {
				return err
			}
			p.StringVal = v
		case "bytesVal":
			v, err := d.Base64()
			if err != nil {
				return err
			}
			p.BytesVal = v
		case "optionalString":
			v, err := d.Str()
			if err != nil {
				return err
			}
			p.OptionalString = &v
		case "optionalInt":
			v, err := d.Int32()
			if err != nil {
				return err
			}
			p.OptionalInt = &v
		case "optionalBool":
			v, err := d.Bool()
			if err != nil {
				return err
			}
			p.OptionalBool = &v
		case "optionalDouble":
			v, err := d.Float64()
			if err != nil {
				return err
			}
			p.OptionalDouble = &v
		case "optionalBytes":
			v, err := d.Base64()
			if err != nil {
				return err
			}
			p.OptionalBytes = v
		case "stringList":
			return d.Arr(func(d *jx.Decoder) error {
				v, err := d.Str()
				if err != nil {
					return err
				}
				p.StringList = append(p.StringList, v)
				return nil
			})
		case "intList":
			return d.Arr(func(d *jx.Decoder) error {
				v, err := d.Int32()
				if err != nil {
					return err
				}
				p.IntList = append(p.IntList, v)
				return nil
			})
		case "doubleList":
			return d.Arr(func(d *jx.Decoder) error {
				v, err := d.Float64()
				if err != nil {
					return err
				}
				p.DoubleList = append(p.DoubleList, v)
				return nil
			})
		case "bytesList":
			return d.Arr(func(d *jx.Decoder) error {
				v, err := d.Base64()
				if err != nil {
					return err
				}
				p.BytesList = append(p.BytesList, v)
				return nil
			})
		case "boolList":
			return d.Arr(func(d *jx.Decoder) error {
				v, err := d.Bool()
				if err != nil {
					return err
				}
				p.BoolList = append(p.BoolList, v)
				return nil
			})
		case "floatList":
			return d.Arr(func(d *jx.Decoder) error {
				v, err := d.Float32()
				if err != nil {
					return err
				}
				p.FloatList = append(p.FloatList, v)
				return nil
			})
		case "int64List":
			return d.Arr(func(d *jx.Decoder) error {
				v, err := d.Int64()
				if err != nil {
					return err
				}
				p.Int64List = append(p.Int64List, v)
				return nil
			})
		case "uint32List":
			return d.Arr(func(d *jx.Decoder) error {
				v, err := d.UInt32()
				if err != nil {
					return err
				}
				p.Uint32List = append(p.Uint32List, v)
				return nil
			})
		case "uint64List":
			return d.Arr(func(d *jx.Decoder) error {
				v, err := d.UInt64()
				if err != nil {
					return err
				}
				p.Uint64List = append(p.Uint64List, v)
				return nil
			})
		case "stringMap":
			if p.StringMap == nil {
				p.StringMap = make(map[string]string)
			}
			return d.Obj(func(d *jx.Decoder, key string) error {
				v, err := d.Str()
				if err != nil {
					return err
				}
				p.StringMap[key] = v
				return nil
			})
		case "intMap":
			if p.IntMap == nil {
				p.IntMap = make(map[string]int32)
			}
			return d.Obj(func(d *jx.Decoder, key string) error {
				v, err := d.Int32()
				if err != nil {
					return err
				}
				p.IntMap[key] = v
				return nil
			})
		case "intKeyMap":
			if p.IntKeyMap == nil {
				p.IntKeyMap = make(map[int32]string)
			}
			return d.Obj(func(d *jx.Decoder, key string) error {
				keyInt, err := strconv.ParseInt(key, 10, 32)
				if err != nil {
					return err
				}
				v, err := d.Str()
				if err != nil {
					return err
				}
				p.IntKeyMap[int32(keyInt)] = v
				return nil
			})
		case "nestedMap":
			if p.NestedMap == nil {
				p.NestedMap = make(map[string]*Config)
			}
			return d.Obj(func(d *jx.Decoder, key string) error {
				v := &Config{}
				if err := v.UnmarshalJX(d); err != nil {
					return err
				}
				p.NestedMap[key] = v
				return nil
			})
		case "int64KeyMap":
			if p.Int64KeyMap == nil {
				p.Int64KeyMap = make(map[int64]string)
			}
			return d.Obj(func(d *jx.Decoder, key string) error {
				keyInt, err := strconv.ParseInt(key, 10, 64)
				if err != nil {
					return err
				}
				v, err := d.Str()
				if err != nil {
					return err
				}
				p.Int64KeyMap[keyInt] = v
				return nil
			})
		case "uint32KeyMap":
			if p.Uint32KeyMap == nil {
				p.Uint32KeyMap = make(map[uint32]string)
			}
			return d.Obj(func(d *jx.Decoder, key string) error {
				keyUint, err := strconv.ParseUint(key, 10, 32)
				if err != nil {
					return err
				}
				v, err := d.Str()
				if err != nil {
					return err
				}
				p.Uint32KeyMap[uint32(keyUint)] = v
				return nil
			})
		case "uint64KeyMap":
			if p.Uint64KeyMap == nil {
				p.Uint64KeyMap = make(map[uint64]string)
			}
			return d.Obj(func(d *jx.Decoder, key string) error {
				keyUint, err := strconv.ParseUint(key, 10, 64)
				if err != nil {
					return err
				}
				v, err := d.Str()
				if err != nil {
					return err
				}
				p.Uint64KeyMap[keyUint] = v
				return nil
			})
		case "sint32KeyMap":
			if p.Sint32KeyMap == nil {
				p.Sint32KeyMap = make(map[int32]string)
			}
			return d.Obj(func(d *jx.Decoder, key string) error {
				keyInt, err := strconv.ParseInt(key, 10, 32)
				if err != nil {
					return err
				}
				v, err := d.Str()
				if err != nil {
					return err
				}
				p.Sint32KeyMap[int32(keyInt)] = v
				return nil
			})
		case "sint64KeyMap":
			if p.Sint64KeyMap == nil {
				p.Sint64KeyMap = make(map[int64]string)
			}
			return d.Obj(func(d *jx.Decoder, key string) error {
				keyInt, err := strconv.ParseInt(key, 10, 64)
				if err != nil {
					return err
				}
				v, err := d.Str()
				if err != nil {
					return err
				}
				p.Sint64KeyMap[keyInt] = v
				return nil
			})
		case "fixed32KeyMap":
			if p.Fixed32KeyMap == nil {
				p.Fixed32KeyMap = make(map[uint32]string)
			}
			return d.Obj(func(d *jx.Decoder, key string) error {
				keyUint, err := strconv.ParseUint(key, 10, 32)
				if err != nil {
					return err
				}
				v, err := d.Str()
				if err != nil {
					return err
				}
				p.Fixed32KeyMap[uint32(keyUint)] = v
				return nil
			})
		case "fixed64KeyMap":
			if p.Fixed64KeyMap == nil {
				p.Fixed64KeyMap = make(map[uint64]string)
			}
			return d.Obj(func(d *jx.Decoder, key string) error {
				keyUint, err := strconv.ParseUint(key, 10, 64)
				if err != nil {
					return err
				}
				v, err := d.Str()
				if err != nil {
					return err
				}
				p.Fixed64KeyMap[keyUint] = v
				return nil
			})
		case "sfixed32KeyMap":
			if p.Sfixed32KeyMap == nil {
				p.Sfixed32KeyMap = make(map[int32]string)
			}
			return d.Obj(func(d *jx.Decoder, key string) error {
				keyInt, err := strconv.ParseInt(key, 10, 32)
				if err != nil {
					return err
				}
				v, err := d.Str()
				if err != nil {
					return err
				}
				p.Sfixed32KeyMap[int32(keyInt)] = v
				return nil
			})
		case "sfixed64KeyMap":
			if p.Sfixed64KeyMap == nil {
				p.Sfixed64KeyMap = make(map[int64]string)
			}
			return d.Obj(func(d *jx.Decoder, key string) error {
				keyInt, err := strconv.ParseInt(key, 10, 64)
				if err != nil {
					return err
				}
				v, err := d.Str()
				if err != nil {
					return err
				}
				p.Sfixed64KeyMap[keyInt] = v
				return nil
			})
		case "boolKeyMap":
			if p.BoolKeyMap == nil {
				p.BoolKeyMap = make(map[bool]string)
			}
			return d.Obj(func(d *jx.Decoder, key string) error {
				keyBool, err := strconv.ParseBool(key)
				if err != nil {
					return err
				}
				v, err := d.Str()
				if err != nil {
					return err
				}
				p.BoolKeyMap[keyBool] = v
				return nil
			})
		case "doubleMap":
			if p.DoubleMap == nil {
				p.DoubleMap = make(map[string]float64)
			}
			return d.Obj(func(d *jx.Decoder, key string) error {
				v, err := d.Float64()
				if err != nil {
					return err
				}
				p.DoubleMap[key] = v
				return nil
			})
		case "bytesMap":
			if p.BytesMap == nil {
				p.BytesMap = make(map[string][]byte)
			}
			return d.Obj(func(d *jx.Decoder, key string) error {
				v, err := d.Base64()
				if err != nil {
					return err
				}
				p.BytesMap[key] = v
				return nil
			})
		case "boolMap":
			if p.BoolMap == nil {
				p.BoolMap = make(map[string]bool)
			}
			return d.Obj(func(d *jx.Decoder, key string) error {
				v, err := d.Bool()
				if err != nil {
					return err
				}
				p.BoolMap[key] = v
				return nil
			})
		case "floatMap":
			if p.FloatMap == nil {
				p.FloatMap = make(map[string]float32)
			}
			return d.Obj(func(d *jx.Decoder, key string) error {
				v, err := d.Float32()
				if err != nil {
					return err
				}
				p.FloatMap[key] = v
				return nil
			})
		case "status":
			v, err := d.Int32()
			if err != nil {
				return err
			}
			p.Status = Status(v)
		case "statusList":
			return d.Arr(func(d *jx.Decoder) error {
				v, err := d.Int32()
				if err != nil {
					return err
				}
				p.StatusList = append(p.StatusList, Status(v))
				return nil
			})
		case "statusMap":
			if p.StatusMap == nil {
				p.StatusMap = make(map[string]Status)
			}
			return d.Obj(func(d *jx.Decoder, key string) error {
				v, err := d.Int32()
				if err != nil {
					return err
				}
				p.StatusMap[key] = Status(v)
				return nil
			})
		case "optionalStatus":
			v, err := d.Int32()
			if err != nil {
				return err
			}
			_ev := Status(v)
			p.OptionalStatus = &_ev
		case "nestedEnum":
			v, err := d.Int32()
			if err != nil {
				return err
			}
			p.NestedEnum = Config_NestedEnum(v)
		case "nestedEnumList":
			return d.Arr(func(d *jx.Decoder) error {
				v, err := d.Int32()
				if err != nil {
					return err
				}
				p.NestedEnumList = append(p.NestedEnumList, Config_NestedEnum(v))
				return nil
			})
		case "nestedConfig":
			p.NestedConfig = &Config_NestedConfig{}
			if err := p.NestedConfig.UnmarshalJX(d); err != nil {
				return err
			}
		case "nestedConfigList":
			return d.Arr(func(d *jx.Decoder) error {
				v := &Config_NestedConfig{}
				if err := v.UnmarshalJX(d); err != nil {
					return err
				}
				p.NestedConfigList = append(p.NestedConfigList, v)
				return nil
			})
		case "nestedConfigMap":
			if p.NestedConfigMap == nil {
				p.NestedConfigMap = make(map[string]*Config_NestedConfig)
			}
			return d.Obj(func(d *jx.Decoder, key string) error {
				v := &Config_NestedConfig{}
				if err := v.UnmarshalJX(d); err != nil {
					return err
				}
				p.NestedConfigMap[key] = v
				return nil
			})
		case "parent":
			p.Parent = &Config{}
			if err := p.Parent.UnmarshalJX(d); err != nil {
				return err
			}
		case "children":
			return d.Arr(func(d *jx.Decoder) error {
				v := &Config{}
				if err := v.UnmarshalJX(d); err != nil {
					return err
				}
				p.Children = append(p.Children, v)
				return nil
			})
		default:
			return d.Skip()
		}
		return nil
	})
}

// MarshalJX encodes Config_NestedConfig to JSON using jx.Encoder
func (p *Config_NestedConfig) MarshalJX(e *jx.Encoder) {
	if p == nil {
		e.Null()
		return
	}

	e.ObjStart()
	if p.GetKey() != "" {
		e.FieldStart("key")
		e.Str(p.GetKey())
	}
	if p.GetValue() != "" {
		e.FieldStart("value")
		e.Str(p.GetValue())
	}
	if p.GetPriority() != 0 {
		e.FieldStart("priority")
		e.Int32(p.GetPriority())
	}
	e.ObjEnd()
}

// UnmarshalJX decodes Config_NestedConfig from JSON using jx.Decoder
func (p *Config_NestedConfig) UnmarshalJX(d *jx.Decoder) error {
	if p == nil {
		return nil
	}

	return d.Obj(func(d *jx.Decoder, key string) error {
		switch key {
		case "key":
			v, err := d.Str()
			if err != nil {
				return err
			}
			p.Key = v
		case "value":
			v, err := d.Str()
			if err != nil {
				return err
			}
			p.Value = v
		case "priority":
			v, err := d.Int32()
			if err != nil {
				return err
			}
			p.Priority = v
		default:
			return d.Skip()
		}
		return nil
	})
}

// MarshalJX encodes WellKnownTypes to JSON using jx.Encoder
func (p *WellKnownTypes) MarshalJX(e *jx.Encoder) {
	if p == nil {
		e.Null()
		return
	}

	e.ObjStart()
	if p.GetCreatedAt() != nil {
		e.FieldStart("createdAt")
		if p.GetCreatedAt() != nil {
			e.Str(p.GetCreatedAt().AsTime().Format("2006-01-02T15:04:05.999999999Z07:00"))
		} else {
			e.Null()
		}
	}
	if p.GetTtl() != nil {
		e.FieldStart("ttl")
		if p.GetTtl() != nil {
			e.Str(p.GetTtl().AsDuration().String())
		} else {
			e.Null()
		}
	}
	if p.GetUpdatedAt() != nil {
		e.FieldStart("updatedAt")
		if p.GetUpdatedAt() != nil {
			e.Str(p.GetUpdatedAt().AsTime().Format("2006-01-02T15:04:05.999999999Z07:00"))
		} else {
			e.Null()
		}
	}
	if p.GetLatency() != nil {
		e.FieldStart("latency")
		if p.GetLatency() != nil {
			e.Str(p.GetLatency().AsDuration().String())
		} else {
			e.Null()
		}
	}
	if p.GetNullableString() != nil {
		e.FieldStart("nullableString")
		if p.GetNullableString() != nil {
			e.Str(p.GetNullableString().GetValue())
		} else {
			e.Null()
		}
	}
	if p.GetNullableInt32() != nil {
		e.FieldStart("nullableInt32")
		if p.GetNullableInt32() != nil {
			if data, err := protojson.Marshal(p.GetNullableInt32()); err == nil {
				e.Raw(data)
			} else {
				e.Null()
			}
		} else {
			e.Null()
		}
	}
	if p.GetNullableInt64() != nil {
		e.FieldStart("nullableInt64")
		if p.GetNullableInt64() != nil {
			if data, err := protojson.Marshal(p.GetNullableInt64()); err == nil {
				e.Raw(data)
			} else {
				e.Null()
			}
		} else {
			e.Null()
		}
	}
	if p.GetNullableUint32() != nil {
		e.FieldStart("nullableUint32")
		if p.GetNullableUint32() != nil {
			if data, err := protojson.Marshal(p.GetNullableUint32()); err == nil {
				e.Raw(data)
			} else {
				e.Null()
			}
		} else {
			e.Null()
		}
	}
	if p.GetNullableUint64() != nil {
		e.FieldStart("nullableUint64")
		if p.GetNullableUint64() != nil {
			if data, err := protojson.Marshal(p.GetNullableUint64()); err == nil {
				e.Raw(data)
			} else {
				e.Null()
			}
		} else {
			e.Null()
		}
	}
	if p.GetNullableFloat() != nil {
		e.FieldStart("nullableFloat")
		if p.GetNullableFloat() != nil {
			if data, err := protojson.Marshal(p.GetNullableFloat()); err == nil {
				e.Raw(data)
			} else {
				e.Null()
			}
		} else {
			e.Null()
		}
	}
	if p.GetNullableDouble() != nil {
		e.FieldStart("nullableDouble")
		if p.GetNullableDouble() != nil {
			if data, err := protojson.Marshal(p.GetNullableDouble()); err == nil {
				e.Raw(data)
			} else {
				e.Null()
			}
		} else {
			e.Null()
		}
	}
	if p.GetNullableBool() != nil {
		e.FieldStart("nullableBool")
		if p.GetNullableBool() != nil {
			e.Bool(p.GetNullableBool().GetValue())
		} else {
			e.Null()
		}
	}
	if p.GetNullableBytes() != nil {
		e.FieldStart("nullableBytes")
		if p.GetNullableBytes() != nil {
			e.Base64(p.GetNullableBytes().GetValue())
		} else {
			e.Null()
		}
	}
	if p.GetMetadata() != nil {
		e.FieldStart("metadata")
		if p.GetMetadata() != nil {
			if data, err := protojson.Marshal(p.GetMetadata()); err == nil {
				e.Raw(data)
			} else {
				e.Null()
			}
		} else {
			e.Null()
		}
	}
	if p.GetDynamicValue() != nil {
		e.FieldStart("dynamicValue")
		if p.GetDynamicValue() != nil {
			if data, err := protojson.Marshal(p.GetDynamicValue()); err == nil {
				e.Raw(data)
			} else {
				e.Null()
			}
		} else {
			e.Null()
		}
	}
	if p.GetListValue() != nil {
		e.FieldStart("listValue")
		if p.GetListValue() != nil {
			if data, err := protojson.Marshal(p.GetListValue()); err == nil {
				e.Raw(data)
			} else {
				e.Null()
			}
		} else {
			e.Null()
		}
	}
	if p.GetPayload() != nil {
		e.FieldStart("payload")
		if p.GetPayload() != nil {
			if data, err := protojson.Marshal(p.GetPayload()); err == nil {
				e.Raw(data)
			} else {
				e.Null()
			}
		} else {
			e.Null()
		}
	}
	if len(p.GetPayloads()) > 0 {
		e.FieldStart("payloads")
		e.ArrStart()
		for _, v := range p.GetPayloads() {
			if v != nil {
				if data, err := protojson.Marshal(v); err == nil {
					e.Raw(data)
				} else {
					e.Null()
				}
			} else {
				e.Null()
			}
		}
		e.ArrEnd()
	}
	if p.GetEmpty() != nil {
		e.FieldStart("empty")
		e.ObjStart()
		e.ObjEnd()
	}
	if len(p.GetTimestamps()) > 0 {
		e.FieldStart("timestamps")
		e.ArrStart()
		for _, v := range p.GetTimestamps() {
			if v != nil {
				e.Str(v.AsTime().Format("2006-01-02T15:04:05.999999999Z07:00"))
			} else {
				e.Null()
			}
		}
		e.ArrEnd()
	}
	if len(p.GetDurations()) > 0 {
		e.FieldStart("durations")
		e.ArrStart()
		for _, v := range p.GetDurations() {
			if v != nil {
				e.Str(v.AsDuration().String())
			} else {
				e.Null()
			}
		}
		e.ArrEnd()
	}
	if len(p.GetStrings()) > 0 {
		e.FieldStart("strings")
		e.ArrStart()
		for _, v := range p.GetStrings() {
			if v != nil {
				e.Str(v.GetValue())
			} else {
				e.Null()
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

// UnmarshalJX decodes WellKnownTypes from JSON using jx.Decoder
func (p *WellKnownTypes) UnmarshalJX(d *jx.Decoder) error {
	if p == nil {
		return nil
	}

	return d.Obj(func(d *jx.Decoder, key string) error {
		switch key {
		case "createdAt":
			raw, err := d.Raw()
			if err != nil {
				return err
			}
			p.CreatedAt = &timestamppb.Timestamp{}
			if err := protojson.Unmarshal(raw, p.CreatedAt); err != nil {
				return err
			}
		case "ttl":
			raw, err := d.Raw()
			if err != nil {
				return err
			}
			p.Ttl = &durationpb.Duration{}
			if err := protojson.Unmarshal(raw, p.Ttl); err != nil {
				return err
			}
		case "updatedAt":
			raw, err := d.Raw()
			if err != nil {
				return err
			}
			p.UpdatedAt = &timestamppb.Timestamp{}
			if err := protojson.Unmarshal(raw, p.UpdatedAt); err != nil {
				return err
			}
		case "latency":
			raw, err := d.Raw()
			if err != nil {
				return err
			}
			p.Latency = &durationpb.Duration{}
			if err := protojson.Unmarshal(raw, p.Latency); err != nil {
				return err
			}
		case "nullableString":
			raw, err := d.Raw()
			if err != nil {
				return err
			}
			p.NullableString = &wrapperspb.StringValue{}
			if err := protojson.Unmarshal(raw, p.NullableString); err != nil {
				return err
			}
		case "nullableInt32":
			raw, err := d.Raw()
			if err != nil {
				return err
			}
			p.NullableInt32 = &wrapperspb.Int32Value{}
			if err := protojson.Unmarshal(raw, p.NullableInt32); err != nil {
				return err
			}
		case "nullableInt64":
			raw, err := d.Raw()
			if err != nil {
				return err
			}
			p.NullableInt64 = &wrapperspb.Int64Value{}
			if err := protojson.Unmarshal(raw, p.NullableInt64); err != nil {
				return err
			}
		case "nullableUint32":
			raw, err := d.Raw()
			if err != nil {
				return err
			}
			p.NullableUint32 = &wrapperspb.UInt32Value{}
			if err := protojson.Unmarshal(raw, p.NullableUint32); err != nil {
				return err
			}
		case "nullableUint64":
			raw, err := d.Raw()
			if err != nil {
				return err
			}
			p.NullableUint64 = &wrapperspb.UInt64Value{}
			if err := protojson.Unmarshal(raw, p.NullableUint64); err != nil {
				return err
			}
		case "nullableFloat":
			raw, err := d.Raw()
			if err != nil {
				return err
			}
			p.NullableFloat = &wrapperspb.FloatValue{}
			if err := protojson.Unmarshal(raw, p.NullableFloat); err != nil {
				return err
			}
		case "nullableDouble":
			raw, err := d.Raw()
			if err != nil {
				return err
			}
			p.NullableDouble = &wrapperspb.DoubleValue{}
			if err := protojson.Unmarshal(raw, p.NullableDouble); err != nil {
				return err
			}
		case "nullableBool":
			raw, err := d.Raw()
			if err != nil {
				return err
			}
			p.NullableBool = &wrapperspb.BoolValue{}
			if err := protojson.Unmarshal(raw, p.NullableBool); err != nil {
				return err
			}
		case "nullableBytes":
			raw, err := d.Raw()
			if err != nil {
				return err
			}
			p.NullableBytes = &wrapperspb.BytesValue{}
			if err := protojson.Unmarshal(raw, p.NullableBytes); err != nil {
				return err
			}
		case "metadata":
			raw, err := d.Raw()
			if err != nil {
				return err
			}
			p.Metadata = &structpb.Struct{}
			if err := protojson.Unmarshal(raw, p.Metadata); err != nil {
				return err
			}
		case "dynamicValue":
			raw, err := d.Raw()
			if err != nil {
				return err
			}
			p.DynamicValue = &structpb.Value{}
			if err := protojson.Unmarshal(raw, p.DynamicValue); err != nil {
				return err
			}
		case "listValue":
			raw, err := d.Raw()
			if err != nil {
				return err
			}
			p.ListValue = &structpb.ListValue{}
			if err := protojson.Unmarshal(raw, p.ListValue); err != nil {
				return err
			}
		case "payload":
			raw, err := d.Raw()
			if err != nil {
				return err
			}
			p.Payload = &anypb.Any{}
			if err := protojson.Unmarshal(raw, p.Payload); err != nil {
				return err
			}
		case "payloads":
			return d.Arr(func(d *jx.Decoder) error {
				raw, err := d.Raw()
				if err != nil {
					return err
				}
				_v := &anypb.Any{}
				if err := protojson.Unmarshal(raw, _v); err != nil {
					return err
				}
				p.Payloads = append(p.Payloads, _v)
				return nil
			})
		case "empty":
			if err := d.Skip(); err != nil {
				return err
			}
			p.Empty = &emptypb.Empty{}
		case "timestamps":
			return d.Arr(func(d *jx.Decoder) error {
				raw, err := d.Raw()
				if err != nil {
					return err
				}
				_v := &timestamppb.Timestamp{}
				if err := protojson.Unmarshal(raw, _v); err != nil {
					return err
				}
				p.Timestamps = append(p.Timestamps, _v)
				return nil
			})
		case "durations":
			return d.Arr(func(d *jx.Decoder) error {
				raw, err := d.Raw()
				if err != nil {
					return err
				}
				_v := &durationpb.Duration{}
				if err := protojson.Unmarshal(raw, _v); err != nil {
					return err
				}
				p.Durations = append(p.Durations, _v)
				return nil
			})
		case "strings":
			return d.Arr(func(d *jx.Decoder) error {
				raw, err := d.Raw()
				if err != nil {
					return err
				}
				_v := &wrapperspb.StringValue{}
				if err := protojson.Unmarshal(raw, _v); err != nil {
					return err
				}
				p.Strings = append(p.Strings, _v)
				return nil
			})
		default:
			return d.Skip()
		}
		return nil
	})
}

// MarshalJX encodes MapShowcase to JSON using jx.Encoder
func (p *MapShowcase) MarshalJX(e *jx.Encoder) {
	if p == nil {
		e.Null()
		return
	}

	e.ObjStart()
	if len(p.GetStrStr()) > 0 {
		e.FieldStart("strStr")
		e.ObjStart()
		for k, v := range p.GetStrStr() {
			e.FieldStart(k)
			e.Str(v)
		}
		e.ObjEnd()
	}
	if len(p.GetStrInt32()) > 0 {
		e.FieldStart("strInt32")
		e.ObjStart()
		for k, v := range p.GetStrInt32() {
			e.FieldStart(k)
			e.Int32(v)
		}
		e.ObjEnd()
	}
	if len(p.GetStrInt64()) > 0 {
		e.FieldStart("strInt64")
		e.ObjStart()
		for k, v := range p.GetStrInt64() {
			e.FieldStart(k)
			e.Int64(v)
		}
		e.ObjEnd()
	}
	if len(p.GetStrUint32()) > 0 {
		e.FieldStart("strUint32")
		e.ObjStart()
		for k, v := range p.GetStrUint32() {
			e.FieldStart(k)
			e.UInt32(v)
		}
		e.ObjEnd()
	}
	if len(p.GetStrUint64()) > 0 {
		e.FieldStart("strUint64")
		e.ObjStart()
		for k, v := range p.GetStrUint64() {
			e.FieldStart(k)
			e.UInt64(v)
		}
		e.ObjEnd()
	}
	if len(p.GetStrFloat()) > 0 {
		e.FieldStart("strFloat")
		e.ObjStart()
		for k, v := range p.GetStrFloat() {
			e.FieldStart(k)
			e.Float32(v)
		}
		e.ObjEnd()
	}
	if len(p.GetStrDouble()) > 0 {
		e.FieldStart("strDouble")
		e.ObjStart()
		for k, v := range p.GetStrDouble() {
			e.FieldStart(k)
			e.Float64(v)
		}
		e.ObjEnd()
	}
	if len(p.GetStrBool()) > 0 {
		e.FieldStart("strBool")
		e.ObjStart()
		for k, v := range p.GetStrBool() {
			e.FieldStart(k)
			e.Bool(v)
		}
		e.ObjEnd()
	}
	if len(p.GetStrBytes()) > 0 {
		e.FieldStart("strBytes")
		e.ObjStart()
		for k, v := range p.GetStrBytes() {
			e.FieldStart(k)
			e.Base64(v)
		}
		e.ObjEnd()
	}
	if len(p.GetInt32Str()) > 0 {
		e.FieldStart("int32Str")
		e.ObjStart()
		for k, v := range p.GetInt32Str() {
			e.FieldStart(fmt.Sprint(k))
			e.Str(v)
		}
		e.ObjEnd()
	}
	if len(p.GetInt64Str()) > 0 {
		e.FieldStart("int64Str")
		e.ObjStart()
		for k, v := range p.GetInt64Str() {
			e.FieldStart(fmt.Sprint(k))
			e.Str(v)
		}
		e.ObjEnd()
	}
	if len(p.GetUint32Str()) > 0 {
		e.FieldStart("uint32Str")
		e.ObjStart()
		for k, v := range p.GetUint32Str() {
			e.FieldStart(fmt.Sprint(k))
			e.Str(v)
		}
		e.ObjEnd()
	}
	if len(p.GetUint64Str()) > 0 {
		e.FieldStart("uint64Str")
		e.ObjStart()
		for k, v := range p.GetUint64Str() {
			e.FieldStart(fmt.Sprint(k))
			e.Str(v)
		}
		e.ObjEnd()
	}
	if len(p.GetSint32Str()) > 0 {
		e.FieldStart("sint32Str")
		e.ObjStart()
		for k, v := range p.GetSint32Str() {
			e.FieldStart(fmt.Sprint(k))
			e.Str(v)
		}
		e.ObjEnd()
	}
	if len(p.GetSint64Str()) > 0 {
		e.FieldStart("sint64Str")
		e.ObjStart()
		for k, v := range p.GetSint64Str() {
			e.FieldStart(fmt.Sprint(k))
			e.Str(v)
		}
		e.ObjEnd()
	}
	if len(p.GetFixed32Str()) > 0 {
		e.FieldStart("fixed32Str")
		e.ObjStart()
		for k, v := range p.GetFixed32Str() {
			e.FieldStart(fmt.Sprint(k))
			e.Str(v)
		}
		e.ObjEnd()
	}
	if len(p.GetFixed64Str()) > 0 {
		e.FieldStart("fixed64Str")
		e.ObjStart()
		for k, v := range p.GetFixed64Str() {
			e.FieldStart(fmt.Sprint(k))
			e.Str(v)
		}
		e.ObjEnd()
	}
	if len(p.GetSfixed32Str()) > 0 {
		e.FieldStart("sfixed32Str")
		e.ObjStart()
		for k, v := range p.GetSfixed32Str() {
			e.FieldStart(fmt.Sprint(k))
			e.Str(v)
		}
		e.ObjEnd()
	}
	if len(p.GetSfixed64Str()) > 0 {
		e.FieldStart("sfixed64Str")
		e.ObjStart()
		for k, v := range p.GetSfixed64Str() {
			e.FieldStart(fmt.Sprint(k))
			e.Str(v)
		}
		e.ObjEnd()
	}
	if len(p.GetBoolStr()) > 0 {
		e.FieldStart("boolStr")
		e.ObjStart()
		for k, v := range p.GetBoolStr() {
			e.FieldStart(fmt.Sprint(k))
			e.Str(v)
		}
		e.ObjEnd()
	}
	if len(p.GetStrMessage()) > 0 {
		e.FieldStart("strMessage")
		e.ObjStart()
		for k, v := range p.GetStrMessage() {
			e.FieldStart(k)
			v.MarshalJX(e)
		}
		e.ObjEnd()
	}
	if len(p.GetInt32Message()) > 0 {
		e.FieldStart("int32Message")
		e.ObjStart()
		for k, v := range p.GetInt32Message() {
			e.FieldStart(fmt.Sprint(k))
			v.MarshalJX(e)
		}
		e.ObjEnd()
	}
	if len(p.GetInt64Message()) > 0 {
		e.FieldStart("int64Message")
		e.ObjStart()
		for k, v := range p.GetInt64Message() {
			e.FieldStart(fmt.Sprint(k))
			v.MarshalJX(e)
		}
		e.ObjEnd()
	}
	if len(p.GetStrEnum()) > 0 {
		e.FieldStart("strEnum")
		e.ObjStart()
		for k, v := range p.GetStrEnum() {
			e.FieldStart(k)
			e.Int32(int32(v))
		}
		e.ObjEnd()
	}
	if len(p.GetInt32Enum()) > 0 {
		e.FieldStart("int32Enum")
		e.ObjStart()
		for k, v := range p.GetInt32Enum() {
			e.FieldStart(fmt.Sprint(k))
			e.Int32(int32(v))
		}
		e.ObjEnd()
	}
	if len(p.GetNested()) > 0 {
		e.FieldStart("nested")
		e.ObjStart()
		for k, v := range p.GetNested() {
			e.FieldStart(k)
			v.MarshalJX(e)
		}
		e.ObjEnd()
	}
	e.ObjEnd()
}

// UnmarshalJX decodes MapShowcase from JSON using jx.Decoder
func (p *MapShowcase) UnmarshalJX(d *jx.Decoder) error {
	if p == nil {
		return nil
	}

	return d.Obj(func(d *jx.Decoder, key string) error {
		switch key {
		case "strStr":
			if p.StrStr == nil {
				p.StrStr = make(map[string]string)
			}
			return d.Obj(func(d *jx.Decoder, key string) error {
				v, err := d.Str()
				if err != nil {
					return err
				}
				p.StrStr[key] = v
				return nil
			})
		case "strInt32":
			if p.StrInt32 == nil {
				p.StrInt32 = make(map[string]int32)
			}
			return d.Obj(func(d *jx.Decoder, key string) error {
				v, err := d.Int32()
				if err != nil {
					return err
				}
				p.StrInt32[key] = v
				return nil
			})
		case "strInt64":
			if p.StrInt64 == nil {
				p.StrInt64 = make(map[string]int64)
			}
			return d.Obj(func(d *jx.Decoder, key string) error {
				v, err := d.Int64()
				if err != nil {
					return err
				}
				p.StrInt64[key] = v
				return nil
			})
		case "strUint32":
			if p.StrUint32 == nil {
				p.StrUint32 = make(map[string]uint32)
			}
			return d.Obj(func(d *jx.Decoder, key string) error {
				v, err := d.UInt32()
				if err != nil {
					return err
				}
				p.StrUint32[key] = v
				return nil
			})
		case "strUint64":
			if p.StrUint64 == nil {
				p.StrUint64 = make(map[string]uint64)
			}
			return d.Obj(func(d *jx.Decoder, key string) error {
				v, err := d.UInt64()
				if err != nil {
					return err
				}
				p.StrUint64[key] = v
				return nil
			})
		case "strFloat":
			if p.StrFloat == nil {
				p.StrFloat = make(map[string]float32)
			}
			return d.Obj(func(d *jx.Decoder, key string) error {
				v, err := d.Float32()
				if err != nil {
					return err
				}
				p.StrFloat[key] = v
				return nil
			})
		case "strDouble":
			if p.StrDouble == nil {
				p.StrDouble = make(map[string]float64)
			}
			return d.Obj(func(d *jx.Decoder, key string) error {
				v, err := d.Float64()
				if err != nil {
					return err
				}
				p.StrDouble[key] = v
				return nil
			})
		case "strBool":
			if p.StrBool == nil {
				p.StrBool = make(map[string]bool)
			}
			return d.Obj(func(d *jx.Decoder, key string) error {
				v, err := d.Bool()
				if err != nil {
					return err
				}
				p.StrBool[key] = v
				return nil
			})
		case "strBytes":
			if p.StrBytes == nil {
				p.StrBytes = make(map[string][]byte)
			}
			return d.Obj(func(d *jx.Decoder, key string) error {
				v, err := d.Base64()
				if err != nil {
					return err
				}
				p.StrBytes[key] = v
				return nil
			})
		case "int32Str":
			if p.Int32Str == nil {
				p.Int32Str = make(map[int32]string)
			}
			return d.Obj(func(d *jx.Decoder, key string) error {
				keyInt, err := strconv.ParseInt(key, 10, 32)
				if err != nil {
					return err
				}
				v, err := d.Str()
				if err != nil {
					return err
				}
				p.Int32Str[int32(keyInt)] = v
				return nil
			})
		case "int64Str":
			if p.Int64Str == nil {
				p.Int64Str = make(map[int64]string)
			}
			return d.Obj(func(d *jx.Decoder, key string) error {
				keyInt, err := strconv.ParseInt(key, 10, 64)
				if err != nil {
					return err
				}
				v, err := d.Str()
				if err != nil {
					return err
				}
				p.Int64Str[keyInt] = v
				return nil
			})
		case "uint32Str":
			if p.Uint32Str == nil {
				p.Uint32Str = make(map[uint32]string)
			}
			return d.Obj(func(d *jx.Decoder, key string) error {
				keyUint, err := strconv.ParseUint(key, 10, 32)
				if err != nil {
					return err
				}
				v, err := d.Str()
				if err != nil {
					return err
				}
				p.Uint32Str[uint32(keyUint)] = v
				return nil
			})
		case "uint64Str":
			if p.Uint64Str == nil {
				p.Uint64Str = make(map[uint64]string)
			}
			return d.Obj(func(d *jx.Decoder, key string) error {
				keyUint, err := strconv.ParseUint(key, 10, 64)
				if err != nil {
					return err
				}
				v, err := d.Str()
				if err != nil {
					return err
				}
				p.Uint64Str[keyUint] = v
				return nil
			})
		case "sint32Str":
			if p.Sint32Str == nil {
				p.Sint32Str = make(map[int32]string)
			}
			return d.Obj(func(d *jx.Decoder, key string) error {
				keyInt, err := strconv.ParseInt(key, 10, 32)
				if err != nil {
					return err
				}
				v, err := d.Str()
				if err != nil {
					return err
				}
				p.Sint32Str[int32(keyInt)] = v
				return nil
			})
		case "sint64Str":
			if p.Sint64Str == nil {
				p.Sint64Str = make(map[int64]string)
			}
			return d.Obj(func(d *jx.Decoder, key string) error {
				keyInt, err := strconv.ParseInt(key, 10, 64)
				if err != nil {
					return err
				}
				v, err := d.Str()
				if err != nil {
					return err
				}
				p.Sint64Str[keyInt] = v
				return nil
			})
		case "fixed32Str":
			if p.Fixed32Str == nil {
				p.Fixed32Str = make(map[uint32]string)
			}
			return d.Obj(func(d *jx.Decoder, key string) error {
				keyUint, err := strconv.ParseUint(key, 10, 32)
				if err != nil {
					return err
				}
				v, err := d.Str()
				if err != nil {
					return err
				}
				p.Fixed32Str[uint32(keyUint)] = v
				return nil
			})
		case "fixed64Str":
			if p.Fixed64Str == nil {
				p.Fixed64Str = make(map[uint64]string)
			}
			return d.Obj(func(d *jx.Decoder, key string) error {
				keyUint, err := strconv.ParseUint(key, 10, 64)
				if err != nil {
					return err
				}
				v, err := d.Str()
				if err != nil {
					return err
				}
				p.Fixed64Str[keyUint] = v
				return nil
			})
		case "sfixed32Str":
			if p.Sfixed32Str == nil {
				p.Sfixed32Str = make(map[int32]string)
			}
			return d.Obj(func(d *jx.Decoder, key string) error {
				keyInt, err := strconv.ParseInt(key, 10, 32)
				if err != nil {
					return err
				}
				v, err := d.Str()
				if err != nil {
					return err
				}
				p.Sfixed32Str[int32(keyInt)] = v
				return nil
			})
		case "sfixed64Str":
			if p.Sfixed64Str == nil {
				p.Sfixed64Str = make(map[int64]string)
			}
			return d.Obj(func(d *jx.Decoder, key string) error {
				keyInt, err := strconv.ParseInt(key, 10, 64)
				if err != nil {
					return err
				}
				v, err := d.Str()
				if err != nil {
					return err
				}
				p.Sfixed64Str[keyInt] = v
				return nil
			})
		case "boolStr":
			if p.BoolStr == nil {
				p.BoolStr = make(map[bool]string)
			}
			return d.Obj(func(d *jx.Decoder, key string) error {
				keyBool, err := strconv.ParseBool(key)
				if err != nil {
					return err
				}
				v, err := d.Str()
				if err != nil {
					return err
				}
				p.BoolStr[keyBool] = v
				return nil
			})
		case "strMessage":
			if p.StrMessage == nil {
				p.StrMessage = make(map[string]*Address)
			}
			return d.Obj(func(d *jx.Decoder, key string) error {
				v := &Address{}
				if err := v.UnmarshalJX(d); err != nil {
					return err
				}
				p.StrMessage[key] = v
				return nil
			})
		case "int32Message":
			if p.Int32Message == nil {
				p.Int32Message = make(map[int32]*Address)
			}
			return d.Obj(func(d *jx.Decoder, key string) error {
				keyInt, err := strconv.ParseInt(key, 10, 32)
				if err != nil {
					return err
				}
				v := &Address{}
				if err := v.UnmarshalJX(d); err != nil {
					return err
				}
				p.Int32Message[int32(keyInt)] = v
				return nil
			})
		case "int64Message":
			if p.Int64Message == nil {
				p.Int64Message = make(map[int64]*Metadata)
			}
			return d.Obj(func(d *jx.Decoder, key string) error {
				keyInt, err := strconv.ParseInt(key, 10, 64)
				if err != nil {
					return err
				}
				v := &Metadata{}
				if err := v.UnmarshalJX(d); err != nil {
					return err
				}
				p.Int64Message[keyInt] = v
				return nil
			})
		case "strEnum":
			if p.StrEnum == nil {
				p.StrEnum = make(map[string]Status)
			}
			return d.Obj(func(d *jx.Decoder, key string) error {
				v, err := d.Int32()
				if err != nil {
					return err
				}
				p.StrEnum[key] = Status(v)
				return nil
			})
		case "int32Enum":
			if p.Int32Enum == nil {
				p.Int32Enum = make(map[int32]Priority)
			}
			return d.Obj(func(d *jx.Decoder, key string) error {
				keyInt, err := strconv.ParseInt(key, 10, 32)
				if err != nil {
					return err
				}
				v, err := d.Int32()
				if err != nil {
					return err
				}
				p.Int32Enum[int32(keyInt)] = Priority(v)
				return nil
			})
		case "nested":
			if p.Nested == nil {
				p.Nested = make(map[string]*Config)
			}
			return d.Obj(func(d *jx.Decoder, key string) error {
				v := &Config{}
				if err := v.UnmarshalJX(d); err != nil {
					return err
				}
				p.Nested[key] = v
				return nil
			})
		default:
			return d.Skip()
		}
		return nil
	})
}

// MarshalJX encodes OptionalShowcase to JSON using jx.Encoder
func (p *OptionalShowcase) MarshalJX(e *jx.Encoder) {
	if p == nil {
		e.Null()
		return
	}

	e.ObjStart()
	if p.OptDouble != nil {
		e.FieldStart("optDouble")
		e.Float64(*p.OptDouble)
	}
	if p.OptFloat != nil {
		e.FieldStart("optFloat")
		e.Float32(*p.OptFloat)
	}
	if p.OptInt32 != nil {
		e.FieldStart("optInt32")
		e.Int32(*p.OptInt32)
	}
	if p.OptInt64 != nil {
		e.FieldStart("optInt64")
		e.Int64(*p.OptInt64)
	}
	if p.OptUint32 != nil {
		e.FieldStart("optUint32")
		e.UInt32(*p.OptUint32)
	}
	if p.OptUint64 != nil {
		e.FieldStart("optUint64")
		e.UInt64(*p.OptUint64)
	}
	if p.OptSint32 != nil {
		e.FieldStart("optSint32")
		e.Int32(*p.OptSint32)
	}
	if p.OptSint64 != nil {
		e.FieldStart("optSint64")
		e.Int64(*p.OptSint64)
	}
	if p.OptFixed32 != nil {
		e.FieldStart("optFixed32")
		e.UInt32(*p.OptFixed32)
	}
	if p.OptFixed64 != nil {
		e.FieldStart("optFixed64")
		e.UInt64(*p.OptFixed64)
	}
	if p.OptSfixed32 != nil {
		e.FieldStart("optSfixed32")
		e.Int32(*p.OptSfixed32)
	}
	if p.OptSfixed64 != nil {
		e.FieldStart("optSfixed64")
		e.Int64(*p.OptSfixed64)
	}
	if p.OptBool != nil {
		e.FieldStart("optBool")
		e.Bool(*p.OptBool)
	}
	if p.OptString != nil {
		e.FieldStart("optString")
		e.Str(*p.OptString)
	}
	if len(p.OptBytes) > 0 {
		e.FieldStart("optBytes")
		e.Base64(p.OptBytes)
	}
	if p.OptStatus != nil {
		e.FieldStart("optStatus")
		e.Int32(int32(*p.OptStatus))
	}
	if p.OptPriority != nil {
		e.FieldStart("optPriority")
		e.Int32(int32(*p.OptPriority))
	}
	if p.GetRegularDouble() != 0 {
		e.FieldStart("regularDouble")
		e.Float64(p.GetRegularDouble())
	}
	if p.GetRegularString() != "" {
		e.FieldStart("regularString")
		e.Str(p.GetRegularString())
	}
	if p.GetRegularBool() {
		e.FieldStart("regularBool")
		e.Bool(p.GetRegularBool())
	}
	e.ObjEnd()
}

// UnmarshalJX decodes OptionalShowcase from JSON using jx.Decoder
func (p *OptionalShowcase) UnmarshalJX(d *jx.Decoder) error {
	if p == nil {
		return nil
	}

	return d.Obj(func(d *jx.Decoder, key string) error {
		switch key {
		case "optDouble":
			v, err := d.Float64()
			if err != nil {
				return err
			}
			p.OptDouble = &v
		case "optFloat":
			v, err := d.Float32()
			if err != nil {
				return err
			}
			p.OptFloat = &v
		case "optInt32":
			v, err := d.Int32()
			if err != nil {
				return err
			}
			p.OptInt32 = &v
		case "optInt64":
			v, err := d.Int64()
			if err != nil {
				return err
			}
			p.OptInt64 = &v
		case "optUint32":
			v, err := d.UInt32()
			if err != nil {
				return err
			}
			p.OptUint32 = &v
		case "optUint64":
			v, err := d.UInt64()
			if err != nil {
				return err
			}
			p.OptUint64 = &v
		case "optSint32":
			v, err := d.Int32()
			if err != nil {
				return err
			}
			p.OptSint32 = &v
		case "optSint64":
			v, err := d.Int64()
			if err != nil {
				return err
			}
			p.OptSint64 = &v
		case "optFixed32":
			v, err := d.UInt32()
			if err != nil {
				return err
			}
			p.OptFixed32 = &v
		case "optFixed64":
			v, err := d.UInt64()
			if err != nil {
				return err
			}
			p.OptFixed64 = &v
		case "optSfixed32":
			v, err := d.Int32()
			if err != nil {
				return err
			}
			p.OptSfixed32 = &v
		case "optSfixed64":
			v, err := d.Int64()
			if err != nil {
				return err
			}
			p.OptSfixed64 = &v
		case "optBool":
			v, err := d.Bool()
			if err != nil {
				return err
			}
			p.OptBool = &v
		case "optString":
			v, err := d.Str()
			if err != nil {
				return err
			}
			p.OptString = &v
		case "optBytes":
			v, err := d.Base64()
			if err != nil {
				return err
			}
			p.OptBytes = v
		case "optStatus":
			v, err := d.Int32()
			if err != nil {
				return err
			}
			_ev := Status(v)
			p.OptStatus = &_ev
		case "optPriority":
			v, err := d.Int32()
			if err != nil {
				return err
			}
			_ev := Priority(v)
			p.OptPriority = &_ev
		case "regularDouble":
			v, err := d.Float64()
			if err != nil {
				return err
			}
			p.RegularDouble = v
		case "regularString":
			v, err := d.Str()
			if err != nil {
				return err
			}
			p.RegularString = v
		case "regularBool":
			v, err := d.Bool()
			if err != nil {
				return err
			}
			p.RegularBool = v
		default:
			return d.Skip()
		}
		return nil
	})
}

// MarshalJX encodes OneofShowcase to JSON using jx.Encoder
func (p *OneofShowcase) MarshalJX(e *jx.Encoder) {
	if p == nil {
		e.Null()
		return
	}

	e.ObjStart()
	if p.GetId() != "" {
		e.FieldStart("id")
		e.Str(p.GetId())
	}
	switch v := p.GetScalarChoice().(type) {
	case *OneofShowcase_StrVal:
		e.FieldStart("strVal")
		e.Str(v.StrVal)
	case *OneofShowcase_IntVal:
		e.FieldStart("intVal")
		e.Int32(v.IntVal)
	case *OneofShowcase_LongVal:
		e.FieldStart("longVal")
		e.Int64(v.LongVal)
	case *OneofShowcase_DoubleVal:
		e.FieldStart("doubleVal")
		e.Float64(v.DoubleVal)
	case *OneofShowcase_BoolVal:
		e.FieldStart("boolVal")
		e.Bool(v.BoolVal)
	case *OneofShowcase_BytesVal:
		e.FieldStart("bytesVal")
		e.Base64(v.BytesVal)
	}
	switch v := p.GetMessageChoice().(type) {
	case *OneofShowcase_Address:
		e.FieldStart("address")
		v.Address.MarshalJX(e)
	case *OneofShowcase_Contact:
		e.FieldStart("contact")
		v.Contact.MarshalJX(e)
	case *OneofShowcase_Metadata:
		e.FieldStart("metadata")
		v.Metadata.MarshalJX(e)
	}
	switch v := p.GetEnumChoice().(type) {
	case *OneofShowcase_Status:
		e.FieldStart("status")
		e.Int32(int32(v.Status))
	case *OneofShowcase_Priority:
		e.FieldStart("priority")
		e.Int32(int32(v.Priority))
	case *OneofShowcase_Error:
		e.FieldStart("error")
		e.Int32(int32(v.Error))
	}
	switch v := p.GetContent().(type) {
	case *OneofShowcase_Text:
		e.FieldStart("text")
		v.Text.MarshalJX(e)
	case *OneofShowcase_Image:
		e.FieldStart("image")
		v.Image.MarshalJX(e)
	case *OneofShowcase_Code:
		e.FieldStart("code")
		v.Code.MarshalJX(e)
	}
	switch v := p.GetSourceType().(type) {
	case *OneofShowcase_Url:
		e.FieldStart("url")
		e.Str(v.Url)
	case *OneofShowcase_FilePath:
		e.FieldStart("filePath")
		e.Str(v.FilePath)
	}
	switch v := p.GetDestinationType().(type) {
	case *OneofShowcase_DestUrl:
		e.FieldStart("destUrl")
		e.Str(v.DestUrl)
	case *OneofShowcase_DestPath:
		e.FieldStart("destPath")
		e.Str(v.DestPath)
	}
	e.ObjEnd()
}

// UnmarshalJX decodes OneofShowcase from JSON using jx.Decoder
func (p *OneofShowcase) UnmarshalJX(d *jx.Decoder) error {
	if p == nil {
		return nil
	}

	return d.Obj(func(d *jx.Decoder, key string) error {
		switch key {
		case "id":
			v, err := d.Str()
			if err != nil {
				return err
			}
			p.Id = v
		case "strVal":
			v, err := d.Str()
			if err != nil {
				return err
			}
			p.ScalarChoice = &OneofShowcase_StrVal{StrVal: v}
		case "intVal":
			v, err := d.Int32()
			if err != nil {
				return err
			}
			p.ScalarChoice = &OneofShowcase_IntVal{IntVal: v}
		case "longVal":
			v, err := d.Int64()
			if err != nil {
				return err
			}
			p.ScalarChoice = &OneofShowcase_LongVal{LongVal: v}
		case "doubleVal":
			v, err := d.Float64()
			if err != nil {
				return err
			}
			p.ScalarChoice = &OneofShowcase_DoubleVal{DoubleVal: v}
		case "boolVal":
			v, err := d.Bool()
			if err != nil {
				return err
			}
			p.ScalarChoice = &OneofShowcase_BoolVal{BoolVal: v}
		case "bytesVal":
			return d.Skip()
		case "address":
			v := &Address{}
			if err := v.UnmarshalJX(d); err != nil {
				return err
			}
			p.MessageChoice = &OneofShowcase_Address{Address: v}
		case "contact":
			v := &ContactInfo{}
			if err := v.UnmarshalJX(d); err != nil {
				return err
			}
			p.MessageChoice = &OneofShowcase_Contact{Contact: v}
		case "metadata":
			v := &Metadata{}
			if err := v.UnmarshalJX(d); err != nil {
				return err
			}
			p.MessageChoice = &OneofShowcase_Metadata{Metadata: v}
		case "status":
			return d.Skip()
		case "priority":
			return d.Skip()
		case "error":
			return d.Skip()
		case "text":
			v := &TextContent{}
			if err := v.UnmarshalJX(d); err != nil {
				return err
			}
			p.Content = &OneofShowcase_Text{Text: v}
		case "image":
			v := &ImageContent{}
			if err := v.UnmarshalJX(d); err != nil {
				return err
			}
			p.Content = &OneofShowcase_Image{Image: v}
		case "code":
			v := &CodeContent{}
			if err := v.UnmarshalJX(d); err != nil {
				return err
			}
			p.Content = &OneofShowcase_Code{Code: v}
		case "url":
			v, err := d.Str()
			if err != nil {
				return err
			}
			p.SourceType = &OneofShowcase_Url{Url: v}
		case "filePath":
			v, err := d.Str()
			if err != nil {
				return err
			}
			p.SourceType = &OneofShowcase_FilePath{FilePath: v}
		case "destUrl":
			v, err := d.Str()
			if err != nil {
				return err
			}
			p.DestinationType = &OneofShowcase_DestUrl{DestUrl: v}
		case "destPath":
			v, err := d.Str()
			if err != nil {
				return err
			}
			p.DestinationType = &OneofShowcase_DestPath{DestPath: v}
		default:
			return d.Skip()
		}
		return nil
	})
}

// MarshalJX encodes Heartbeat to JSON using jx.Encoder
func (p *Heartbeat) MarshalJX(e *jx.Encoder) {
	if p == nil {
		e.Null()
		return
	}

	e.ObjStart()
	if p.GetTimestamp() != 0 {
		e.FieldStart("timestamp")
		e.Int64(p.GetTimestamp())
	}
	if p.GetNodeId() != "" {
		e.FieldStart("nodeId")
		e.Str(p.GetNodeId())
	}
	if p.GetCpuPercent() != 0 {
		e.FieldStart("cpuPercent")
		e.Int32(p.GetCpuPercent())
	}
	if p.GetMemoryBytes() != 0 {
		e.FieldStart("memoryBytes")
		e.Int64(p.GetMemoryBytes())
	}
	e.ObjEnd()
}

// UnmarshalJX decodes Heartbeat from JSON using jx.Decoder
func (p *Heartbeat) UnmarshalJX(d *jx.Decoder) error {
	if p == nil {
		return nil
	}

	return d.Obj(func(d *jx.Decoder, key string) error {
		switch key {
		case "timestamp":
			v, err := d.Int64()
			if err != nil {
				return err
			}
			p.Timestamp = v
		case "nodeId":
			v, err := d.Str()
			if err != nil {
				return err
			}
			p.NodeId = v
		case "cpuPercent":
			v, err := d.Int32()
			if err != nil {
				return err
			}
			p.CpuPercent = v
		case "memoryBytes":
			v, err := d.Int64()
			if err != nil {
				return err
			}
			p.MemoryBytes = v
		default:
			return d.Skip()
		}
		return nil
	})
}

// MarshalJX encodes ProcessStarted to JSON using jx.Encoder
func (p *ProcessStarted) MarshalJX(e *jx.Encoder) {
	if p == nil {
		e.Null()
		return
	}

	e.ObjStart()
	if p.GetProcessId() != "" {
		e.FieldStart("processId")
		e.Str(p.GetProcessId())
	}
	if p.GetCommand() != "" {
		e.FieldStart("command")
		e.Str(p.GetCommand())
	}
	if len(p.GetArgs()) > 0 {
		e.FieldStart("args")
		e.ArrStart()
		for _, v := range p.GetArgs() {
			e.Str(v)
		}
		e.ArrEnd()
	}
	if p.GetStartTime() != 0 {
		e.FieldStart("startTime")
		e.Int64(p.GetStartTime())
	}
	e.ObjEnd()
}

// UnmarshalJX decodes ProcessStarted from JSON using jx.Decoder
func (p *ProcessStarted) UnmarshalJX(d *jx.Decoder) error {
	if p == nil {
		return nil
	}

	return d.Obj(func(d *jx.Decoder, key string) error {
		switch key {
		case "processId":
			v, err := d.Str()
			if err != nil {
				return err
			}
			p.ProcessId = v
		case "command":
			v, err := d.Str()
			if err != nil {
				return err
			}
			p.Command = v
		case "args":
			return d.Arr(func(d *jx.Decoder) error {
				v, err := d.Str()
				if err != nil {
					return err
				}
				p.Args = append(p.Args, v)
				return nil
			})
		case "startTime":
			v, err := d.Int64()
			if err != nil {
				return err
			}
			p.StartTime = v
		default:
			return d.Skip()
		}
		return nil
	})
}

// MarshalJX encodes ProcessExited to JSON using jx.Encoder
func (p *ProcessExited) MarshalJX(e *jx.Encoder) {
	if p == nil {
		e.Null()
		return
	}

	e.ObjStart()
	if p.GetProcessId() != "" {
		e.FieldStart("processId")
		e.Str(p.GetProcessId())
	}
	if p.GetExitCode() != 0 {
		e.FieldStart("exitCode")
		e.Int32(p.GetExitCode())
	}
	if p.GetExitTime() != 0 {
		e.FieldStart("exitTime")
		e.Int64(p.GetExitTime())
	}
	if p.GetSignal() != "" {
		e.FieldStart("signal")
		e.Str(p.GetSignal())
	}
	e.ObjEnd()
}

// UnmarshalJX decodes ProcessExited from JSON using jx.Decoder
func (p *ProcessExited) UnmarshalJX(d *jx.Decoder) error {
	if p == nil {
		return nil
	}

	return d.Obj(func(d *jx.Decoder, key string) error {
		switch key {
		case "processId":
			v, err := d.Str()
			if err != nil {
				return err
			}
			p.ProcessId = v
		case "exitCode":
			v, err := d.Int32()
			if err != nil {
				return err
			}
			p.ExitCode = v
		case "exitTime":
			v, err := d.Int64()
			if err != nil {
				return err
			}
			p.ExitTime = v
		case "signal":
			v, err := d.Str()
			if err != nil {
				return err
			}
			p.Signal = v
		default:
			return d.Skip()
		}
		return nil
	})
}

// MarshalJX encodes NetworkEvent to JSON using jx.Encoder
func (p *NetworkEvent) MarshalJX(e *jx.Encoder) {
	if p == nil {
		e.Null()
		return
	}

	e.ObjStart()
	if p.GetInterfaceName() != "" {
		e.FieldStart("interfaceName")
		e.Str(p.GetInterfaceName())
	}
	if p.GetRemoteAddr() != "" {
		e.FieldStart("remoteAddr")
		e.Str(p.GetRemoteAddr())
	}
	if p.GetRemotePort() != 0 {
		e.FieldStart("remotePort")
		e.Int32(p.GetRemotePort())
	}
	if p.GetProtocol() != "" {
		e.FieldStart("protocol")
		e.Str(p.GetProtocol())
	}
	if p.GetBytesSent() != 0 {
		e.FieldStart("bytesSent")
		e.Int64(p.GetBytesSent())
	}
	if p.GetBytesReceived() != 0 {
		e.FieldStart("bytesReceived")
		e.Int64(p.GetBytesReceived())
	}
	e.ObjEnd()
}

// UnmarshalJX decodes NetworkEvent from JSON using jx.Decoder
func (p *NetworkEvent) UnmarshalJX(d *jx.Decoder) error {
	if p == nil {
		return nil
	}

	return d.Obj(func(d *jx.Decoder, key string) error {
		switch key {
		case "interfaceName":
			v, err := d.Str()
			if err != nil {
				return err
			}
			p.InterfaceName = v
		case "remoteAddr":
			v, err := d.Str()
			if err != nil {
				return err
			}
			p.RemoteAddr = v
		case "remotePort":
			v, err := d.Int32()
			if err != nil {
				return err
			}
			p.RemotePort = v
		case "protocol":
			v, err := d.Str()
			if err != nil {
				return err
			}
			p.Protocol = v
		case "bytesSent":
			v, err := d.Int64()
			if err != nil {
				return err
			}
			p.BytesSent = v
		case "bytesReceived":
			v, err := d.Int64()
			if err != nil {
				return err
			}
			p.BytesReceived = v
		default:
			return d.Skip()
		}
		return nil
	})
}

// MarshalJX encodes PlatformEvent to JSON using jx.Encoder
func (p *PlatformEvent) MarshalJX(e *jx.Encoder) {
	if p == nil {
		e.Null()
		return
	}

	e.ObjStart()
	if p.GetEventId() != "" {
		e.FieldStart("eventId")
		e.Str(p.GetEventId())
	}
	if p.GetEventTime() != 0 {
		e.FieldStart("eventTime")
		e.Int64(p.GetEventTime())
	}
	if p.GetSource() != "" {
		e.FieldStart("source")
		e.Str(p.GetSource())
	}
	if len(p.GetLabels()) > 0 {
		e.FieldStart("labels")
		e.ObjStart()
		for k, v := range p.GetLabels() {
			e.FieldStart(k)
			e.Str(v)
		}
		e.ObjEnd()
	}
	switch v := p.GetPlatformEvent().(type) {
	case *PlatformEvent_Heartbeat:
		e.FieldStart("heartbeat")
		v.Heartbeat.MarshalJX(e)
	case *PlatformEvent_ProcessStarted:
		e.FieldStart("processStarted")
		v.ProcessStarted.MarshalJX(e)
	case *PlatformEvent_ProcessExited:
		e.FieldStart("processExited")
		v.ProcessExited.MarshalJX(e)
	case *PlatformEvent_NetworkEvent:
		e.FieldStart("networkEvent")
		v.NetworkEvent.MarshalJX(e)
	}
	e.ObjEnd()
}

// UnmarshalJX decodes PlatformEvent from JSON using jx.Decoder
func (p *PlatformEvent) UnmarshalJX(d *jx.Decoder) error {
	if p == nil {
		return nil
	}

	return d.Obj(func(d *jx.Decoder, key string) error {
		switch key {
		case "eventId":
			v, err := d.Str()
			if err != nil {
				return err
			}
			p.EventId = v
		case "eventTime":
			v, err := d.Int64()
			if err != nil {
				return err
			}
			p.EventTime = v
		case "source":
			v, err := d.Str()
			if err != nil {
				return err
			}
			p.Source = v
		case "labels":
			if p.Labels == nil {
				p.Labels = make(map[string]string)
			}
			return d.Obj(func(d *jx.Decoder, key string) error {
				v, err := d.Str()
				if err != nil {
					return err
				}
				p.Labels[key] = v
				return nil
			})
		case "heartbeat":
			v := &Heartbeat{}
			if err := v.UnmarshalJX(d); err != nil {
				return err
			}
			p.PlatformEvent = &PlatformEvent_Heartbeat{Heartbeat: v}
		case "processStarted":
			v := &ProcessStarted{}
			if err := v.UnmarshalJX(d); err != nil {
				return err
			}
			p.PlatformEvent = &PlatformEvent_ProcessStarted{ProcessStarted: v}
		case "processExited":
			v := &ProcessExited{}
			if err := v.UnmarshalJX(d); err != nil {
				return err
			}
			p.PlatformEvent = &PlatformEvent_ProcessExited{ProcessExited: v}
		case "networkEvent":
			v := &NetworkEvent{}
			if err := v.UnmarshalJX(d); err != nil {
				return err
			}
			p.PlatformEvent = &PlatformEvent_NetworkEvent{NetworkEvent: v}
		default:
			return d.Skip()
		}
		return nil
	})
}

// MarshalJX encodes DeprecatedShowcase to JSON using jx.Encoder
func (p *DeprecatedShowcase) MarshalJX(e *jx.Encoder) {
	if p == nil {
		e.Null()
		return
	}

	e.ObjStart()
	if p.GetId() != "" {
		e.FieldStart("id")
		e.Str(p.GetId())
	}
	if p.GetName() != "" {
		e.FieldStart("name")
		e.Str(p.GetName())
	}
	if p.GetOldField() != "" {
		e.FieldStart("oldField")
		e.Str(p.GetOldField())
	}
	if p.GetLegacyCount() != 0 {
		e.FieldStart("legacyCount")
		e.Int32(p.GetLegacyCount())
	}
	if p.GetNewField() != "" {
		e.FieldStart("newField")
		e.Str(p.GetNewField())
	}
	e.ObjEnd()
}

// UnmarshalJX decodes DeprecatedShowcase from JSON using jx.Decoder
func (p *DeprecatedShowcase) UnmarshalJX(d *jx.Decoder) error {
	if p == nil {
		return nil
	}

	return d.Obj(func(d *jx.Decoder, key string) error {
		switch key {
		case "id":
			v, err := d.Str()
			if err != nil {
				return err
			}
			p.Id = v
		case "name":
			v, err := d.Str()
			if err != nil {
				return err
			}
			p.Name = v
		case "oldField":
			v, err := d.Str()
			if err != nil {
				return err
			}
			p.OldField = v
		case "legacyCount":
			v, err := d.Int32()
			if err != nil {
				return err
			}
			p.LegacyCount = v
		case "newField":
			v, err := d.Str()
			if err != nil {
				return err
			}
			p.NewField = v
		default:
			return d.Skip()
		}
		return nil
	})
}

// MarshalJX encodes DefaultsShowcase to JSON using jx.Encoder
func (p *DefaultsShowcase) MarshalJX(e *jx.Encoder) {
	if p == nil {
		e.Null()
		return
	}

	e.ObjStart()
	if p.GetEmptyString() != "" {
		e.FieldStart("emptyString")
		e.Str(p.GetEmptyString())
	}
	if p.GetZeroInt() != 0 {
		e.FieldStart("zeroInt")
		e.Int32(p.GetZeroInt())
	}
	if p.GetZeroLong() != 0 {
		e.FieldStart("zeroLong")
		e.Int64(p.GetZeroLong())
	}
	if p.GetZeroDouble() != 0 {
		e.FieldStart("zeroDouble")
		e.Float64(p.GetZeroDouble())
	}
	if p.GetFalseBool() {
		e.FieldStart("falseBool")
		e.Bool(p.GetFalseBool())
	}
	if len(p.GetEmptyBytes()) > 0 {
		e.FieldStart("emptyBytes")
		e.Base64(p.GetEmptyBytes())
	}
	e.FieldStart("zeroEnum")
	e.Int32(int32(p.GetZeroEnum()))
	if len(p.GetEmptyList()) > 0 {
		e.FieldStart("emptyList")
		e.ArrStart()
		for _, v := range p.GetEmptyList() {
			e.Str(v)
		}
		e.ArrEnd()
	}
	if len(p.GetEmptyIntList()) > 0 {
		e.FieldStart("emptyIntList")
		e.ArrStart()
		for _, v := range p.GetEmptyIntList() {
			e.Int32(v)
		}
		e.ArrEnd()
	}
	if len(p.GetEmptyMap()) > 0 {
		e.FieldStart("emptyMap")
		e.ObjStart()
		for k, v := range p.GetEmptyMap() {
			e.FieldStart(k)
			e.Str(v)
		}
		e.ObjEnd()
	}
	if p.GetNilMessage() != nil {
		e.FieldStart("nilMessage")
		p.GetNilMessage().MarshalJX(e)
	}
	e.ObjEnd()
}

// UnmarshalJX decodes DefaultsShowcase from JSON using jx.Decoder
func (p *DefaultsShowcase) UnmarshalJX(d *jx.Decoder) error {
	if p == nil {
		return nil
	}

	return d.Obj(func(d *jx.Decoder, key string) error {
		switch key {
		case "emptyString":
			v, err := d.Str()
			if err != nil {
				return err
			}
			p.EmptyString = v
		case "zeroInt":
			v, err := d.Int32()
			if err != nil {
				return err
			}
			p.ZeroInt = v
		case "zeroLong":
			v, err := d.Int64()
			if err != nil {
				return err
			}
			p.ZeroLong = v
		case "zeroDouble":
			v, err := d.Float64()
			if err != nil {
				return err
			}
			p.ZeroDouble = v
		case "falseBool":
			v, err := d.Bool()
			if err != nil {
				return err
			}
			p.FalseBool = v
		case "emptyBytes":
			v, err := d.Base64()
			if err != nil {
				return err
			}
			p.EmptyBytes = v
		case "zeroEnum":
			v, err := d.Int32()
			if err != nil {
				return err
			}
			p.ZeroEnum = Status(v)
		case "emptyList":
			return d.Arr(func(d *jx.Decoder) error {
				v, err := d.Str()
				if err != nil {
					return err
				}
				p.EmptyList = append(p.EmptyList, v)
				return nil
			})
		case "emptyIntList":
			return d.Arr(func(d *jx.Decoder) error {
				v, err := d.Int32()
				if err != nil {
					return err
				}
				p.EmptyIntList = append(p.EmptyIntList, v)
				return nil
			})
		case "emptyMap":
			if p.EmptyMap == nil {
				p.EmptyMap = make(map[string]string)
			}
			return d.Obj(func(d *jx.Decoder, key string) error {
				v, err := d.Str()
				if err != nil {
					return err
				}
				p.EmptyMap[key] = v
				return nil
			})
		case "nilMessage":
			p.NilMessage = &Address{}
			if err := p.NilMessage.UnmarshalJX(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// MarshalJX encodes ComplexNested to JSON using jx.Encoder
func (p *ComplexNested) MarshalJX(e *jx.Encoder) {
	if p == nil {
		e.Null()
		return
	}

	e.ObjStart()
	if p.GetId() != "" {
		e.FieldStart("id")
		e.Str(p.GetId())
	}
	if p.GetInner() != nil {
		e.FieldStart("inner")
		p.GetInner().MarshalJX(e)
	}
	if len(p.GetInnerList()) > 0 {
		e.FieldStart("innerList")
		e.ArrStart()
		for _, v := range p.GetInnerList() {
			v.MarshalJX(e)
		}
		e.ArrEnd()
	}
	if len(p.GetInnerMap()) > 0 {
		e.FieldStart("innerMap")
		e.ObjStart()
		for k, v := range p.GetInnerMap() {
			e.FieldStart(k)
			v.MarshalJX(e)
		}
		e.ObjEnd()
	}
	e.FieldStart("innerEnum")
	e.Int32(int32(p.GetInnerEnum()))
	if len(p.GetInnerEnumList()) > 0 {
		e.FieldStart("innerEnumList")
		e.ArrStart()
		for _, v := range p.GetInnerEnumList() {
			e.Int32(int32(v))
		}
		e.ArrEnd()
	}
	switch v := p.GetChoice().(type) {
	case *ComplexNested_ChoiceInner:
		e.FieldStart("choiceInner")
		v.ChoiceInner.MarshalJX(e)
	case *ComplexNested_ChoiceString:
		e.FieldStart("choiceString")
		e.Str(v.ChoiceString)
	}
	e.ObjEnd()
}

// UnmarshalJX decodes ComplexNested from JSON using jx.Decoder
func (p *ComplexNested) UnmarshalJX(d *jx.Decoder) error {
	if p == nil {
		return nil
	}

	return d.Obj(func(d *jx.Decoder, key string) error {
		switch key {
		case "id":
			v, err := d.Str()
			if err != nil {
				return err
			}
			p.Id = v
		case "inner":
			p.Inner = &ComplexNested_Inner{}
			if err := p.Inner.UnmarshalJX(d); err != nil {
				return err
			}
		case "innerList":
			return d.Arr(func(d *jx.Decoder) error {
				v := &ComplexNested_Inner{}
				if err := v.UnmarshalJX(d); err != nil {
					return err
				}
				p.InnerList = append(p.InnerList, v)
				return nil
			})
		case "innerMap":
			if p.InnerMap == nil {
				p.InnerMap = make(map[string]*ComplexNested_Inner)
			}
			return d.Obj(func(d *jx.Decoder, key string) error {
				v := &ComplexNested_Inner{}
				if err := v.UnmarshalJX(d); err != nil {
					return err
				}
				p.InnerMap[key] = v
				return nil
			})
		case "innerEnum":
			v, err := d.Int32()
			if err != nil {
				return err
			}
			p.InnerEnum = ComplexNested_InnerEnum(v)
		case "innerEnumList":
			return d.Arr(func(d *jx.Decoder) error {
				v, err := d.Int32()
				if err != nil {
					return err
				}
				p.InnerEnumList = append(p.InnerEnumList, ComplexNested_InnerEnum(v))
				return nil
			})
		case "choiceInner":
			v := &ComplexNested_Inner{}
			if err := v.UnmarshalJX(d); err != nil {
				return err
			}
			p.Choice = &ComplexNested_ChoiceInner{ChoiceInner: v}
		case "choiceString":
			v, err := d.Str()
			if err != nil {
				return err
			}
			p.Choice = &ComplexNested_ChoiceString{ChoiceString: v}
		default:
			return d.Skip()
		}
		return nil
	})
}

// MarshalJX encodes ComplexNested_Inner to JSON using jx.Encoder
func (p *ComplexNested_Inner) MarshalJX(e *jx.Encoder) {
	if p == nil {
		e.Null()
		return
	}

	e.ObjStart()
	if p.GetValue() != "" {
		e.FieldStart("value")
		e.Str(p.GetValue())
	}
	if p.GetCount() != 0 {
		e.FieldStart("count")
		e.Int32(p.GetCount())
	}
	if p.GetDeep() != nil {
		e.FieldStart("deep")
		p.GetDeep().MarshalJX(e)
	}
	if len(p.GetDeepList()) > 0 {
		e.FieldStart("deepList")
		e.ArrStart()
		for _, v := range p.GetDeepList() {
			v.MarshalJX(e)
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

// UnmarshalJX decodes ComplexNested_Inner from JSON using jx.Decoder
func (p *ComplexNested_Inner) UnmarshalJX(d *jx.Decoder) error {
	if p == nil {
		return nil
	}

	return d.Obj(func(d *jx.Decoder, key string) error {
		switch key {
		case "value":
			v, err := d.Str()
			if err != nil {
				return err
			}
			p.Value = v
		case "count":
			v, err := d.Int32()
			if err != nil {
				return err
			}
			p.Count = v
		case "deep":
			p.Deep = &ComplexNested_Inner_DeepInner{}
			if err := p.Deep.UnmarshalJX(d); err != nil {
				return err
			}
		case "deepList":
			return d.Arr(func(d *jx.Decoder) error {
				v := &ComplexNested_Inner_DeepInner{}
				if err := v.UnmarshalJX(d); err != nil {
					return err
				}
				p.DeepList = append(p.DeepList, v)
				return nil
			})
		default:
			return d.Skip()
		}
		return nil
	})
}

// MarshalJX encodes ComplexNested_Inner_DeepInner to JSON using jx.Encoder
func (p *ComplexNested_Inner_DeepInner) MarshalJX(e *jx.Encoder) {
	if p == nil {
		e.Null()
		return
	}

	e.ObjStart()
	if p.GetDeepValue() != "" {
		e.FieldStart("deepValue")
		e.Str(p.GetDeepValue())
	}
	if len(p.GetTags()) > 0 {
		e.FieldStart("tags")
		e.ArrStart()
		for _, v := range p.GetTags() {
			e.Str(v)
		}
		e.ArrEnd()
	}
	if len(p.GetScores()) > 0 {
		e.FieldStart("scores")
		e.ObjStart()
		for k, v := range p.GetScores() {
			e.FieldStart(k)
			e.Int32(v)
		}
		e.ObjEnd()
	}
	e.ObjEnd()
}

// UnmarshalJX decodes ComplexNested_Inner_DeepInner from JSON using jx.Decoder
func (p *ComplexNested_Inner_DeepInner) UnmarshalJX(d *jx.Decoder) error {
	if p == nil {
		return nil
	}

	return d.Obj(func(d *jx.Decoder, key string) error {
		switch key {
		case "deepValue":
			v, err := d.Str()
			if err != nil {
				return err
			}
			p.DeepValue = v
		case "tags":
			return d.Arr(func(d *jx.Decoder) error {
				v, err := d.Str()
				if err != nil {
					return err
				}
				p.Tags = append(p.Tags, v)
				return nil
			})
		case "scores":
			if p.Scores == nil {
				p.Scores = make(map[string]int32)
			}
			return d.Obj(func(d *jx.Decoder, key string) error {
				v, err := d.Int32()
				if err != nil {
					return err
				}
				p.Scores[key] = v
				return nil
			})
		default:
			return d.Skip()
		}
		return nil
	})
}
