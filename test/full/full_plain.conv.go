// Code generated by protoc-gen-go-plain. DO NOT EDIT.

package full

import (
	"fmt"
	"github.com/google/uuid"
	"github.com/yaroher/protoc-gen-go-plain/cast"
	"strings"
)

func parseCRFPath(s string) []string {
	if s == "" {
		return nil
	}
	parts := strings.Split(s, "/")
	result := make([]string, 0, len(parts))
	for _, p := range parts {
		if p == "" {
			continue
		}
		if idx := strings.Index(p, "?"); idx >= 0 {
			p = p[:idx]
		}
		result = append(result, p)
	}
	return result
}

func (x *BasePlain) IntoPb() *Base {
	if x == nil {
		return nil
	}
	out := &Base{}
	out.Id = x.Id
	out.Source = x.Source
	return out
}

func (x *Base) IntoPlain() *BasePlain {
	if x == nil {
		return nil
	}
	out := &BasePlain{}
	out.Id = x.Id
	out.Source = x.Source
	return out
}

func (x *BasePlain) IntoPbErr() (*Base, error) {
	if x == nil {
		return nil, nil
	}
	out := &Base{}
	out.Id = x.Id
	out.Source = x.Source
	return out, nil
}

func (x *Base) IntoPlainErr() (*BasePlain, error) {
	if x == nil {
		return nil, nil
	}
	out := &BasePlain{}
	out.Id = x.Id
	out.Source = x.Source
	return out, nil
}

func (x *ComplexPlain) IntoPb(casterUuidUuidToString cast.Caster[uuid.UUID, string]) *Complex {
	if x == nil {
		return nil
	}
	out := &Complex{}
	out.Meta = x.Meta
	if x.Comment != nil {
		out.Comment = x.Comment
	}
	if x.ContactPhone != nil {
		out.Contact = &Complex_Phone{Phone: *x.ContactPhone}
	}
	out.AliasId = &StringAlias{Value: x.AliasId}
	if x.CreatedAt != nil {
		out.CreatedAt = x.CreatedAt
	}
	if casterUuidUuidToString == nil {
		panic("missing caster: casterUuidUuidToString")
	}
	val := casterUuidUuidToString.Cast(x.CustomId)
	out.CustomId = val
	if len(x.AliasList) > 0 {
		vals := make([]*StringAlias, len(x.AliasList))
		for i, v := range x.AliasList {
			vals[i] = &StringAlias{Value: v}
		}
		out.AliasList = vals
	}
	out.Int32Alias = &Int32Alias{Value: x.Int32Alias}
	out.Int64Alias = &Int64Alias{Value: x.Int64Alias}
	if len(x.BoolAliasList) > 0 {
		vals := make([]*BoolAlias, len(x.BoolAliasList))
		for i, v := range x.BoolAliasList {
			vals[i] = &BoolAlias{Value: v}
		}
		out.BoolAliasList = vals
	}
	out.BytesAlias = &BytesAlias{Value: x.BytesAlias}
	if x.Note != nil {
		_valNote := *x.Note
		out.Note = &_valNote
	}
	if len(x.RawList) > 0 {
		out.RawList = x.RawList
	}
	if x.ContactEmail != nil {
		out.Contact = &Complex_Email{Email: *x.ContactEmail}
	}
	out.Status = Status(x.Status)
	out.CustomNameAlias = &CustomNameAlias{Data: x.CustomNameAlias}
	// skip invalid path for VirtualNote
	if x.IdCRF != "" {
		_crfPath := strings.Join(parseCRFPath(x.IdCRF), "/")
		switch _crfPath {
		case "base/id":
			if x.Id != nil {
				if out.Base == nil {
					out.Base = &Base{}
				}
				out.Base.Id = *x.Id
			}
		case "extra/id":
			if x.Id != nil {
				if out.Extra == nil {
					out.Extra = &Extra{}
				}
				out.Extra.Id = *x.Id
			}
		}
	} else {
		if x.Id != nil {
			if out.Base == nil {
				out.Base = &Base{}
			}
			out.Base.Id = *x.Id
		}
	}
	// skip invalid path for IdCRF
	if out.Base == nil {
		out.Base = &Base{}
	}
	out.Base.Source = x.Source
	out.Name = x.Name
	if len(x.Labels) > 0 {
		out.Labels = x.Labels
	}
	if len(x.StatusList) > 0 {
		_valStatusListSlice := make([]Status, len(x.StatusList))
		for i, el := range x.StatusList {
			_valStatusListSlice[i] = Status(el)
		}
		out.StatusList = _valStatusListSlice
	}
	out.FloatAlias = &FloatAlias{Value: x.FloatAlias}
	out.DoubleAlias = &DoubleAlias{Value: x.DoubleAlias}
	if out.Extra == nil {
		out.Extra = &Extra{}
	}
	out.Extra.Tag = x.Tag
	if x.Archived != nil {
		_valArchived := *x.Archived
		out.Archived = &_valArchived
	}
	out.Raw = x.Raw
	out.Counters = x.Counters
	return out
}

func (x *Complex) IntoPlain(casterStringToUuidUuid cast.Caster[string, uuid.UUID]) *ComplexPlain {
	if x == nil {
		return nil
	}
	out := &ComplexPlain{}
	if len(x.Meta) > 0 {
		out.Meta = x.Meta
	}
	if x.Comment != nil {
		out.Comment = x.Comment
	}
	if _oneofPhone0XPhone_0, ok := x.Contact.(*Complex_Phone); ok {
		_valContactPhone := _oneofPhone0XPhone_0.Phone
		out.ContactPhone = &_valContactPhone
	}
	if x.AliasId != nil {
		val := x.AliasId.Value
		out.AliasId = val
	}
	if x.CreatedAt != nil {
		out.CreatedAt = x.CreatedAt
	}
	if x.CustomId != "" {
		if casterStringToUuidUuid == nil {
			panic("missing caster: casterStringToUuidUuid")
		}
		out.CustomId = casterStringToUuidUuid.Cast(x.CustomId)
	}
	if len(x.AliasList) > 0 {
		vals := make([]string, 0, len(x.AliasList))
		for _, v := range x.AliasList {
			if v == nil {
				continue
			}
			vals = append(vals, v.Value)
		}
		out.AliasList = vals
	}
	if x.Int32Alias != nil {
		val := x.Int32Alias.Value
		out.Int32Alias = val
	}
	if x.Int64Alias != nil {
		val := x.Int64Alias.Value
		out.Int64Alias = val
	}
	if len(x.BoolAliasList) > 0 {
		vals := make([]bool, 0, len(x.BoolAliasList))
		for _, v := range x.BoolAliasList {
			if v == nil {
				continue
			}
			vals = append(vals, v.Value)
		}
		out.BoolAliasList = vals
	}
	if x.BytesAlias != nil {
		val := x.BytesAlias.Value
		out.BytesAlias = val
	}
	if x.Note != nil {
		_valNote := *x.Note
		out.Note = &_valNote
	}
	if len(x.RawList) > 0 {
		out.RawList = x.RawList
	}
	if _oneofEmail0XEmail_1, ok := x.Contact.(*Complex_Email); ok {
		_valContactEmail := _oneofEmail0XEmail_1.Email
		out.ContactEmail = &_valContactEmail
	}
	out.Status = int32(x.Status)
	if x.CustomNameAlias != nil {
		val := x.CustomNameAlias.Data
		out.CustomNameAlias = val
	}
	// skip invalid path for VirtualNote
	// CRF paths
	if x.Base != nil {
		if x.Base.Id != "" {
			_valId := x.Base.Id
			out.Id = &_valId
			out.IdCRF = "base/id"
		}
	}
	if x.Extra != nil {
		if x.Extra.Id != "" {
			_valId := x.Extra.Id
			out.Id = &_valId
			out.IdCRF = "extra/id"
		}
	}
	// skip invalid path for IdCRF
	if x.Base != nil {
		out.Source = x.Base.Source
	}
	out.Name = x.Name
	if len(x.Labels) > 0 {
		out.Labels = x.Labels
	}
	if len(x.StatusList) > 0 {
		_valStatusListSlice := make([]int32, len(x.StatusList))
		for i, el := range x.StatusList {
			_valStatusListSlice[i] = int32(el)
		}
		out.StatusList = _valStatusListSlice
	}
	if x.FloatAlias != nil {
		val := x.FloatAlias.Value
		out.FloatAlias = val
	}
	if x.DoubleAlias != nil {
		val := x.DoubleAlias.Value
		out.DoubleAlias = val
	}
	if x.Extra != nil {
		out.Tag = x.Extra.Tag
	}
	if x.Archived != nil {
		_valArchived := *x.Archived
		out.Archived = &_valArchived
	}
	out.Raw = x.Raw
	if len(x.Counters) > 0 {
		out.Counters = x.Counters
	}
	return out
}

func (x *ComplexPlain) IntoPbErr(casterUuidUuidToString cast.CasterErr[uuid.UUID, string]) (*Complex, error) {
	if x == nil {
		return nil, nil
	}
	out := &Complex{}
	out.Meta = x.Meta
	if x.Comment != nil {
		out.Comment = x.Comment
	}
	if x.ContactPhone != nil {
		out.Contact = &Complex_Phone{Phone: *x.ContactPhone}
	}
	out.AliasId = &StringAlias{Value: x.AliasId}
	if x.CreatedAt != nil {
		out.CreatedAt = x.CreatedAt
	}
	if casterUuidUuidToString == nil {
		return nil, fmt.Errorf("missing caster: casterUuidUuidToString")
	}
	val, err := casterUuidUuidToString.CastErr(x.CustomId)
	if err != nil {
		return nil, err
	}
	out.CustomId = val
	if len(x.AliasList) > 0 {
		vals := make([]*StringAlias, len(x.AliasList))
		for i, v := range x.AliasList {
			vals[i] = &StringAlias{Value: v}
		}
		out.AliasList = vals
	}
	out.Int32Alias = &Int32Alias{Value: x.Int32Alias}
	out.Int64Alias = &Int64Alias{Value: x.Int64Alias}
	if len(x.BoolAliasList) > 0 {
		vals := make([]*BoolAlias, len(x.BoolAliasList))
		for i, v := range x.BoolAliasList {
			vals[i] = &BoolAlias{Value: v}
		}
		out.BoolAliasList = vals
	}
	out.BytesAlias = &BytesAlias{Value: x.BytesAlias}
	if x.Note != nil {
		_valNote := *x.Note
		out.Note = &_valNote
	}
	if len(x.RawList) > 0 {
		out.RawList = x.RawList
	}
	if x.ContactEmail != nil {
		out.Contact = &Complex_Email{Email: *x.ContactEmail}
	}
	out.Status = Status(x.Status)
	out.CustomNameAlias = &CustomNameAlias{Data: x.CustomNameAlias}
	// skip invalid path for VirtualNote
	if x.IdCRF != "" {
		_crfPath := strings.Join(parseCRFPath(x.IdCRF), "/")
		switch _crfPath {
		case "base/id":
			if x.Id != nil {
				if out.Base == nil {
					out.Base = &Base{}
				}
				out.Base.Id = *x.Id
			}
		case "extra/id":
			if x.Id != nil {
				if out.Extra == nil {
					out.Extra = &Extra{}
				}
				out.Extra.Id = *x.Id
			}
		}
	} else {
		if x.Id != nil {
			if out.Base == nil {
				out.Base = &Base{}
			}
			out.Base.Id = *x.Id
		}
	}
	// skip invalid path for IdCRF
	if out.Base == nil {
		out.Base = &Base{}
	}
	out.Base.Source = x.Source
	out.Name = x.Name
	if len(x.Labels) > 0 {
		out.Labels = x.Labels
	}
	if len(x.StatusList) > 0 {
		_valStatusListSlice := make([]Status, len(x.StatusList))
		for i, el := range x.StatusList {
			_valStatusListSlice[i] = Status(el)
		}
		out.StatusList = _valStatusListSlice
	}
	out.FloatAlias = &FloatAlias{Value: x.FloatAlias}
	out.DoubleAlias = &DoubleAlias{Value: x.DoubleAlias}
	if out.Extra == nil {
		out.Extra = &Extra{}
	}
	out.Extra.Tag = x.Tag
	if x.Archived != nil {
		_valArchived := *x.Archived
		out.Archived = &_valArchived
	}
	out.Raw = x.Raw
	out.Counters = x.Counters
	return out, nil
}

func (x *Complex) IntoPlainErr(casterStringToUuidUuid cast.CasterErr[string, uuid.UUID]) (*ComplexPlain, error) {
	if x == nil {
		return nil, nil
	}
	out := &ComplexPlain{}
	if len(x.Meta) > 0 {
		out.Meta = x.Meta
	}
	if x.Comment != nil {
		out.Comment = x.Comment
	}
	if _oneofPhone0XPhone_2, ok := x.Contact.(*Complex_Phone); ok {
		_valContactPhone := _oneofPhone0XPhone_2.Phone
		out.ContactPhone = &_valContactPhone
	}
	if x.AliasId != nil {
		val := x.AliasId.Value
		out.AliasId = val
	}
	if x.CreatedAt != nil {
		out.CreatedAt = x.CreatedAt
	}
	if x.CustomId != "" {
		if casterStringToUuidUuid == nil {
			return nil, fmt.Errorf("missing caster: casterStringToUuidUuid")
		}
		val, err := casterStringToUuidUuid.CastErr(x.CustomId)
		if err != nil {
			return nil, err
		}
		out.CustomId = val
	}
	if len(x.AliasList) > 0 {
		vals := make([]string, 0, len(x.AliasList))
		for _, v := range x.AliasList {
			if v == nil {
				continue
			}
			vals = append(vals, v.Value)
		}
		out.AliasList = vals
	}
	if x.Int32Alias != nil {
		val := x.Int32Alias.Value
		out.Int32Alias = val
	}
	if x.Int64Alias != nil {
		val := x.Int64Alias.Value
		out.Int64Alias = val
	}
	if len(x.BoolAliasList) > 0 {
		vals := make([]bool, 0, len(x.BoolAliasList))
		for _, v := range x.BoolAliasList {
			if v == nil {
				continue
			}
			vals = append(vals, v.Value)
		}
		out.BoolAliasList = vals
	}
	if x.BytesAlias != nil {
		val := x.BytesAlias.Value
		out.BytesAlias = val
	}
	if x.Note != nil {
		_valNote := *x.Note
		out.Note = &_valNote
	}
	if len(x.RawList) > 0 {
		out.RawList = x.RawList
	}
	if _oneofEmail0XEmail_3, ok := x.Contact.(*Complex_Email); ok {
		_valContactEmail := _oneofEmail0XEmail_3.Email
		out.ContactEmail = &_valContactEmail
	}
	out.Status = int32(x.Status)
	if x.CustomNameAlias != nil {
		val := x.CustomNameAlias.Data
		out.CustomNameAlias = val
	}
	// skip invalid path for VirtualNote
	// CRF paths
	if x.Base != nil {
		if x.Base.Id != "" {
			_valId := x.Base.Id
			out.Id = &_valId
			out.IdCRF = "base/id"
		}
	}
	if x.Extra != nil {
		if x.Extra.Id != "" {
			_valId := x.Extra.Id
			out.Id = &_valId
			out.IdCRF = "extra/id"
		}
	}
	// skip invalid path for IdCRF
	if x.Base != nil {
		out.Source = x.Base.Source
	}
	out.Name = x.Name
	if len(x.Labels) > 0 {
		out.Labels = x.Labels
	}
	if len(x.StatusList) > 0 {
		_valStatusListSlice := make([]int32, len(x.StatusList))
		for i, el := range x.StatusList {
			_valStatusListSlice[i] = int32(el)
		}
		out.StatusList = _valStatusListSlice
	}
	if x.FloatAlias != nil {
		val := x.FloatAlias.Value
		out.FloatAlias = val
	}
	if x.DoubleAlias != nil {
		val := x.DoubleAlias.Value
		out.DoubleAlias = val
	}
	if x.Extra != nil {
		out.Tag = x.Extra.Tag
	}
	if x.Archived != nil {
		_valArchived := *x.Archived
		out.Archived = &_valArchived
	}
	out.Raw = x.Raw
	if len(x.Counters) > 0 {
		out.Counters = x.Counters
	}
	return out, nil
}

func (x *ExtraPlain) IntoPb() *Extra {
	if x == nil {
		return nil
	}
	out := &Extra{}
	out.Id = x.Id
	out.Tag = x.Tag
	return out
}

func (x *Extra) IntoPlain() *ExtraPlain {
	if x == nil {
		return nil
	}
	out := &ExtraPlain{}
	out.Id = x.Id
	out.Tag = x.Tag
	return out
}

func (x *ExtraPlain) IntoPbErr() (*Extra, error) {
	if x == nil {
		return nil, nil
	}
	out := &Extra{}
	out.Id = x.Id
	out.Tag = x.Tag
	return out, nil
}

func (x *Extra) IntoPlainErr() (*ExtraPlain, error) {
	if x == nil {
		return nil, nil
	}
	out := &ExtraPlain{}
	out.Id = x.Id
	out.Tag = x.Tag
	return out, nil
}
