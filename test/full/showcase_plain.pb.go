// Code generated by protoc-gen-go-plain. DO NOT EDIT.
// source: test/full/showcase.proto

package full

import (
	json "encoding/json"
	fmt "fmt"
	jx "github.com/go-faster/jx"
	cast "github.com/yaroher/protoc-gen-go-plain/cast"
	protojson "google.golang.org/protobuf/encoding/protojson"
	proto "google.golang.org/protobuf/proto"
	anypb "google.golang.org/protobuf/types/known/anypb"
	durationpb "google.golang.org/protobuf/types/known/durationpb"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
	structpb "google.golang.org/protobuf/types/known/structpb"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
	wrapperspb "google.golang.org/protobuf/types/known/wrapperspb"
	strconv "strconv"
	sync "sync"
	time "time"
)

type MetricsPlain struct {
	DurationNs     time.Duration `json:"durationNs"`
	TimestampUnix  int64         `json:"timestampUnix"`
	BytesProcessed int64         `json:"bytesProcessed"`
	RequestsCount  int32         `json:"requestsCount"`
	SuccessRate    float64       `json:"successRate"`
}

// MetricsPlainCasters contains type casters for MetricsPlain
type MetricsPlainCasters struct {
	DurationNsToPlain cast.Caster[int64, time.Duration]
	DurationNsToPb    cast.Caster[time.Duration, int64]
}

// IntoPlain converts protobuf message to plain struct
func (pb *Metrics) IntoPlain(c *MetricsPlainCasters) *MetricsPlain {
	if pb == nil {
		return nil
	}
	p := &MetricsPlain{}

	p.DurationNs = c.DurationNsToPlain.Cast(pb.DurationNs)
	p.TimestampUnix = pb.TimestampUnix
	p.BytesProcessed = pb.BytesProcessed
	p.RequestsCount = pb.RequestsCount
	p.SuccessRate = pb.SuccessRate
	return p
}

// IntoPb converts plain struct to protobuf message
func (p *MetricsPlain) IntoPb(c *MetricsPlainCasters) *Metrics {
	if p == nil {
		return nil
	}
	pb := &Metrics{}

	pb.DurationNs = c.DurationNsToPb.Cast(p.DurationNs)
	pb.TimestampUnix = p.TimestampUnix
	pb.BytesProcessed = p.BytesProcessed
	pb.RequestsCount = p.RequestsCount
	pb.SuccessRate = p.SuccessRate
	return pb
}

// MarshalJX encodes MetricsPlain to JSON using jx.Encoder
func (p *MetricsPlain) MarshalJX(e *jx.Encoder) {
	if p == nil {
		e.Null()
		return
	}

	e.ObjStart()

	e.FieldStart("durationNs")
	e.Int64(int64(p.DurationNs))
	if p.TimestampUnix != 0 {
		e.FieldStart("timestampUnix")
		e.Int64(p.TimestampUnix)
	}
	if p.BytesProcessed != 0 {
		e.FieldStart("bytesProcessed")
		e.Int64(p.BytesProcessed)
	}
	if p.RequestsCount != 0 {
		e.FieldStart("requestsCount")
		e.Int32(p.RequestsCount)
	}
	if p.SuccessRate != 0 {
		e.FieldStart("successRate")
		e.Float64(p.SuccessRate)
	}
	e.ObjEnd()
}

// MarshalJSON implements json.Marshaler using jx
func (p *MetricsPlain) MarshalJSON() ([]byte, error) {
	e := jx.GetEncoder()
	defer jx.PutEncoder(e)
	p.MarshalJX(e)
	return e.Bytes(), nil
}

// UnmarshalJX decodes MetricsPlain from JSON using jx.Decoder
func (p *MetricsPlain) UnmarshalJX(d *jx.Decoder) error {
	if p == nil {
		return nil
	}

	return d.Obj(func(d *jx.Decoder, key string) error {
		switch key {
		case "durationNs":
			v, err := d.Int64()
			if err != nil {
				return err
			}
			p.DurationNs = time.Duration(v)
		case "timestampUnix":
			v, err := d.Int64()
			if err != nil {
				return err
			}
			p.TimestampUnix = v
		case "bytesProcessed":
			v, err := d.Int64()
			if err != nil {
				return err
			}
			p.BytesProcessed = v
		case "requestsCount":
			v, err := d.Int32()
			if err != nil {
				return err
			}
			p.RequestsCount = v
		case "successRate":
			v, err := d.Float64()
			if err != nil {
				return err
			}
			p.SuccessRate = v
		default:
			return d.Skip()
		}
		return nil
	})
}

// UnmarshalJSON implements json.Unmarshaler using jx
func (p *MetricsPlain) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return p.UnmarshalJX(d)
}

// metricsPlainPool is a sync.Pool for MetricsPlain objects
var metricsPlainPool = sync.Pool{
	New: func() interface{} {
		return &MetricsPlain{}
	},
}

// GetMetricsPlain returns a MetricsPlain from the pool
func GetMetricsPlain() *MetricsPlain {
	return metricsPlainPool.Get().(*MetricsPlain)
}

// PutMetricsPlain returns a MetricsPlain to the pool after resetting it
func PutMetricsPlain(p *MetricsPlain) {
	if p == nil {
		return
	}
	p.Reset()
	metricsPlainPool.Put(p)
}

// Reset clears all fields in MetricsPlain for reuse
func (p *MetricsPlain) Reset() {
	if p == nil {
		return
	}

	p.DurationNs = 0
	p.TimestampUnix = 0
	p.BytesProcessed = 0
	p.RequestsCount = 0
	p.SuccessRate = 0
}

type CustomTypesPlain struct {
	RawJson json.RawMessage `json:"rawJson"`
	Name    string          `json:"name"`
	Count   int64           `json:"count"`
	Label   string          `json:"label"` // origin: type_alias, empath: label
}

// IntoPlain converts protobuf message to plain struct
func (pb *CustomTypes) IntoPlain() *CustomTypesPlain {
	if pb == nil {
		return nil
	}
	p := &CustomTypesPlain{}

	p.RawJson = json.RawMessage(pb.RawJson)
	p.Name = pb.Name
	p.Count = pb.Count
	// Label type alias from label
	if pb.GetLabel() != nil {
		p.Label = pb.GetLabel().GetValue()
	}
	return p
}

// IntoPb converts plain struct to protobuf message
func (p *CustomTypesPlain) IntoPb() *CustomTypes {
	if p == nil {
		return nil
	}
	pb := &CustomTypes{}

	pb.RawJson = []byte(p.RawJson)
	pb.Name = p.Name
	pb.Count = p.Count
	// Label type alias -> label
	if p.Label != "" {
		pb.Label = &MyString{Value: p.Label}
	}
	return pb
}

// IntoPlainReuse converts protobuf message to existing plain struct (for pool usage)
func (pb *CustomTypes) IntoPlainReuse(p *CustomTypesPlain) {
	if pb == nil || p == nil {
		return
	}
	// Reset before filling
	p.Reset()

	p.RawJson = json.RawMessage(pb.RawJson)
	p.Name = pb.Name
	p.Count = pb.Count
	// Label type alias from label
	if pb.GetLabel() != nil {
		p.Label = pb.GetLabel().GetValue()
	}
}

// MarshalJX encodes CustomTypesPlain to JSON using jx.Encoder
func (p *CustomTypesPlain) MarshalJX(e *jx.Encoder) {
	if p == nil {
		e.Null()
		return
	}

	e.ObjStart()

	e.FieldStart("rawJson")
	// unknown scalar: RawMessage
	e.Null()
	if p.Name != "" {
		e.FieldStart("name")
		e.Str(p.Name)
	}
	if p.Count != 0 {
		e.FieldStart("count")
		e.Int64(p.Count)
	}
	if p.Label != "" {
		e.FieldStart("label")
		e.Str(p.Label)
	}
	e.ObjEnd()
}

// MarshalJSON implements json.Marshaler using jx
func (p *CustomTypesPlain) MarshalJSON() ([]byte, error) {
	e := jx.GetEncoder()
	defer jx.PutEncoder(e)
	p.MarshalJX(e)
	return e.Bytes(), nil
}

// UnmarshalJX decodes CustomTypesPlain from JSON using jx.Decoder
func (p *CustomTypesPlain) UnmarshalJX(d *jx.Decoder) error {
	if p == nil {
		return nil
	}

	return d.Obj(func(d *jx.Decoder, key string) error {
		switch key {
		case "rawJson":
			return d.Skip()
		case "name":
			v, err := d.Str()
			if err != nil {
				return err
			}
			p.Name = v
		case "count":
			v, err := d.Int64()
			if err != nil {
				return err
			}
			p.Count = v
		case "label":
			v, err := d.Str()
			if err != nil {
				return err
			}
			p.Label = v
		default:
			return d.Skip()
		}
		return nil
	})
}

// UnmarshalJSON implements json.Unmarshaler using jx
func (p *CustomTypesPlain) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return p.UnmarshalJX(d)
}

// customTypesPlainPool is a sync.Pool for CustomTypesPlain objects
var customTypesPlainPool = sync.Pool{
	New: func() interface{} {
		return &CustomTypesPlain{}
	},
}

// GetCustomTypesPlain returns a CustomTypesPlain from the pool
func GetCustomTypesPlain() *CustomTypesPlain {
	return customTypesPlainPool.Get().(*CustomTypesPlain)
}

// PutCustomTypesPlain returns a CustomTypesPlain to the pool after resetting it
func PutCustomTypesPlain(p *CustomTypesPlain) {
	if p == nil {
		return
	}
	p.Reset()
	customTypesPlainPool.Put(p)
}

// Reset clears all fields in CustomTypesPlain for reuse
func (p *CustomTypesPlain) Reset() {
	if p == nil {
		return
	}

	p.RawJson = nil
	p.Name = ""
	p.Count = 0
	p.Label = ""
}

type DocumentPlain struct {
	Id                       string            `json:"id"`
	Title                    string            `json:"title"`
	Status                   Status            `json:"status"`
	Priority                 Priority          `json:"priority"`
	Description              string            `json:"description"` // origin: type_alias, empath: description
	Version                  int64             `json:"version"`     // origin: type_alias, empath: version
	IsPublic                 bool              `json:"isPublic"`    // origin: type_alias, empath: is_public
	Email                    string            `json:"email"`
	Phone                    string            `json:"phone"`
	Address                  *Address          `json:"address"`
	Metadata                 *Metadata         `json:"metadata"`
	Performance              []byte            `json:"performance"` // origin: serialized, empath: performance
	Keywords                 []string          `json:"keywords"`
	Attributes               map[string]string `json:"attributes"`
	Locations                []*Address        `json:"locations"`
	Structure                *Level1           `json:"structure"`
	Children                 []DocumentPlain   `json:"children"`
	Parent                   *DocumentPlain    `json:"parent"`
	TextContentTextContent   *TextContent      `json:"textContentTextContent"`   // origin: oneof_embed, empath: text_content.text_content
	ImageContentImageContent *ImageContent     `json:"imageContentImageContent"` // origin: oneof_embed, empath: image_content.image_content
	VideoContentVideoContent *VideoContent     `json:"videoContentVideoContent"` // origin: oneof_embed, empath: video_content.video_content
	CodeContentCodeContent   *CodeContent      `json:"codeContentCodeContent"`   // origin: oneof_embed, empath: code_content.code_content
	TableContentTableContent *TableContent     `json:"tableContentTableContent"` // origin: oneof_embed, empath: table_content.table_content
	ComputedHash             string            `json:"computedHash"`             // origin: virtual, empath: virtual
	IsValid                  bool              `json:"isValid"`                  // origin: virtual, empath: virtual
	// ContentCase indicates which variant of content oneof is set
	ContentCase string `json:"content_case,omitempty"`
}

// IntoPlain converts protobuf message to plain struct
func (pb *Document) IntoPlain() *DocumentPlain {
	if pb == nil {
		return nil
	}
	p := &DocumentPlain{}

	// Detect content oneof case
	switch pb.Content.(type) {
	case *Document_TextContent:
		p.ContentCase = "text_content"
	case *Document_ImageContent:
		p.ContentCase = "image_content"
	case *Document_VideoContent:
		p.ContentCase = "video_content"
	case *Document_CodeContent:
		p.ContentCase = "code_content"
	case *Document_TableContent:
		p.ContentCase = "table_content"
	}

	p.Id = pb.Id
	p.Title = pb.Title
	p.Status = pb.Status
	p.Priority = pb.Priority
	// Description type alias from description
	if pb.GetDescription() != nil {
		p.Description = pb.GetDescription().GetValue()
	}
	// Version type alias from version
	if pb.GetVersion() != nil {
		p.Version = pb.GetVersion().GetValue()
	}
	// IsPublic type alias from is_public
	if pb.GetIsPublic() != nil {
		p.IsPublic = pb.GetIsPublic().GetValue()
	}
	// Email from
	if pb.GetAuthor() != nil {
		p.Email = pb.GetAuthor().GetEmail()
	}
	// Phone from
	if pb.GetAuthor() != nil {
		p.Phone = pb.GetAuthor().GetPhone()
	}
	// Address from
	if pb.GetAuthor() != nil && pb.GetAuthor().GetAddress() != nil {
		p.Address = pb.GetAuthor().GetAddress()
	}
	p.Metadata = pb.Metadata
	// Performance serialized from performance
	if pb.Performance != nil {
		if data, err := proto.Marshal(pb.Performance); err == nil {
			p.Performance = data
		}
	}
	p.Keywords = pb.Keywords
	p.Attributes = pb.Attributes
	p.Locations = pb.Locations
	p.Structure = pb.Structure
	if len(pb.Children) > 0 {
		p.Children = make([]DocumentPlain, len(pb.Children))
		for i, v := range pb.Children {
			if v != nil {
				p.Children[i] = *v.IntoPlain()
			}
		}
	}
	if pb.Parent != nil {
		p.Parent = pb.Parent.IntoPlain()
	}
	// TextContentTextContent from text_content.text_content
	if pb.GetTextContent() != nil {
		p.TextContentTextContent = pb.GetTextContent()
	}
	// ImageContentImageContent from image_content.image_content
	if pb.GetImageContent() != nil {
		p.ImageContentImageContent = pb.GetImageContent()
	}
	// VideoContentVideoContent from video_content.video_content
	if pb.GetVideoContent() != nil {
		p.VideoContentVideoContent = pb.GetVideoContent()
	}
	// CodeContentCodeContent from code_content.code_content
	if pb.GetCodeContent() != nil {
		p.CodeContentCodeContent = pb.GetCodeContent()
	}
	// TableContentTableContent from table_content.table_content
	if pb.GetTableContent() != nil {
		p.TableContentTableContent = pb.GetTableContent()
	}
	// ComputedHash is virtual, no source in protobuf
	// IsValid is virtual, no source in protobuf
	return p
}

// IntoPb converts plain struct to protobuf message
func (p *DocumentPlain) IntoPb() *Document {
	if p == nil {
		return nil
	}
	pb := &Document{}

	pb.Id = p.Id
	pb.Title = p.Title
	pb.Status = p.Status
	pb.Priority = p.Priority
	// Description type alias -> description
	if p.Description != "" {
		pb.Description = &StringValue{Value: p.Description}
	}
	// Version type alias -> version
	{
		pb.Version = &Int64Value{Value: p.Version}
	}
	// IsPublic type alias -> is_public
	{
		pb.IsPublic = &BoolValue{Value: p.IsPublic}
	}
	// Email ->
	if p.Email != "" {
		if pb.Author == nil {
			pb.Author = &ContactInfo{}
		}
		pb.Author.Email = p.Email
	}
	// Phone ->
	if p.Phone != "" {
		if pb.Author == nil {
			pb.Author = &ContactInfo{}
		}
		pb.Author.Phone = p.Phone
	}
	// Address ->
	if p.Address != nil {
		if pb.Author == nil {
			pb.Author = &ContactInfo{}
		}
		pb.Author.Address = p.Address
	}
	pb.Metadata = p.Metadata
	// Performance deserialize -> performance
	if len(p.Performance) > 0 {
		// TODO: Initialize parent structures for Performance
		var msg Metrics
		if err := proto.Unmarshal(p.Performance, &msg); err == nil {
			pb.Performance = &msg
		}
	}
	pb.Keywords = p.Keywords
	pb.Attributes = p.Attributes
	pb.Locations = p.Locations
	pb.Structure = p.Structure
	if len(p.Children) > 0 {
		pb.Children = make([]*Document, len(p.Children))
		for i := range p.Children {
			pb.Children[i] = (&p.Children[i]).IntoPb()
		}
	}
	if p.Parent != nil {
		pb.Parent = p.Parent.IntoPb()
	}
	// TextContentTextContent -> text_content.text_content
	if p.TextContentTextContent != nil && p.ContentCase == "text_content" {
		pb.Content = &Document_TextContent{TextContent: p.TextContentTextContent}
	}
	// ImageContentImageContent -> image_content.image_content
	if p.ImageContentImageContent != nil && p.ContentCase == "image_content" {
		pb.Content = &Document_ImageContent{ImageContent: p.ImageContentImageContent}
	}
	// VideoContentVideoContent -> video_content.video_content
	if p.VideoContentVideoContent != nil && p.ContentCase == "video_content" {
		pb.Content = &Document_VideoContent{VideoContent: p.VideoContentVideoContent}
	}
	// CodeContentCodeContent -> code_content.code_content
	if p.CodeContentCodeContent != nil && p.ContentCase == "code_content" {
		pb.Content = &Document_CodeContent{CodeContent: p.CodeContentCodeContent}
	}
	// TableContentTableContent -> table_content.table_content
	if p.TableContentTableContent != nil && p.ContentCase == "table_content" {
		pb.Content = &Document_TableContent{TableContent: p.TableContentTableContent}
	}
	// ComputedHash is virtual, skipping
	// IsValid is virtual, skipping
	return pb
}

// IntoPlainReuse converts protobuf message to existing plain struct (for pool usage)
func (pb *Document) IntoPlainReuse(p *DocumentPlain) {
	if pb == nil || p == nil {
		return
	}
	// Reset before filling
	p.Reset()

	// Detect content oneof case
	switch pb.Content.(type) {
	case *Document_TextContent:
		p.ContentCase = "text_content"
	case *Document_ImageContent:
		p.ContentCase = "image_content"
	case *Document_VideoContent:
		p.ContentCase = "video_content"
	case *Document_CodeContent:
		p.ContentCase = "code_content"
	case *Document_TableContent:
		p.ContentCase = "table_content"
	}

	p.Id = pb.Id
	p.Title = pb.Title
	p.Status = pb.Status
	p.Priority = pb.Priority
	// Description type alias from description
	if pb.GetDescription() != nil {
		p.Description = pb.GetDescription().GetValue()
	}
	// Version type alias from version
	if pb.GetVersion() != nil {
		p.Version = pb.GetVersion().GetValue()
	}
	// IsPublic type alias from is_public
	if pb.GetIsPublic() != nil {
		p.IsPublic = pb.GetIsPublic().GetValue()
	}
	// Email from
	if pb.GetAuthor() != nil {
		p.Email = pb.GetAuthor().GetEmail()
	}
	// Phone from
	if pb.GetAuthor() != nil {
		p.Phone = pb.GetAuthor().GetPhone()
	}
	// Address from
	if pb.GetAuthor() != nil && pb.GetAuthor().GetAddress() != nil {
		p.Address = pb.GetAuthor().GetAddress()
	}
	p.Metadata = pb.Metadata
	// Performance serialized from performance
	if pb.Performance != nil {
		if data, err := proto.Marshal(pb.Performance); err == nil {
			p.Performance = data
		}
	}
	p.Keywords = pb.Keywords
	p.Attributes = pb.Attributes
	p.Locations = pb.Locations
	p.Structure = pb.Structure
	if len(pb.Children) > 0 {
		p.Children = make([]DocumentPlain, len(pb.Children))
		for i, v := range pb.Children {
			if v != nil {
				p.Children[i] = *v.IntoPlain()
			}
		}
	}
	if pb.Parent != nil {
		p.Parent = pb.Parent.IntoPlain()
	}
	// TextContentTextContent from text_content.text_content
	if pb.GetTextContent() != nil {
		p.TextContentTextContent = pb.GetTextContent()
	}
	// ImageContentImageContent from image_content.image_content
	if pb.GetImageContent() != nil {
		p.ImageContentImageContent = pb.GetImageContent()
	}
	// VideoContentVideoContent from video_content.video_content
	if pb.GetVideoContent() != nil {
		p.VideoContentVideoContent = pb.GetVideoContent()
	}
	// CodeContentCodeContent from code_content.code_content
	if pb.GetCodeContent() != nil {
		p.CodeContentCodeContent = pb.GetCodeContent()
	}
	// TableContentTableContent from table_content.table_content
	if pb.GetTableContent() != nil {
		p.TableContentTableContent = pb.GetTableContent()
	}
	// ComputedHash is virtual, no source in protobuf
	// IsValid is virtual, no source in protobuf
}

// MarshalJX encodes DocumentPlain to JSON using jx.Encoder
func (p *DocumentPlain) MarshalJX(e *jx.Encoder) {
	if p == nil {
		e.Null()
		return
	}

	e.ObjStart()

	if p.ContentCase != "" {
		e.FieldStart("content_case")
		e.Str(p.ContentCase)
	}
	if p.Id != "" {
		e.FieldStart("id")
		e.Str(p.Id)
	}
	if p.Title != "" {
		e.FieldStart("title")
		e.Str(p.Title)
	}
	e.FieldStart("status")
	e.Int32(int32(p.Status))
	e.FieldStart("priority")
	e.Int32(int32(p.Priority))
	if p.Description != "" {
		e.FieldStart("description")
		e.Str(p.Description)
	}
	if p.Version != 0 {
		e.FieldStart("version")
		e.Int64(p.Version)
	}
	if p.IsPublic {
		e.FieldStart("isPublic")
		e.Bool(p.IsPublic)
	}
	if p.Email != "" {
		e.FieldStart("email")
		e.Str(p.Email)
	}
	if p.Phone != "" {
		e.FieldStart("phone")
		e.Str(p.Phone)
	}
	if p.Address != nil {
		e.FieldStart("address")
		p.Address.MarshalJX(e)
	}
	if p.Metadata != nil {
		e.FieldStart("metadata")
		p.Metadata.MarshalJX(e)
	}
	if len(p.Performance) > 0 {
		e.FieldStart("performance")
		e.Base64(p.Performance)
	}
	if len(p.Keywords) > 0 {
		e.FieldStart("keywords")
		e.ArrStart()
		for _, v := range p.Keywords {
			e.Str(v)
		}
		e.ArrEnd()
	}
	e.FieldStart("attributes")
	e.ObjStart()
	for k, v := range p.Attributes {
		e.FieldStart(k)
		e.Str(v)
	}
	e.ObjEnd()
	if p.Locations != nil {
		e.FieldStart("locations")
		e.ArrStart()
		for _, v := range p.Locations {
			v.MarshalJX(e)
		}
		e.ArrEnd()
	}
	if p.Structure != nil {
		e.FieldStart("structure")
		p.Structure.MarshalJX(e)
	}
	if len(p.Children) > 0 {
		e.FieldStart("children")
		e.ArrStart()
		for _, v := range p.Children {
			(&v).MarshalJX(e)
		}
		e.ArrEnd()
	}
	if p.Parent != nil {
		e.FieldStart("parent")
		p.Parent.MarshalJX(e)
	}
	if p.TextContentTextContent != nil {
		e.FieldStart("textContentTextContent")
		p.TextContentTextContent.MarshalJX(e)
	}
	if p.ImageContentImageContent != nil {
		e.FieldStart("imageContentImageContent")
		p.ImageContentImageContent.MarshalJX(e)
	}
	if p.VideoContentVideoContent != nil {
		e.FieldStart("videoContentVideoContent")
		p.VideoContentVideoContent.MarshalJX(e)
	}
	if p.CodeContentCodeContent != nil {
		e.FieldStart("codeContentCodeContent")
		p.CodeContentCodeContent.MarshalJX(e)
	}
	if p.TableContentTableContent != nil {
		e.FieldStart("tableContentTableContent")
		p.TableContentTableContent.MarshalJX(e)
	}
	if p.ComputedHash != "" {
		e.FieldStart("computedHash")
		e.Str(p.ComputedHash)
	}
	if p.IsValid {
		e.FieldStart("isValid")
		e.Bool(p.IsValid)
	}
	e.ObjEnd()
}

// MarshalJSON implements json.Marshaler using jx
func (p *DocumentPlain) MarshalJSON() ([]byte, error) {
	e := jx.GetEncoder()
	defer jx.PutEncoder(e)
	p.MarshalJX(e)
	return e.Bytes(), nil
}

// UnmarshalJX decodes DocumentPlain from JSON using jx.Decoder
func (p *DocumentPlain) UnmarshalJX(d *jx.Decoder) error {
	if p == nil {
		return nil
	}

	return d.Obj(func(d *jx.Decoder, key string) error {
		switch key {
		case "content_case":
			v, err := d.Str()
			if err != nil {
				return err
			}
			p.ContentCase = v
		case "id":
			v, err := d.Str()
			if err != nil {
				return err
			}
			p.Id = v
		case "title":
			v, err := d.Str()
			if err != nil {
				return err
			}
			p.Title = v
		case "status":
			v, err := d.Int32()
			if err != nil {
				return err
			}
			p.Status = Status(v)
		case "priority":
			v, err := d.Int32()
			if err != nil {
				return err
			}
			p.Priority = Priority(v)
		case "description":
			v, err := d.Str()
			if err != nil {
				return err
			}
			p.Description = v
		case "version":
			v, err := d.Int64()
			if err != nil {
				return err
			}
			p.Version = v
		case "isPublic":
			v, err := d.Bool()
			if err != nil {
				return err
			}
			p.IsPublic = v
		case "email":
			v, err := d.Str()
			if err != nil {
				return err
			}
			p.Email = v
		case "phone":
			v, err := d.Str()
			if err != nil {
				return err
			}
			p.Phone = v
		case "address":
			p.Address = &Address{}
			if err := p.Address.UnmarshalJX(d); err != nil {
				return err
			}
		case "metadata":
			p.Metadata = &Metadata{}
			if err := p.Metadata.UnmarshalJX(d); err != nil {
				return err
			}
		case "performance":
			v, err := d.Base64()
			if err != nil {
				return err
			}
			p.Performance = v
		case "keywords":
			if err := d.Arr(func(d *jx.Decoder) error {
				v, err := d.Str()
				if err != nil {
					return err
				}
				p.Keywords = append(p.Keywords, v)
				return nil
			}); err != nil {
				return err
			}
		case "attributes":
			if p.Attributes == nil {
				p.Attributes = make(map[string]string)
			}
			return d.Obj(func(d *jx.Decoder, key string) error {
				v, err := d.Str()
				if err != nil {
					return err
				}
				p.Attributes[key] = v
				return nil
			})
		case "locations":
			if err := d.Arr(func(d *jx.Decoder) error {
				var v Address
				if err := v.UnmarshalJX(d); err != nil {
					return err
				}
				p.Locations = append(p.Locations, &v)
				return nil
			}); err != nil {
				return err
			}
		case "structure":
			p.Structure = &Level1{}
			if err := p.Structure.UnmarshalJX(d); err != nil {
				return err
			}
		case "children":
			if err := d.Arr(func(d *jx.Decoder) error {
				var v DocumentPlain
				if err := v.UnmarshalJX(d); err != nil {
					return err
				}
				p.Children = append(p.Children, v)
				return nil
			}); err != nil {
				return err
			}
		case "parent":
			p.Parent = &DocumentPlain{}
			if err := p.Parent.UnmarshalJX(d); err != nil {
				return err
			}
		case "textContentTextContent":
			p.TextContentTextContent = &TextContent{}
			if err := p.TextContentTextContent.UnmarshalJX(d); err != nil {
				return err
			}
		case "imageContentImageContent":
			p.ImageContentImageContent = &ImageContent{}
			if err := p.ImageContentImageContent.UnmarshalJX(d); err != nil {
				return err
			}
		case "videoContentVideoContent":
			p.VideoContentVideoContent = &VideoContent{}
			if err := p.VideoContentVideoContent.UnmarshalJX(d); err != nil {
				return err
			}
		case "codeContentCodeContent":
			p.CodeContentCodeContent = &CodeContent{}
			if err := p.CodeContentCodeContent.UnmarshalJX(d); err != nil {
				return err
			}
		case "tableContentTableContent":
			p.TableContentTableContent = &TableContent{}
			if err := p.TableContentTableContent.UnmarshalJX(d); err != nil {
				return err
			}
		case "computedHash":
			v, err := d.Str()
			if err != nil {
				return err
			}
			p.ComputedHash = v
		case "isValid":
			v, err := d.Bool()
			if err != nil {
				return err
			}
			p.IsValid = v
		default:
			return d.Skip()
		}
		return nil
	})
}

// UnmarshalJSON implements json.Unmarshaler using jx
func (p *DocumentPlain) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return p.UnmarshalJX(d)
}

// documentPlainPool is a sync.Pool for DocumentPlain objects
var documentPlainPool = sync.Pool{
	New: func() interface{} {
		return &DocumentPlain{}
	},
}

// GetDocumentPlain returns a DocumentPlain from the pool
func GetDocumentPlain() *DocumentPlain {
	return documentPlainPool.Get().(*DocumentPlain)
}

// PutDocumentPlain returns a DocumentPlain to the pool after resetting it
func PutDocumentPlain(p *DocumentPlain) {
	if p == nil {
		return
	}
	p.Reset()
	documentPlainPool.Put(p)
}

// Reset clears all fields in DocumentPlain for reuse
func (p *DocumentPlain) Reset() {
	if p == nil {
		return
	}

	p.ContentCase = ""
	p.Id = ""
	p.Title = ""
	p.Status = 0
	p.Priority = 0
	p.Description = ""
	p.Version = 0
	p.IsPublic = false
	p.Email = ""
	p.Phone = ""
	p.Address = nil
	p.Metadata = nil
	p.Performance = nil
	p.Keywords = p.Keywords[:0]
	for k := range p.Attributes {
		delete(p.Attributes, k)
	}
	p.Locations = nil
	p.Structure = nil
	p.Children = p.Children[:0]
	p.Parent = nil
	p.TextContentTextContent = nil
	p.ImageContentImageContent = nil
	p.VideoContentVideoContent = nil
	p.CodeContentCodeContent = nil
	p.TableContentTableContent = nil
	p.ComputedHash = ""
	p.IsValid = false
}

type TreeNodePlain struct {
	Id         string            `json:"id"`
	Name       string            `json:"name"`
	Type       string            `json:"type"`
	Children   []TreeNodePlain   `json:"children"`
	Parent     *TreeNodePlain    `json:"parent"`
	CreatedBy  string            `json:"createdBy"`
	CreatedAt  int64             `json:"createdAt"`
	ModifiedBy string            `json:"modifiedBy"`
	ModifiedAt int64             `json:"modifiedAt"`
	Labels     map[string]string `json:"labels"`
	Tags       []string          `json:"tags"`
	TextText   *TextContent      `json:"textText"`   // origin: oneof_embed, empath: text.text
	ImageImage *ImageContent     `json:"imageImage"` // origin: oneof_embed, empath: image.image
	CodeCode   *CodeContent      `json:"codeCode"`   // origin: oneof_embed, empath: code.code
	// PayloadCase indicates which variant of payload oneof is set
	PayloadCase string `json:"payload_case,omitempty"`
}

// IntoPlain converts protobuf message to plain struct
func (pb *TreeNode) IntoPlain() *TreeNodePlain {
	if pb == nil {
		return nil
	}
	p := &TreeNodePlain{}

	// Detect payload oneof case
	switch pb.Payload.(type) {
	case *TreeNode_Text:
		p.PayloadCase = "text"
	case *TreeNode_Image:
		p.PayloadCase = "image"
	case *TreeNode_Code:
		p.PayloadCase = "code"
	}

	p.Id = pb.Id
	p.Name = pb.Name
	p.Type = pb.Type
	if len(pb.Children) > 0 {
		p.Children = make([]TreeNodePlain, len(pb.Children))
		for i, v := range pb.Children {
			if v != nil {
				p.Children[i] = *v.IntoPlain()
			}
		}
	}
	if pb.Parent != nil {
		p.Parent = pb.Parent.IntoPlain()
	}
	// CreatedBy from
	if pb.GetInfo() != nil {
		p.CreatedBy = pb.GetInfo().GetCreatedBy()
	}
	// CreatedAt from
	if pb.GetInfo() != nil {
		p.CreatedAt = pb.GetInfo().GetCreatedAt()
	}
	// ModifiedBy from
	if pb.GetInfo() != nil {
		p.ModifiedBy = pb.GetInfo().GetModifiedBy()
	}
	// ModifiedAt from
	if pb.GetInfo() != nil {
		p.ModifiedAt = pb.GetInfo().GetModifiedAt()
	}
	// Labels from
	if pb.GetInfo() != nil && pb.GetInfo().GetLabels() != nil {
		p.Labels = pb.GetInfo().GetLabels()
	}
	// Tags from
	if pb.GetInfo() != nil {
		p.Tags = pb.GetInfo().GetTags()
	}
	// TextText from text.text
	if pb.GetText() != nil {
		p.TextText = pb.GetText()
	}
	// ImageImage from image.image
	if pb.GetImage() != nil {
		p.ImageImage = pb.GetImage()
	}
	// CodeCode from code.code
	if pb.GetCode() != nil {
		p.CodeCode = pb.GetCode()
	}
	return p
}

// IntoPb converts plain struct to protobuf message
func (p *TreeNodePlain) IntoPb() *TreeNode {
	if p == nil {
		return nil
	}
	pb := &TreeNode{}

	pb.Id = p.Id
	pb.Name = p.Name
	pb.Type = p.Type
	if len(p.Children) > 0 {
		pb.Children = make([]*TreeNode, len(p.Children))
		for i := range p.Children {
			pb.Children[i] = (&p.Children[i]).IntoPb()
		}
	}
	if p.Parent != nil {
		pb.Parent = p.Parent.IntoPb()
	}
	// CreatedBy ->
	if p.CreatedBy != "" {
		if pb.Info == nil {
			pb.Info = &Metadata{}
		}
		pb.Info.CreatedBy = p.CreatedBy
	}
	// CreatedAt ->
	if pb.Info == nil {
		pb.Info = &Metadata{}
	}
	pb.Info.CreatedAt = p.CreatedAt
	// ModifiedBy ->
	if p.ModifiedBy != "" {
		if pb.Info == nil {
			pb.Info = &Metadata{}
		}
		pb.Info.ModifiedBy = p.ModifiedBy
	}
	// ModifiedAt ->
	if pb.Info == nil {
		pb.Info = &Metadata{}
	}
	pb.Info.ModifiedAt = p.ModifiedAt
	// Labels ->
	if pb.Info == nil {
		pb.Info = &Metadata{}
	}
	pb.Info.Labels = p.Labels
	// Tags ->
	if len(p.Tags) > 0 {
		if pb.Info == nil {
			pb.Info = &Metadata{}
		}
		pb.Info.Tags = p.Tags
	}
	// TextText -> text.text
	if p.TextText != nil && p.PayloadCase == "text" {
		pb.Payload = &TreeNode_Text{Text: p.TextText}
	}
	// ImageImage -> image.image
	if p.ImageImage != nil && p.PayloadCase == "image" {
		pb.Payload = &TreeNode_Image{Image: p.ImageImage}
	}
	// CodeCode -> code.code
	if p.CodeCode != nil && p.PayloadCase == "code" {
		pb.Payload = &TreeNode_Code{Code: p.CodeCode}
	}
	return pb
}

// IntoPlainReuse converts protobuf message to existing plain struct (for pool usage)
func (pb *TreeNode) IntoPlainReuse(p *TreeNodePlain) {
	if pb == nil || p == nil {
		return
	}
	// Reset before filling
	p.Reset()

	// Detect payload oneof case
	switch pb.Payload.(type) {
	case *TreeNode_Text:
		p.PayloadCase = "text"
	case *TreeNode_Image:
		p.PayloadCase = "image"
	case *TreeNode_Code:
		p.PayloadCase = "code"
	}

	p.Id = pb.Id
	p.Name = pb.Name
	p.Type = pb.Type
	if len(pb.Children) > 0 {
		p.Children = make([]TreeNodePlain, len(pb.Children))
		for i, v := range pb.Children {
			if v != nil {
				p.Children[i] = *v.IntoPlain()
			}
		}
	}
	if pb.Parent != nil {
		p.Parent = pb.Parent.IntoPlain()
	}
	// CreatedBy from
	if pb.GetInfo() != nil {
		p.CreatedBy = pb.GetInfo().GetCreatedBy()
	}
	// CreatedAt from
	if pb.GetInfo() != nil {
		p.CreatedAt = pb.GetInfo().GetCreatedAt()
	}
	// ModifiedBy from
	if pb.GetInfo() != nil {
		p.ModifiedBy = pb.GetInfo().GetModifiedBy()
	}
	// ModifiedAt from
	if pb.GetInfo() != nil {
		p.ModifiedAt = pb.GetInfo().GetModifiedAt()
	}
	// Labels from
	if pb.GetInfo() != nil && pb.GetInfo().GetLabels() != nil {
		p.Labels = pb.GetInfo().GetLabels()
	}
	// Tags from
	if pb.GetInfo() != nil {
		p.Tags = pb.GetInfo().GetTags()
	}
	// TextText from text.text
	if pb.GetText() != nil {
		p.TextText = pb.GetText()
	}
	// ImageImage from image.image
	if pb.GetImage() != nil {
		p.ImageImage = pb.GetImage()
	}
	// CodeCode from code.code
	if pb.GetCode() != nil {
		p.CodeCode = pb.GetCode()
	}
}

// MarshalJX encodes TreeNodePlain to JSON using jx.Encoder
func (p *TreeNodePlain) MarshalJX(e *jx.Encoder) {
	if p == nil {
		e.Null()
		return
	}

	e.ObjStart()

	if p.PayloadCase != "" {
		e.FieldStart("payload_case")
		e.Str(p.PayloadCase)
	}
	if p.Id != "" {
		e.FieldStart("id")
		e.Str(p.Id)
	}
	if p.Name != "" {
		e.FieldStart("name")
		e.Str(p.Name)
	}
	if p.Type != "" {
		e.FieldStart("type")
		e.Str(p.Type)
	}
	if len(p.Children) > 0 {
		e.FieldStart("children")
		e.ArrStart()
		for _, v := range p.Children {
			(&v).MarshalJX(e)
		}
		e.ArrEnd()
	}
	if p.Parent != nil {
		e.FieldStart("parent")
		p.Parent.MarshalJX(e)
	}
	if p.CreatedBy != "" {
		e.FieldStart("createdBy")
		e.Str(p.CreatedBy)
	}
	if p.CreatedAt != 0 {
		e.FieldStart("createdAt")
		e.Int64(p.CreatedAt)
	}
	if p.ModifiedBy != "" {
		e.FieldStart("modifiedBy")
		e.Str(p.ModifiedBy)
	}
	if p.ModifiedAt != 0 {
		e.FieldStart("modifiedAt")
		e.Int64(p.ModifiedAt)
	}
	e.FieldStart("labels")
	e.ObjStart()
	for k, v := range p.Labels {
		e.FieldStart(k)
		e.Str(v)
	}
	e.ObjEnd()
	if len(p.Tags) > 0 {
		e.FieldStart("tags")
		e.ArrStart()
		for _, v := range p.Tags {
			e.Str(v)
		}
		e.ArrEnd()
	}
	if p.TextText != nil {
		e.FieldStart("textText")
		p.TextText.MarshalJX(e)
	}
	if p.ImageImage != nil {
		e.FieldStart("imageImage")
		p.ImageImage.MarshalJX(e)
	}
	if p.CodeCode != nil {
		e.FieldStart("codeCode")
		p.CodeCode.MarshalJX(e)
	}
	e.ObjEnd()
}

// MarshalJSON implements json.Marshaler using jx
func (p *TreeNodePlain) MarshalJSON() ([]byte, error) {
	e := jx.GetEncoder()
	defer jx.PutEncoder(e)
	p.MarshalJX(e)
	return e.Bytes(), nil
}

// UnmarshalJX decodes TreeNodePlain from JSON using jx.Decoder
func (p *TreeNodePlain) UnmarshalJX(d *jx.Decoder) error {
	if p == nil {
		return nil
	}

	return d.Obj(func(d *jx.Decoder, key string) error {
		switch key {
		case "payload_case":
			v, err := d.Str()
			if err != nil {
				return err
			}
			p.PayloadCase = v
		case "id":
			v, err := d.Str()
			if err != nil {
				return err
			}
			p.Id = v
		case "name":
			v, err := d.Str()
			if err != nil {
				return err
			}
			p.Name = v
		case "type":
			v, err := d.Str()
			if err != nil {
				return err
			}
			p.Type = v
		case "children":
			if err := d.Arr(func(d *jx.Decoder) error {
				var v TreeNodePlain
				if err := v.UnmarshalJX(d); err != nil {
					return err
				}
				p.Children = append(p.Children, v)
				return nil
			}); err != nil {
				return err
			}
		case "parent":
			p.Parent = &TreeNodePlain{}
			if err := p.Parent.UnmarshalJX(d); err != nil {
				return err
			}
		case "createdBy":
			v, err := d.Str()
			if err != nil {
				return err
			}
			p.CreatedBy = v
		case "createdAt":
			v, err := d.Int64()
			if err != nil {
				return err
			}
			p.CreatedAt = v
		case "modifiedBy":
			v, err := d.Str()
			if err != nil {
				return err
			}
			p.ModifiedBy = v
		case "modifiedAt":
			v, err := d.Int64()
			if err != nil {
				return err
			}
			p.ModifiedAt = v
		case "labels":
			if p.Labels == nil {
				p.Labels = make(map[string]string)
			}
			return d.Obj(func(d *jx.Decoder, key string) error {
				v, err := d.Str()
				if err != nil {
					return err
				}
				p.Labels[key] = v
				return nil
			})
		case "tags":
			if err := d.Arr(func(d *jx.Decoder) error {
				v, err := d.Str()
				if err != nil {
					return err
				}
				p.Tags = append(p.Tags, v)
				return nil
			}); err != nil {
				return err
			}
		case "textText":
			p.TextText = &TextContent{}
			if err := p.TextText.UnmarshalJX(d); err != nil {
				return err
			}
		case "imageImage":
			p.ImageImage = &ImageContent{}
			if err := p.ImageImage.UnmarshalJX(d); err != nil {
				return err
			}
		case "codeCode":
			p.CodeCode = &CodeContent{}
			if err := p.CodeCode.UnmarshalJX(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// UnmarshalJSON implements json.Unmarshaler using jx
func (p *TreeNodePlain) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return p.UnmarshalJX(d)
}

// treeNodePlainPool is a sync.Pool for TreeNodePlain objects
var treeNodePlainPool = sync.Pool{
	New: func() interface{} {
		return &TreeNodePlain{}
	},
}

// GetTreeNodePlain returns a TreeNodePlain from the pool
func GetTreeNodePlain() *TreeNodePlain {
	return treeNodePlainPool.Get().(*TreeNodePlain)
}

// PutTreeNodePlain returns a TreeNodePlain to the pool after resetting it
func PutTreeNodePlain(p *TreeNodePlain) {
	if p == nil {
		return
	}
	p.Reset()
	treeNodePlainPool.Put(p)
}

// Reset clears all fields in TreeNodePlain for reuse
func (p *TreeNodePlain) Reset() {
	if p == nil {
		return
	}

	p.PayloadCase = ""
	p.Id = ""
	p.Name = ""
	p.Type = ""
	p.Children = p.Children[:0]
	p.Parent = nil
	p.CreatedBy = ""
	p.CreatedAt = 0
	p.ModifiedBy = ""
	p.ModifiedAt = 0
	for k := range p.Labels {
		delete(p.Labels, k)
	}
	p.Tags = p.Tags[:0]
	p.TextText = nil
	p.ImageImage = nil
	p.CodeCode = nil
}

type EventPlain struct {
	EventId                      string               `json:"eventId"`
	EventType                    string               `json:"eventType"`
	Timestamp                    int64                `json:"timestamp"`
	Source                       string               `json:"source"`
	Meta                         *Metadata            `json:"meta"`
	UserCreatedUserCreated       *UserCreatedEvent    `json:"userCreatedUserCreated"`       // origin: oneof_embed, empath: user_created.user_created
	UserUpdatedUserUpdated       *UserUpdatedEvent    `json:"userUpdatedUserUpdated"`       // origin: oneof_embed, empath: user_updated.user_updated
	UserDeletedUserDeleted       *UserDeletedEvent    `json:"userDeletedUserDeleted"`       // origin: oneof_embed, empath: user_deleted.user_deleted
	OrderCreatedOrderCreated     *OrderCreatedEvent   `json:"orderCreatedOrderCreated"`     // origin: oneof_embed, empath: order_created.order_created
	OrderCompletedOrderCompleted *OrderCompletedEvent `json:"orderCompletedOrderCompleted"` // origin: oneof_embed, empath: order_completed.order_completed
	// PayloadCase indicates which variant of payload oneof is set
	PayloadCase string `json:"payload_case,omitempty"`
}

// IntoPlain converts protobuf message to plain struct
func (pb *Event) IntoPlain() *EventPlain {
	if pb == nil {
		return nil
	}
	p := &EventPlain{}

	// Detect payload oneof case
	switch pb.Payload.(type) {
	case *Event_UserCreated:
		p.PayloadCase = "user_created"
	case *Event_UserUpdated:
		p.PayloadCase = "user_updated"
	case *Event_UserDeleted:
		p.PayloadCase = "user_deleted"
	case *Event_OrderCreated:
		p.PayloadCase = "order_created"
	case *Event_OrderCompleted:
		p.PayloadCase = "order_completed"
	}

	p.EventId = pb.EventId
	p.EventType = pb.EventType
	p.Timestamp = pb.Timestamp
	p.Source = pb.Source
	p.Meta = pb.Meta
	// UserCreatedUserCreated from user_created.user_created
	if pb.GetUserCreated() != nil {
		p.UserCreatedUserCreated = pb.GetUserCreated()
	}
	// UserUpdatedUserUpdated from user_updated.user_updated
	if pb.GetUserUpdated() != nil {
		p.UserUpdatedUserUpdated = pb.GetUserUpdated()
	}
	// UserDeletedUserDeleted from user_deleted.user_deleted
	if pb.GetUserDeleted() != nil {
		p.UserDeletedUserDeleted = pb.GetUserDeleted()
	}
	// OrderCreatedOrderCreated from order_created.order_created
	if pb.GetOrderCreated() != nil {
		p.OrderCreatedOrderCreated = pb.GetOrderCreated()
	}
	// OrderCompletedOrderCompleted from order_completed.order_completed
	if pb.GetOrderCompleted() != nil {
		p.OrderCompletedOrderCompleted = pb.GetOrderCompleted()
	}
	return p
}

// IntoPb converts plain struct to protobuf message
func (p *EventPlain) IntoPb() *Event {
	if p == nil {
		return nil
	}
	pb := &Event{}

	pb.EventId = p.EventId
	pb.EventType = p.EventType
	pb.Timestamp = p.Timestamp
	pb.Source = p.Source
	pb.Meta = p.Meta
	// UserCreatedUserCreated -> user_created.user_created
	if p.UserCreatedUserCreated != nil && p.PayloadCase == "user_created" {
		pb.Payload = &Event_UserCreated{UserCreated: p.UserCreatedUserCreated}
	}
	// UserUpdatedUserUpdated -> user_updated.user_updated
	if p.UserUpdatedUserUpdated != nil && p.PayloadCase == "user_updated" {
		pb.Payload = &Event_UserUpdated{UserUpdated: p.UserUpdatedUserUpdated}
	}
	// UserDeletedUserDeleted -> user_deleted.user_deleted
	if p.UserDeletedUserDeleted != nil && p.PayloadCase == "user_deleted" {
		pb.Payload = &Event_UserDeleted{UserDeleted: p.UserDeletedUserDeleted}
	}
	// OrderCreatedOrderCreated -> order_created.order_created
	if p.OrderCreatedOrderCreated != nil && p.PayloadCase == "order_created" {
		pb.Payload = &Event_OrderCreated{OrderCreated: p.OrderCreatedOrderCreated}
	}
	// OrderCompletedOrderCompleted -> order_completed.order_completed
	if p.OrderCompletedOrderCompleted != nil && p.PayloadCase == "order_completed" {
		pb.Payload = &Event_OrderCompleted{OrderCompleted: p.OrderCompletedOrderCompleted}
	}
	return pb
}

// IntoPlainReuse converts protobuf message to existing plain struct (for pool usage)
func (pb *Event) IntoPlainReuse(p *EventPlain) {
	if pb == nil || p == nil {
		return
	}
	// Reset before filling
	p.Reset()

	// Detect payload oneof case
	switch pb.Payload.(type) {
	case *Event_UserCreated:
		p.PayloadCase = "user_created"
	case *Event_UserUpdated:
		p.PayloadCase = "user_updated"
	case *Event_UserDeleted:
		p.PayloadCase = "user_deleted"
	case *Event_OrderCreated:
		p.PayloadCase = "order_created"
	case *Event_OrderCompleted:
		p.PayloadCase = "order_completed"
	}

	p.EventId = pb.EventId
	p.EventType = pb.EventType
	p.Timestamp = pb.Timestamp
	p.Source = pb.Source
	p.Meta = pb.Meta
	// UserCreatedUserCreated from user_created.user_created
	if pb.GetUserCreated() != nil {
		p.UserCreatedUserCreated = pb.GetUserCreated()
	}
	// UserUpdatedUserUpdated from user_updated.user_updated
	if pb.GetUserUpdated() != nil {
		p.UserUpdatedUserUpdated = pb.GetUserUpdated()
	}
	// UserDeletedUserDeleted from user_deleted.user_deleted
	if pb.GetUserDeleted() != nil {
		p.UserDeletedUserDeleted = pb.GetUserDeleted()
	}
	// OrderCreatedOrderCreated from order_created.order_created
	if pb.GetOrderCreated() != nil {
		p.OrderCreatedOrderCreated = pb.GetOrderCreated()
	}
	// OrderCompletedOrderCompleted from order_completed.order_completed
	if pb.GetOrderCompleted() != nil {
		p.OrderCompletedOrderCompleted = pb.GetOrderCompleted()
	}
}

// MarshalJX encodes EventPlain to JSON using jx.Encoder
func (p *EventPlain) MarshalJX(e *jx.Encoder) {
	if p == nil {
		e.Null()
		return
	}

	e.ObjStart()

	if p.PayloadCase != "" {
		e.FieldStart("payload_case")
		e.Str(p.PayloadCase)
	}
	if p.EventId != "" {
		e.FieldStart("eventId")
		e.Str(p.EventId)
	}
	if p.EventType != "" {
		e.FieldStart("eventType")
		e.Str(p.EventType)
	}
	if p.Timestamp != 0 {
		e.FieldStart("timestamp")
		e.Int64(p.Timestamp)
	}
	if p.Source != "" {
		e.FieldStart("source")
		e.Str(p.Source)
	}
	if p.Meta != nil {
		e.FieldStart("meta")
		p.Meta.MarshalJX(e)
	}
	if p.UserCreatedUserCreated != nil {
		e.FieldStart("userCreatedUserCreated")
		p.UserCreatedUserCreated.MarshalJX(e)
	}
	if p.UserUpdatedUserUpdated != nil {
		e.FieldStart("userUpdatedUserUpdated")
		p.UserUpdatedUserUpdated.MarshalJX(e)
	}
	if p.UserDeletedUserDeleted != nil {
		e.FieldStart("userDeletedUserDeleted")
		p.UserDeletedUserDeleted.MarshalJX(e)
	}
	if p.OrderCreatedOrderCreated != nil {
		e.FieldStart("orderCreatedOrderCreated")
		p.OrderCreatedOrderCreated.MarshalJX(e)
	}
	if p.OrderCompletedOrderCompleted != nil {
		e.FieldStart("orderCompletedOrderCompleted")
		p.OrderCompletedOrderCompleted.MarshalJX(e)
	}
	e.ObjEnd()
}

// MarshalJSON implements json.Marshaler using jx
func (p *EventPlain) MarshalJSON() ([]byte, error) {
	e := jx.GetEncoder()
	defer jx.PutEncoder(e)
	p.MarshalJX(e)
	return e.Bytes(), nil
}

// UnmarshalJX decodes EventPlain from JSON using jx.Decoder
func (p *EventPlain) UnmarshalJX(d *jx.Decoder) error {
	if p == nil {
		return nil
	}

	return d.Obj(func(d *jx.Decoder, key string) error {
		switch key {
		case "payload_case":
			v, err := d.Str()
			if err != nil {
				return err
			}
			p.PayloadCase = v
		case "eventId":
			v, err := d.Str()
			if err != nil {
				return err
			}
			p.EventId = v
		case "eventType":
			v, err := d.Str()
			if err != nil {
				return err
			}
			p.EventType = v
		case "timestamp":
			v, err := d.Int64()
			if err != nil {
				return err
			}
			p.Timestamp = v
		case "source":
			v, err := d.Str()
			if err != nil {
				return err
			}
			p.Source = v
		case "meta":
			p.Meta = &Metadata{}
			if err := p.Meta.UnmarshalJX(d); err != nil {
				return err
			}
		case "userCreatedUserCreated":
			p.UserCreatedUserCreated = &UserCreatedEvent{}
			if err := p.UserCreatedUserCreated.UnmarshalJX(d); err != nil {
				return err
			}
		case "userUpdatedUserUpdated":
			p.UserUpdatedUserUpdated = &UserUpdatedEvent{}
			if err := p.UserUpdatedUserUpdated.UnmarshalJX(d); err != nil {
				return err
			}
		case "userDeletedUserDeleted":
			p.UserDeletedUserDeleted = &UserDeletedEvent{}
			if err := p.UserDeletedUserDeleted.UnmarshalJX(d); err != nil {
				return err
			}
		case "orderCreatedOrderCreated":
			p.OrderCreatedOrderCreated = &OrderCreatedEvent{}
			if err := p.OrderCreatedOrderCreated.UnmarshalJX(d); err != nil {
				return err
			}
		case "orderCompletedOrderCompleted":
			p.OrderCompletedOrderCompleted = &OrderCompletedEvent{}
			if err := p.OrderCompletedOrderCompleted.UnmarshalJX(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// UnmarshalJSON implements json.Unmarshaler using jx
func (p *EventPlain) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return p.UnmarshalJX(d)
}

// eventPlainPool is a sync.Pool for EventPlain objects
var eventPlainPool = sync.Pool{
	New: func() interface{} {
		return &EventPlain{}
	},
}

// GetEventPlain returns a EventPlain from the pool
func GetEventPlain() *EventPlain {
	return eventPlainPool.Get().(*EventPlain)
}

// PutEventPlain returns a EventPlain to the pool after resetting it
func PutEventPlain(p *EventPlain) {
	if p == nil {
		return
	}
	p.Reset()
	eventPlainPool.Put(p)
}

// Reset clears all fields in EventPlain for reuse
func (p *EventPlain) Reset() {
	if p == nil {
		return
	}

	p.PayloadCase = ""
	p.EventId = ""
	p.EventType = ""
	p.Timestamp = 0
	p.Source = ""
	p.Meta = nil
	p.UserCreatedUserCreated = nil
	p.UserUpdatedUserUpdated = nil
	p.UserDeletedUserDeleted = nil
	p.OrderCreatedOrderCreated = nil
	p.OrderCompletedOrderCompleted = nil
}

type ConfigPlain struct {
	DoubleVal        float64                         `json:"doubleVal"`
	FloatVal         float32                         `json:"floatVal"`
	Int32Val         int32                           `json:"int32Val"`
	Int64Val         int64                           `json:"int64Val"`
	Uint32Val        uint32                          `json:"uint32Val"`
	Uint64Val        uint64                          `json:"uint64Val"`
	Sint32Val        int32                           `json:"sint32Val"`
	Sint64Val        int64                           `json:"sint64Val"`
	Fixed32Val       uint32                          `json:"fixed32Val"`
	Fixed64Val       uint64                          `json:"fixed64Val"`
	Sfixed32Val      int32                           `json:"sfixed32Val"`
	Sfixed64Val      int64                           `json:"sfixed64Val"`
	BoolVal          bool                            `json:"boolVal"`
	StringVal        string                          `json:"stringVal"`
	BytesVal         []byte                          `json:"bytesVal"`
	OptionalString   string                          `json:"optionalString,omitempty"`
	OptionalInt      int32                           `json:"optionalInt,omitempty"`
	OptionalBool     bool                            `json:"optionalBool,omitempty"`
	OptionalDouble   float64                         `json:"optionalDouble,omitempty"`
	OptionalBytes    []byte                          `json:"optionalBytes,omitempty"`
	StringList       []string                        `json:"stringList"`
	IntList          []int32                         `json:"intList"`
	DoubleList       []float64                       `json:"doubleList"`
	BytesList        [][]byte                        `json:"bytesList"`
	BoolList         []bool                          `json:"boolList"`
	FloatList        []float32                       `json:"floatList"`
	Int64List        []int64                         `json:"int64List"`
	Uint32List       []uint32                        `json:"uint32List"`
	Uint64List       []uint64                        `json:"uint64List"`
	StringMap        map[string]string               `json:"stringMap"`
	IntMap           map[string]int32                `json:"intMap"`
	IntKeyMap        map[int32]string                `json:"intKeyMap"`
	NestedMap        map[string]*ConfigPlain         `json:"nestedMap"`
	Int64KeyMap      map[int64]string                `json:"int64KeyMap"`
	Uint32KeyMap     map[uint32]string               `json:"uint32KeyMap"`
	Uint64KeyMap     map[uint64]string               `json:"uint64KeyMap"`
	Sint32KeyMap     map[int32]string                `json:"sint32KeyMap"`
	Sint64KeyMap     map[int64]string                `json:"sint64KeyMap"`
	Fixed32KeyMap    map[uint32]string               `json:"fixed32KeyMap"`
	Fixed64KeyMap    map[uint64]string               `json:"fixed64KeyMap"`
	Sfixed32KeyMap   map[int32]string                `json:"sfixed32KeyMap"`
	Sfixed64KeyMap   map[int64]string                `json:"sfixed64KeyMap"`
	BoolKeyMap       map[bool]string                 `json:"boolKeyMap"`
	DoubleMap        map[string]float64              `json:"doubleMap"`
	BytesMap         map[string][]byte               `json:"bytesMap"`
	BoolMap          map[string]bool                 `json:"boolMap"`
	FloatMap         map[string]float32              `json:"floatMap"`
	Status           Status                          `json:"status"`
	StatusList       []Status                        `json:"statusList"`
	StatusMap        map[string]Status               `json:"statusMap"`
	OptionalStatus   Status                          `json:"optionalStatus,omitempty"`
	NestedEnum       Config_NestedEnum               `json:"nestedEnum"`
	NestedEnumList   []Config_NestedEnum             `json:"nestedEnumList"`
	NestedConfig     *Config_NestedConfig            `json:"nestedConfig"`
	NestedConfigList []*Config_NestedConfig          `json:"nestedConfigList"`
	NestedConfigMap  map[string]*Config_NestedConfig `json:"nestedConfigMap"`
	Parent           *ConfigPlain                    `json:"parent"`
	Children         []ConfigPlain                   `json:"children"`
}

// IntoPlain converts protobuf message to plain struct
func (pb *Config) IntoPlain() *ConfigPlain {
	if pb == nil {
		return nil
	}
	p := &ConfigPlain{}

	p.DoubleVal = pb.DoubleVal
	p.FloatVal = pb.FloatVal
	p.Int32Val = pb.Int32Val
	p.Int64Val = pb.Int64Val
	p.Uint32Val = pb.Uint32Val
	p.Uint64Val = pb.Uint64Val
	p.Sint32Val = pb.Sint32Val
	p.Sint64Val = pb.Sint64Val
	p.Fixed32Val = pb.Fixed32Val
	p.Fixed64Val = pb.Fixed64Val
	p.Sfixed32Val = pb.Sfixed32Val
	p.Sfixed64Val = pb.Sfixed64Val
	p.BoolVal = pb.BoolVal
	p.StringVal = pb.StringVal
	p.BytesVal = pb.BytesVal
	if pb.OptionalString != nil {
		p.OptionalString = *pb.OptionalString
	}
	if pb.OptionalInt != nil {
		p.OptionalInt = *pb.OptionalInt
	}
	if pb.OptionalBool != nil {
		p.OptionalBool = *pb.OptionalBool
	}
	if pb.OptionalDouble != nil {
		p.OptionalDouble = *pb.OptionalDouble
	}
	p.OptionalBytes = pb.OptionalBytes
	p.StringList = pb.StringList
	p.IntList = pb.IntList
	p.DoubleList = pb.DoubleList
	p.BytesList = pb.BytesList
	p.BoolList = pb.BoolList
	p.FloatList = pb.FloatList
	p.Int64List = pb.Int64List
	p.Uint32List = pb.Uint32List
	p.Uint64List = pb.Uint64List
	p.StringMap = pb.StringMap
	p.IntMap = pb.IntMap
	p.IntKeyMap = pb.IntKeyMap
	if len(pb.NestedMap) > 0 {
		p.NestedMap = make(map[string]*ConfigPlain, len(pb.NestedMap))
		for k, v := range pb.NestedMap {
			if v != nil {
				p.NestedMap[k] = v.IntoPlain()
			}
		}
	}
	p.Int64KeyMap = pb.Int64KeyMap
	p.Uint32KeyMap = pb.Uint32KeyMap
	p.Uint64KeyMap = pb.Uint64KeyMap
	p.Sint32KeyMap = pb.Sint32KeyMap
	p.Sint64KeyMap = pb.Sint64KeyMap
	p.Fixed32KeyMap = pb.Fixed32KeyMap
	p.Fixed64KeyMap = pb.Fixed64KeyMap
	p.Sfixed32KeyMap = pb.Sfixed32KeyMap
	p.Sfixed64KeyMap = pb.Sfixed64KeyMap
	p.BoolKeyMap = pb.BoolKeyMap
	p.DoubleMap = pb.DoubleMap
	p.BytesMap = pb.BytesMap
	p.BoolMap = pb.BoolMap
	p.FloatMap = pb.FloatMap
	p.Status = pb.Status
	p.StatusList = pb.StatusList
	p.StatusMap = pb.StatusMap
	if pb.OptionalStatus != nil {
		p.OptionalStatus = *pb.OptionalStatus
	}
	p.NestedEnum = pb.NestedEnum
	p.NestedEnumList = pb.NestedEnumList
	p.NestedConfig = pb.NestedConfig
	p.NestedConfigList = pb.NestedConfigList
	p.NestedConfigMap = pb.NestedConfigMap
	if pb.Parent != nil {
		p.Parent = pb.Parent.IntoPlain()
	}
	if len(pb.Children) > 0 {
		p.Children = make([]ConfigPlain, len(pb.Children))
		for i, v := range pb.Children {
			if v != nil {
				p.Children[i] = *v.IntoPlain()
			}
		}
	}
	return p
}

// IntoPb converts plain struct to protobuf message
func (p *ConfigPlain) IntoPb() *Config {
	if p == nil {
		return nil
	}
	pb := &Config{}

	pb.DoubleVal = p.DoubleVal
	pb.FloatVal = p.FloatVal
	pb.Int32Val = p.Int32Val
	pb.Int64Val = p.Int64Val
	pb.Uint32Val = p.Uint32Val
	pb.Uint64Val = p.Uint64Val
	pb.Sint32Val = p.Sint32Val
	pb.Sint64Val = p.Sint64Val
	pb.Fixed32Val = p.Fixed32Val
	pb.Fixed64Val = p.Fixed64Val
	pb.Sfixed32Val = p.Sfixed32Val
	pb.Sfixed64Val = p.Sfixed64Val
	pb.BoolVal = p.BoolVal
	pb.StringVal = p.StringVal
	pb.BytesVal = p.BytesVal
	if p.OptionalString != "" {
		pb.OptionalString = &p.OptionalString
	}
	pb.OptionalInt = &p.OptionalInt
	pb.OptionalBool = &p.OptionalBool
	pb.OptionalDouble = &p.OptionalDouble
	pb.OptionalBytes = p.OptionalBytes
	pb.StringList = p.StringList
	pb.IntList = p.IntList
	pb.DoubleList = p.DoubleList
	pb.BytesList = p.BytesList
	pb.BoolList = p.BoolList
	pb.FloatList = p.FloatList
	pb.Int64List = p.Int64List
	pb.Uint32List = p.Uint32List
	pb.Uint64List = p.Uint64List
	pb.StringMap = p.StringMap
	pb.IntMap = p.IntMap
	pb.IntKeyMap = p.IntKeyMap
	if len(p.NestedMap) > 0 {
		pb.NestedMap = make(map[string]*Config, len(p.NestedMap))
		for k, v := range p.NestedMap {
			if v != nil {
				pb.NestedMap[k] = v.IntoPb()
			}
		}
	}
	pb.Int64KeyMap = p.Int64KeyMap
	pb.Uint32KeyMap = p.Uint32KeyMap
	pb.Uint64KeyMap = p.Uint64KeyMap
	pb.Sint32KeyMap = p.Sint32KeyMap
	pb.Sint64KeyMap = p.Sint64KeyMap
	pb.Fixed32KeyMap = p.Fixed32KeyMap
	pb.Fixed64KeyMap = p.Fixed64KeyMap
	pb.Sfixed32KeyMap = p.Sfixed32KeyMap
	pb.Sfixed64KeyMap = p.Sfixed64KeyMap
	pb.BoolKeyMap = p.BoolKeyMap
	pb.DoubleMap = p.DoubleMap
	pb.BytesMap = p.BytesMap
	pb.BoolMap = p.BoolMap
	pb.FloatMap = p.FloatMap
	pb.Status = p.Status
	pb.StatusList = p.StatusList
	pb.StatusMap = p.StatusMap
	pb.OptionalStatus = &p.OptionalStatus
	pb.NestedEnum = p.NestedEnum
	pb.NestedEnumList = p.NestedEnumList
	pb.NestedConfig = p.NestedConfig
	pb.NestedConfigList = p.NestedConfigList
	pb.NestedConfigMap = p.NestedConfigMap
	if p.Parent != nil {
		pb.Parent = p.Parent.IntoPb()
	}
	if len(p.Children) > 0 {
		pb.Children = make([]*Config, len(p.Children))
		for i := range p.Children {
			pb.Children[i] = (&p.Children[i]).IntoPb()
		}
	}
	return pb
}

// IntoPlainReuse converts protobuf message to existing plain struct (for pool usage)
func (pb *Config) IntoPlainReuse(p *ConfigPlain) {
	if pb == nil || p == nil {
		return
	}
	// Reset before filling
	p.Reset()

	p.DoubleVal = pb.DoubleVal
	p.FloatVal = pb.FloatVal
	p.Int32Val = pb.Int32Val
	p.Int64Val = pb.Int64Val
	p.Uint32Val = pb.Uint32Val
	p.Uint64Val = pb.Uint64Val
	p.Sint32Val = pb.Sint32Val
	p.Sint64Val = pb.Sint64Val
	p.Fixed32Val = pb.Fixed32Val
	p.Fixed64Val = pb.Fixed64Val
	p.Sfixed32Val = pb.Sfixed32Val
	p.Sfixed64Val = pb.Sfixed64Val
	p.BoolVal = pb.BoolVal
	p.StringVal = pb.StringVal
	p.BytesVal = pb.BytesVal
	if pb.OptionalString != nil {
		p.OptionalString = *pb.OptionalString
	}
	if pb.OptionalInt != nil {
		p.OptionalInt = *pb.OptionalInt
	}
	if pb.OptionalBool != nil {
		p.OptionalBool = *pb.OptionalBool
	}
	if pb.OptionalDouble != nil {
		p.OptionalDouble = *pb.OptionalDouble
	}
	p.OptionalBytes = pb.OptionalBytes
	p.StringList = pb.StringList
	p.IntList = pb.IntList
	p.DoubleList = pb.DoubleList
	p.BytesList = pb.BytesList
	p.BoolList = pb.BoolList
	p.FloatList = pb.FloatList
	p.Int64List = pb.Int64List
	p.Uint32List = pb.Uint32List
	p.Uint64List = pb.Uint64List
	p.StringMap = pb.StringMap
	p.IntMap = pb.IntMap
	p.IntKeyMap = pb.IntKeyMap
	if len(pb.NestedMap) > 0 {
		p.NestedMap = make(map[string]*ConfigPlain, len(pb.NestedMap))
		for k, v := range pb.NestedMap {
			if v != nil {
				p.NestedMap[k] = v.IntoPlain()
			}
		}
	}
	p.Int64KeyMap = pb.Int64KeyMap
	p.Uint32KeyMap = pb.Uint32KeyMap
	p.Uint64KeyMap = pb.Uint64KeyMap
	p.Sint32KeyMap = pb.Sint32KeyMap
	p.Sint64KeyMap = pb.Sint64KeyMap
	p.Fixed32KeyMap = pb.Fixed32KeyMap
	p.Fixed64KeyMap = pb.Fixed64KeyMap
	p.Sfixed32KeyMap = pb.Sfixed32KeyMap
	p.Sfixed64KeyMap = pb.Sfixed64KeyMap
	p.BoolKeyMap = pb.BoolKeyMap
	p.DoubleMap = pb.DoubleMap
	p.BytesMap = pb.BytesMap
	p.BoolMap = pb.BoolMap
	p.FloatMap = pb.FloatMap
	p.Status = pb.Status
	p.StatusList = pb.StatusList
	p.StatusMap = pb.StatusMap
	if pb.OptionalStatus != nil {
		p.OptionalStatus = *pb.OptionalStatus
	}
	p.NestedEnum = pb.NestedEnum
	p.NestedEnumList = pb.NestedEnumList
	p.NestedConfig = pb.NestedConfig
	p.NestedConfigList = pb.NestedConfigList
	p.NestedConfigMap = pb.NestedConfigMap
	if pb.Parent != nil {
		p.Parent = pb.Parent.IntoPlain()
	}
	if len(pb.Children) > 0 {
		p.Children = make([]ConfigPlain, len(pb.Children))
		for i, v := range pb.Children {
			if v != nil {
				p.Children[i] = *v.IntoPlain()
			}
		}
	}
}

// MarshalJX encodes ConfigPlain to JSON using jx.Encoder
func (p *ConfigPlain) MarshalJX(e *jx.Encoder) {
	if p == nil {
		e.Null()
		return
	}

	e.ObjStart()

	if p.DoubleVal != 0 {
		e.FieldStart("doubleVal")
		e.Float64(p.DoubleVal)
	}
	if p.FloatVal != 0 {
		e.FieldStart("floatVal")
		e.Float32(p.FloatVal)
	}
	if p.Int32Val != 0 {
		e.FieldStart("int32Val")
		e.Int32(p.Int32Val)
	}
	if p.Int64Val != 0 {
		e.FieldStart("int64Val")
		e.Int64(p.Int64Val)
	}
	if p.Uint32Val != 0 {
		e.FieldStart("uint32Val")
		e.UInt32(p.Uint32Val)
	}
	if p.Uint64Val != 0 {
		e.FieldStart("uint64Val")
		e.UInt64(p.Uint64Val)
	}
	if p.Sint32Val != 0 {
		e.FieldStart("sint32Val")
		e.Int32(p.Sint32Val)
	}
	if p.Sint64Val != 0 {
		e.FieldStart("sint64Val")
		e.Int64(p.Sint64Val)
	}
	if p.Fixed32Val != 0 {
		e.FieldStart("fixed32Val")
		e.UInt32(p.Fixed32Val)
	}
	if p.Fixed64Val != 0 {
		e.FieldStart("fixed64Val")
		e.UInt64(p.Fixed64Val)
	}
	if p.Sfixed32Val != 0 {
		e.FieldStart("sfixed32Val")
		e.Int32(p.Sfixed32Val)
	}
	if p.Sfixed64Val != 0 {
		e.FieldStart("sfixed64Val")
		e.Int64(p.Sfixed64Val)
	}
	if p.BoolVal {
		e.FieldStart("boolVal")
		e.Bool(p.BoolVal)
	}
	if p.StringVal != "" {
		e.FieldStart("stringVal")
		e.Str(p.StringVal)
	}
	if len(p.BytesVal) > 0 {
		e.FieldStart("bytesVal")
		e.Base64(p.BytesVal)
	}
	if p.OptionalString != "" {
		e.FieldStart("optionalString")
		e.Str(p.OptionalString)
	}
	if p.OptionalInt != 0 {
		e.FieldStart("optionalInt")
		e.Int32(p.OptionalInt)
	}
	if p.OptionalBool {
		e.FieldStart("optionalBool")
		e.Bool(p.OptionalBool)
	}
	if p.OptionalDouble != 0 {
		e.FieldStart("optionalDouble")
		e.Float64(p.OptionalDouble)
	}
	if len(p.OptionalBytes) > 0 {
		e.FieldStart("optionalBytes")
		e.Base64(p.OptionalBytes)
	}
	if len(p.StringList) > 0 {
		e.FieldStart("stringList")
		e.ArrStart()
		for _, v := range p.StringList {
			e.Str(v)
		}
		e.ArrEnd()
	}
	if len(p.IntList) > 0 {
		e.FieldStart("intList")
		e.ArrStart()
		for _, v := range p.IntList {
			e.Int32(v)
		}
		e.ArrEnd()
	}
	if len(p.DoubleList) > 0 {
		e.FieldStart("doubleList")
		e.ArrStart()
		for _, v := range p.DoubleList {
			e.Float64(v)
		}
		e.ArrEnd()
	}
	if len(p.BytesList) > 0 {
		e.FieldStart("bytesList")
		e.ArrStart()
		for _, v := range p.BytesList {
			e.Base64(v)
		}
		e.ArrEnd()
	}
	if len(p.BoolList) > 0 {
		e.FieldStart("boolList")
		e.ArrStart()
		for _, v := range p.BoolList {
			e.Bool(v)
		}
		e.ArrEnd()
	}
	if len(p.FloatList) > 0 {
		e.FieldStart("floatList")
		e.ArrStart()
		for _, v := range p.FloatList {
			e.Float32(v)
		}
		e.ArrEnd()
	}
	if len(p.Int64List) > 0 {
		e.FieldStart("int64List")
		e.ArrStart()
		for _, v := range p.Int64List {
			e.Int64(v)
		}
		e.ArrEnd()
	}
	if len(p.Uint32List) > 0 {
		e.FieldStart("uint32List")
		e.ArrStart()
		for _, v := range p.Uint32List {
			e.UInt32(v)
		}
		e.ArrEnd()
	}
	if len(p.Uint64List) > 0 {
		e.FieldStart("uint64List")
		e.ArrStart()
		for _, v := range p.Uint64List {
			e.UInt64(v)
		}
		e.ArrEnd()
	}
	e.FieldStart("stringMap")
	e.ObjStart()
	for k, v := range p.StringMap {
		e.FieldStart(k)
		e.Str(v)
	}
	e.ObjEnd()
	e.FieldStart("intMap")
	e.ObjStart()
	for k, v := range p.IntMap {
		e.FieldStart(k)
		e.Int32(v)
	}
	e.ObjEnd()
	e.FieldStart("intKeyMap")
	e.ObjStart()
	for k, v := range p.IntKeyMap {
		e.FieldStart(fmt.Sprint(k))
		e.Str(v)
	}
	e.ObjEnd()
	e.FieldStart("nestedMap")
	e.ObjStart()
	for k, v := range p.NestedMap {
		e.FieldStart(k)
		v.MarshalJX(e)
	}
	e.ObjEnd()
	e.FieldStart("int64KeyMap")
	e.ObjStart()
	for k, v := range p.Int64KeyMap {
		e.FieldStart(fmt.Sprint(k))
		e.Str(v)
	}
	e.ObjEnd()
	e.FieldStart("uint32KeyMap")
	e.ObjStart()
	for k, v := range p.Uint32KeyMap {
		e.FieldStart(fmt.Sprint(k))
		e.Str(v)
	}
	e.ObjEnd()
	e.FieldStart("uint64KeyMap")
	e.ObjStart()
	for k, v := range p.Uint64KeyMap {
		e.FieldStart(fmt.Sprint(k))
		e.Str(v)
	}
	e.ObjEnd()
	e.FieldStart("sint32KeyMap")
	e.ObjStart()
	for k, v := range p.Sint32KeyMap {
		e.FieldStart(fmt.Sprint(k))
		e.Str(v)
	}
	e.ObjEnd()
	e.FieldStart("sint64KeyMap")
	e.ObjStart()
	for k, v := range p.Sint64KeyMap {
		e.FieldStart(fmt.Sprint(k))
		e.Str(v)
	}
	e.ObjEnd()
	e.FieldStart("fixed32KeyMap")
	e.ObjStart()
	for k, v := range p.Fixed32KeyMap {
		e.FieldStart(fmt.Sprint(k))
		e.Str(v)
	}
	e.ObjEnd()
	e.FieldStart("fixed64KeyMap")
	e.ObjStart()
	for k, v := range p.Fixed64KeyMap {
		e.FieldStart(fmt.Sprint(k))
		e.Str(v)
	}
	e.ObjEnd()
	e.FieldStart("sfixed32KeyMap")
	e.ObjStart()
	for k, v := range p.Sfixed32KeyMap {
		e.FieldStart(fmt.Sprint(k))
		e.Str(v)
	}
	e.ObjEnd()
	e.FieldStart("sfixed64KeyMap")
	e.ObjStart()
	for k, v := range p.Sfixed64KeyMap {
		e.FieldStart(fmt.Sprint(k))
		e.Str(v)
	}
	e.ObjEnd()
	e.FieldStart("boolKeyMap")
	e.ObjStart()
	for k, v := range p.BoolKeyMap {
		e.FieldStart(fmt.Sprint(k))
		e.Str(v)
	}
	e.ObjEnd()
	e.FieldStart("doubleMap")
	e.ObjStart()
	for k, v := range p.DoubleMap {
		e.FieldStart(k)
		e.Float64(v)
	}
	e.ObjEnd()
	e.FieldStart("bytesMap")
	e.ObjStart()
	for k, v := range p.BytesMap {
		e.FieldStart(k)
		e.Base64(v)
	}
	e.ObjEnd()
	e.FieldStart("boolMap")
	e.ObjStart()
	for k, v := range p.BoolMap {
		e.FieldStart(k)
		e.Bool(v)
	}
	e.ObjEnd()
	e.FieldStart("floatMap")
	e.ObjStart()
	for k, v := range p.FloatMap {
		e.FieldStart(k)
		e.Float32(v)
	}
	e.ObjEnd()
	e.FieldStart("status")
	e.Int32(int32(p.Status))
	if len(p.StatusList) > 0 {
		e.FieldStart("statusList")
		e.ArrStart()
		for _, v := range p.StatusList {
			e.Int32(int32(v))
		}
		e.ArrEnd()
	}
	e.FieldStart("statusMap")
	e.ObjStart()
	for k, v := range p.StatusMap {
		e.FieldStart(k)
		e.Int32(int32(v))
	}
	e.ObjEnd()
	e.FieldStart("optionalStatus")
	e.Int32(int32(p.OptionalStatus))
	e.FieldStart("nestedEnum")
	e.Int32(int32(p.NestedEnum))
	if len(p.NestedEnumList) > 0 {
		e.FieldStart("nestedEnumList")
		e.ArrStart()
		for _, v := range p.NestedEnumList {
			e.Int32(int32(v))
		}
		e.ArrEnd()
	}
	if p.NestedConfig != nil {
		e.FieldStart("nestedConfig")
		p.NestedConfig.MarshalJX(e)
	}
	if p.NestedConfigList != nil {
		e.FieldStart("nestedConfigList")
		e.ArrStart()
		for _, v := range p.NestedConfigList {
			v.MarshalJX(e)
		}
		e.ArrEnd()
	}
	e.FieldStart("nestedConfigMap")
	e.ObjStart()
	for k, v := range p.NestedConfigMap {
		e.FieldStart(k)
		v.MarshalJX(e)
	}
	e.ObjEnd()
	if p.Parent != nil {
		e.FieldStart("parent")
		p.Parent.MarshalJX(e)
	}
	if len(p.Children) > 0 {
		e.FieldStart("children")
		e.ArrStart()
		for _, v := range p.Children {
			(&v).MarshalJX(e)
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

// MarshalJSON implements json.Marshaler using jx
func (p *ConfigPlain) MarshalJSON() ([]byte, error) {
	e := jx.GetEncoder()
	defer jx.PutEncoder(e)
	p.MarshalJX(e)
	return e.Bytes(), nil
}

// UnmarshalJX decodes ConfigPlain from JSON using jx.Decoder
func (p *ConfigPlain) UnmarshalJX(d *jx.Decoder) error {
	if p == nil {
		return nil
	}

	return d.Obj(func(d *jx.Decoder, key string) error {
		switch key {
		case "doubleVal":
			v, err := d.Float64()
			if err != nil {
				return err
			}
			p.DoubleVal = v
		case "floatVal":
			v, err := d.Float32()
			if err != nil {
				return err
			}
			p.FloatVal = v
		case "int32Val":
			v, err := d.Int32()
			if err != nil {
				return err
			}
			p.Int32Val = v
		case "int64Val":
			v, err := d.Int64()
			if err != nil {
				return err
			}
			p.Int64Val = v
		case "uint32Val":
			v, err := d.UInt32()
			if err != nil {
				return err
			}
			p.Uint32Val = v
		case "uint64Val":
			v, err := d.UInt64()
			if err != nil {
				return err
			}
			p.Uint64Val = v
		case "sint32Val":
			v, err := d.Int32()
			if err != nil {
				return err
			}
			p.Sint32Val = v
		case "sint64Val":
			v, err := d.Int64()
			if err != nil {
				return err
			}
			p.Sint64Val = v
		case "fixed32Val":
			v, err := d.UInt32()
			if err != nil {
				return err
			}
			p.Fixed32Val = v
		case "fixed64Val":
			v, err := d.UInt64()
			if err != nil {
				return err
			}
			p.Fixed64Val = v
		case "sfixed32Val":
			v, err := d.Int32()
			if err != nil {
				return err
			}
			p.Sfixed32Val = v
		case "sfixed64Val":
			v, err := d.Int64()
			if err != nil {
				return err
			}
			p.Sfixed64Val = v
		case "boolVal":
			v, err := d.Bool()
			if err != nil {
				return err
			}
			p.BoolVal = v
		case "stringVal":
			v, err := d.Str()
			if err != nil {
				return err
			}
			p.StringVal = v
		case "bytesVal":
			v, err := d.Base64()
			if err != nil {
				return err
			}
			p.BytesVal = v
		case "optionalString":
			v, err := d.Str()
			if err != nil {
				return err
			}
			p.OptionalString = v
		case "optionalInt":
			v, err := d.Int32()
			if err != nil {
				return err
			}
			p.OptionalInt = v
		case "optionalBool":
			v, err := d.Bool()
			if err != nil {
				return err
			}
			p.OptionalBool = v
		case "optionalDouble":
			v, err := d.Float64()
			if err != nil {
				return err
			}
			p.OptionalDouble = v
		case "optionalBytes":
			v, err := d.Base64()
			if err != nil {
				return err
			}
			p.OptionalBytes = v
		case "stringList":
			if err := d.Arr(func(d *jx.Decoder) error {
				v, err := d.Str()
				if err != nil {
					return err
				}
				p.StringList = append(p.StringList, v)
				return nil
			}); err != nil {
				return err
			}
		case "intList":
			if err := d.Arr(func(d *jx.Decoder) error {
				v, err := d.Int32()
				if err != nil {
					return err
				}
				p.IntList = append(p.IntList, v)
				return nil
			}); err != nil {
				return err
			}
		case "doubleList":
			if err := d.Arr(func(d *jx.Decoder) error {
				v, err := d.Float64()
				if err != nil {
					return err
				}
				p.DoubleList = append(p.DoubleList, v)
				return nil
			}); err != nil {
				return err
			}
		case "bytesList":
			if err := d.Arr(func(d *jx.Decoder) error {
				v, err := d.Base64()
				if err != nil {
					return err
				}
				p.BytesList = append(p.BytesList, v)
				return nil
			}); err != nil {
				return err
			}
		case "boolList":
			if err := d.Arr(func(d *jx.Decoder) error {
				v, err := d.Bool()
				if err != nil {
					return err
				}
				p.BoolList = append(p.BoolList, v)
				return nil
			}); err != nil {
				return err
			}
		case "floatList":
			if err := d.Arr(func(d *jx.Decoder) error {
				v, err := d.Float32()
				if err != nil {
					return err
				}
				p.FloatList = append(p.FloatList, v)
				return nil
			}); err != nil {
				return err
			}
		case "int64List":
			if err := d.Arr(func(d *jx.Decoder) error {
				v, err := d.Int64()
				if err != nil {
					return err
				}
				p.Int64List = append(p.Int64List, v)
				return nil
			}); err != nil {
				return err
			}
		case "uint32List":
			if err := d.Arr(func(d *jx.Decoder) error {
				v, err := d.UInt32()
				if err != nil {
					return err
				}
				p.Uint32List = append(p.Uint32List, v)
				return nil
			}); err != nil {
				return err
			}
		case "uint64List":
			if err := d.Arr(func(d *jx.Decoder) error {
				v, err := d.UInt64()
				if err != nil {
					return err
				}
				p.Uint64List = append(p.Uint64List, v)
				return nil
			}); err != nil {
				return err
			}
		case "stringMap":
			if p.StringMap == nil {
				p.StringMap = make(map[string]string)
			}
			return d.Obj(func(d *jx.Decoder, key string) error {
				v, err := d.Str()
				if err != nil {
					return err
				}
				p.StringMap[key] = v
				return nil
			})
		case "intMap":
			if p.IntMap == nil {
				p.IntMap = make(map[string]int32)
			}
			return d.Obj(func(d *jx.Decoder, key string) error {
				v, err := d.Int32()
				if err != nil {
					return err
				}
				p.IntMap[key] = v
				return nil
			})
		case "intKeyMap":
			if p.IntKeyMap == nil {
				p.IntKeyMap = make(map[int32]string)
			}
			return d.Obj(func(d *jx.Decoder, key string) error {
				_k, err := strconv.ParseInt(key, 10, 32)
				if err != nil {
					return err
				}
				_mapKey := int32(_k)
				v, err := d.Str()
				if err != nil {
					return err
				}
				p.IntKeyMap[_mapKey] = v
				return nil
			})
		case "nestedMap":
			if p.NestedMap == nil {
				p.NestedMap = make(map[string]*ConfigPlain)
			}
			return d.Obj(func(d *jx.Decoder, key string) error {
				p.NestedMap[key] = &ConfigPlain{}
				if err := p.NestedMap[key].UnmarshalJX(d); err != nil {
					return err
				}
				return nil
			})
		case "int64KeyMap":
			if p.Int64KeyMap == nil {
				p.Int64KeyMap = make(map[int64]string)
			}
			return d.Obj(func(d *jx.Decoder, key string) error {
				_mapKey, err := strconv.ParseInt(key, 10, 64)
				if err != nil {
					return err
				}
				v, err := d.Str()
				if err != nil {
					return err
				}
				p.Int64KeyMap[_mapKey] = v
				return nil
			})
		case "uint32KeyMap":
			if p.Uint32KeyMap == nil {
				p.Uint32KeyMap = make(map[uint32]string)
			}
			return d.Obj(func(d *jx.Decoder, key string) error {
				_k, err := strconv.ParseUint(key, 10, 32)
				if err != nil {
					return err
				}
				_mapKey := uint32(_k)
				v, err := d.Str()
				if err != nil {
					return err
				}
				p.Uint32KeyMap[_mapKey] = v
				return nil
			})
		case "uint64KeyMap":
			if p.Uint64KeyMap == nil {
				p.Uint64KeyMap = make(map[uint64]string)
			}
			return d.Obj(func(d *jx.Decoder, key string) error {
				_mapKey, err := strconv.ParseUint(key, 10, 64)
				if err != nil {
					return err
				}
				v, err := d.Str()
				if err != nil {
					return err
				}
				p.Uint64KeyMap[_mapKey] = v
				return nil
			})
		case "sint32KeyMap":
			if p.Sint32KeyMap == nil {
				p.Sint32KeyMap = make(map[int32]string)
			}
			return d.Obj(func(d *jx.Decoder, key string) error {
				_k, err := strconv.ParseInt(key, 10, 32)
				if err != nil {
					return err
				}
				_mapKey := int32(_k)
				v, err := d.Str()
				if err != nil {
					return err
				}
				p.Sint32KeyMap[_mapKey] = v
				return nil
			})
		case "sint64KeyMap":
			if p.Sint64KeyMap == nil {
				p.Sint64KeyMap = make(map[int64]string)
			}
			return d.Obj(func(d *jx.Decoder, key string) error {
				_mapKey, err := strconv.ParseInt(key, 10, 64)
				if err != nil {
					return err
				}
				v, err := d.Str()
				if err != nil {
					return err
				}
				p.Sint64KeyMap[_mapKey] = v
				return nil
			})
		case "fixed32KeyMap":
			if p.Fixed32KeyMap == nil {
				p.Fixed32KeyMap = make(map[uint32]string)
			}
			return d.Obj(func(d *jx.Decoder, key string) error {
				_k, err := strconv.ParseUint(key, 10, 32)
				if err != nil {
					return err
				}
				_mapKey := uint32(_k)
				v, err := d.Str()
				if err != nil {
					return err
				}
				p.Fixed32KeyMap[_mapKey] = v
				return nil
			})
		case "fixed64KeyMap":
			if p.Fixed64KeyMap == nil {
				p.Fixed64KeyMap = make(map[uint64]string)
			}
			return d.Obj(func(d *jx.Decoder, key string) error {
				_mapKey, err := strconv.ParseUint(key, 10, 64)
				if err != nil {
					return err
				}
				v, err := d.Str()
				if err != nil {
					return err
				}
				p.Fixed64KeyMap[_mapKey] = v
				return nil
			})
		case "sfixed32KeyMap":
			if p.Sfixed32KeyMap == nil {
				p.Sfixed32KeyMap = make(map[int32]string)
			}
			return d.Obj(func(d *jx.Decoder, key string) error {
				_k, err := strconv.ParseInt(key, 10, 32)
				if err != nil {
					return err
				}
				_mapKey := int32(_k)
				v, err := d.Str()
				if err != nil {
					return err
				}
				p.Sfixed32KeyMap[_mapKey] = v
				return nil
			})
		case "sfixed64KeyMap":
			if p.Sfixed64KeyMap == nil {
				p.Sfixed64KeyMap = make(map[int64]string)
			}
			return d.Obj(func(d *jx.Decoder, key string) error {
				_mapKey, err := strconv.ParseInt(key, 10, 64)
				if err != nil {
					return err
				}
				v, err := d.Str()
				if err != nil {
					return err
				}
				p.Sfixed64KeyMap[_mapKey] = v
				return nil
			})
		case "boolKeyMap":
			if p.BoolKeyMap == nil {
				p.BoolKeyMap = make(map[bool]string)
			}
			return d.Obj(func(d *jx.Decoder, key string) error {
				_mapKey, err := strconv.ParseBool(key)
				if err != nil {
					return err
				}
				v, err := d.Str()
				if err != nil {
					return err
				}
				p.BoolKeyMap[_mapKey] = v
				return nil
			})
		case "doubleMap":
			if p.DoubleMap == nil {
				p.DoubleMap = make(map[string]float64)
			}
			return d.Obj(func(d *jx.Decoder, key string) error {
				v, err := d.Float64()
				if err != nil {
					return err
				}
				p.DoubleMap[key] = v
				return nil
			})
		case "bytesMap":
			if p.BytesMap == nil {
				p.BytesMap = make(map[string][]byte)
			}
			return d.Obj(func(d *jx.Decoder, key string) error {
				v, err := d.Base64()
				if err != nil {
					return err
				}
				p.BytesMap[key] = v
				return nil
			})
		case "boolMap":
			if p.BoolMap == nil {
				p.BoolMap = make(map[string]bool)
			}
			return d.Obj(func(d *jx.Decoder, key string) error {
				v, err := d.Bool()
				if err != nil {
					return err
				}
				p.BoolMap[key] = v
				return nil
			})
		case "floatMap":
			if p.FloatMap == nil {
				p.FloatMap = make(map[string]float32)
			}
			return d.Obj(func(d *jx.Decoder, key string) error {
				v, err := d.Float32()
				if err != nil {
					return err
				}
				p.FloatMap[key] = v
				return nil
			})
		case "status":
			v, err := d.Int32()
			if err != nil {
				return err
			}
			p.Status = Status(v)
		case "statusList":
			if err := d.Arr(func(d *jx.Decoder) error {
				v, err := d.Int32()
				if err != nil {
					return err
				}
				p.StatusList = append(p.StatusList, Status(v))
				return nil
			}); err != nil {
				return err
			}
		case "statusMap":
			if p.StatusMap == nil {
				p.StatusMap = make(map[string]Status)
			}
			return d.Obj(func(d *jx.Decoder, key string) error {
				v, err := d.Int32()
				if err != nil {
					return err
				}
				p.StatusMap[key] = Status(v)
				return nil
			})
		case "optionalStatus":
			v, err := d.Int32()
			if err != nil {
				return err
			}
			p.OptionalStatus = Status(v)
		case "nestedEnum":
			v, err := d.Int32()
			if err != nil {
				return err
			}
			p.NestedEnum = Config_NestedEnum(v)
		case "nestedEnumList":
			if err := d.Arr(func(d *jx.Decoder) error {
				v, err := d.Int32()
				if err != nil {
					return err
				}
				p.NestedEnumList = append(p.NestedEnumList, Config_NestedEnum(v))
				return nil
			}); err != nil {
				return err
			}
		case "nestedConfig":
			p.NestedConfig = &Config_NestedConfig{}
			if err := p.NestedConfig.UnmarshalJX(d); err != nil {
				return err
			}
		case "nestedConfigList":
			if err := d.Arr(func(d *jx.Decoder) error {
				var v Config_NestedConfig
				if err := v.UnmarshalJX(d); err != nil {
					return err
				}
				p.NestedConfigList = append(p.NestedConfigList, &v)
				return nil
			}); err != nil {
				return err
			}
		case "nestedConfigMap":
			if p.NestedConfigMap == nil {
				p.NestedConfigMap = make(map[string]*Config_NestedConfig)
			}
			return d.Obj(func(d *jx.Decoder, key string) error {
				p.NestedConfigMap[key] = &Config_NestedConfig{}
				if err := p.NestedConfigMap[key].UnmarshalJX(d); err != nil {
					return err
				}
				return nil
			})
		case "parent":
			p.Parent = &ConfigPlain{}
			if err := p.Parent.UnmarshalJX(d); err != nil {
				return err
			}
		case "children":
			if err := d.Arr(func(d *jx.Decoder) error {
				var v ConfigPlain
				if err := v.UnmarshalJX(d); err != nil {
					return err
				}
				p.Children = append(p.Children, v)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// UnmarshalJSON implements json.Unmarshaler using jx
func (p *ConfigPlain) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return p.UnmarshalJX(d)
}

// configPlainPool is a sync.Pool for ConfigPlain objects
var configPlainPool = sync.Pool{
	New: func() interface{} {
		return &ConfigPlain{}
	},
}

// GetConfigPlain returns a ConfigPlain from the pool
func GetConfigPlain() *ConfigPlain {
	return configPlainPool.Get().(*ConfigPlain)
}

// PutConfigPlain returns a ConfigPlain to the pool after resetting it
func PutConfigPlain(p *ConfigPlain) {
	if p == nil {
		return
	}
	p.Reset()
	configPlainPool.Put(p)
}

// Reset clears all fields in ConfigPlain for reuse
func (p *ConfigPlain) Reset() {
	if p == nil {
		return
	}

	p.DoubleVal = 0
	p.FloatVal = 0
	p.Int32Val = 0
	p.Int64Val = 0
	p.Uint32Val = 0
	p.Uint64Val = 0
	p.Sint32Val = 0
	p.Sint64Val = 0
	p.Fixed32Val = 0
	p.Fixed64Val = 0
	p.Sfixed32Val = 0
	p.Sfixed64Val = 0
	p.BoolVal = false
	p.StringVal = ""
	p.BytesVal = nil
	p.OptionalString = ""
	p.OptionalInt = 0
	p.OptionalBool = false
	p.OptionalDouble = 0
	p.OptionalBytes = nil
	p.StringList = p.StringList[:0]
	p.IntList = p.IntList[:0]
	p.DoubleList = p.DoubleList[:0]
	p.BytesList = p.BytesList[:0]
	p.BoolList = p.BoolList[:0]
	p.FloatList = p.FloatList[:0]
	p.Int64List = p.Int64List[:0]
	p.Uint32List = p.Uint32List[:0]
	p.Uint64List = p.Uint64List[:0]
	for k := range p.StringMap {
		delete(p.StringMap, k)
	}
	for k := range p.IntMap {
		delete(p.IntMap, k)
	}
	for k := range p.IntKeyMap {
		delete(p.IntKeyMap, k)
	}
	for k := range p.NestedMap {
		delete(p.NestedMap, k)
	}
	for k := range p.Int64KeyMap {
		delete(p.Int64KeyMap, k)
	}
	for k := range p.Uint32KeyMap {
		delete(p.Uint32KeyMap, k)
	}
	for k := range p.Uint64KeyMap {
		delete(p.Uint64KeyMap, k)
	}
	for k := range p.Sint32KeyMap {
		delete(p.Sint32KeyMap, k)
	}
	for k := range p.Sint64KeyMap {
		delete(p.Sint64KeyMap, k)
	}
	for k := range p.Fixed32KeyMap {
		delete(p.Fixed32KeyMap, k)
	}
	for k := range p.Fixed64KeyMap {
		delete(p.Fixed64KeyMap, k)
	}
	for k := range p.Sfixed32KeyMap {
		delete(p.Sfixed32KeyMap, k)
	}
	for k := range p.Sfixed64KeyMap {
		delete(p.Sfixed64KeyMap, k)
	}
	for k := range p.BoolKeyMap {
		delete(p.BoolKeyMap, k)
	}
	for k := range p.DoubleMap {
		delete(p.DoubleMap, k)
	}
	for k := range p.BytesMap {
		delete(p.BytesMap, k)
	}
	for k := range p.BoolMap {
		delete(p.BoolMap, k)
	}
	for k := range p.FloatMap {
		delete(p.FloatMap, k)
	}
	p.Status = 0
	p.StatusList = p.StatusList[:0]
	for k := range p.StatusMap {
		delete(p.StatusMap, k)
	}
	p.OptionalStatus = 0
	p.NestedEnum = 0
	p.NestedEnumList = p.NestedEnumList[:0]
	p.NestedConfig = nil
	p.NestedConfigList = nil
	for k := range p.NestedConfigMap {
		delete(p.NestedConfigMap, k)
	}
	p.Parent = nil
	p.Children = p.Children[:0]
}

type WellKnownTypesPlain struct {
	CreatedAt      *timestamppb.Timestamp    `json:"createdAt"`
	Ttl            *durationpb.Duration      `json:"ttl"`
	UpdatedAt      *timestamppb.Timestamp    `json:"updatedAt"`
	Latency        *durationpb.Duration      `json:"latency"`
	NullableString *wrapperspb.StringValue   `json:"nullableString"`
	NullableInt32  *wrapperspb.Int32Value    `json:"nullableInt32"`
	NullableInt64  *wrapperspb.Int64Value    `json:"nullableInt64"`
	NullableUint32 *wrapperspb.UInt32Value   `json:"nullableUint32"`
	NullableUint64 *wrapperspb.UInt64Value   `json:"nullableUint64"`
	NullableFloat  *wrapperspb.FloatValue    `json:"nullableFloat"`
	NullableDouble *wrapperspb.DoubleValue   `json:"nullableDouble"`
	NullableBool   *wrapperspb.BoolValue     `json:"nullableBool"`
	NullableBytes  *wrapperspb.BytesValue    `json:"nullableBytes"`
	Metadata       *structpb.Struct          `json:"metadata"`
	DynamicValue   *structpb.Value           `json:"dynamicValue"`
	ListValue      *structpb.ListValue       `json:"listValue"`
	Payload        *anypb.Any                `json:"payload"`
	Payloads       []*anypb.Any              `json:"payloads"`
	Empty          *emptypb.Empty            `json:"empty"`
	Timestamps     []*timestamppb.Timestamp  `json:"timestamps"`
	Durations      []*durationpb.Duration    `json:"durations"`
	Strings        []*wrapperspb.StringValue `json:"strings"`
}

// IntoPlain converts protobuf message to plain struct
func (pb *WellKnownTypes) IntoPlain() *WellKnownTypesPlain {
	if pb == nil {
		return nil
	}
	p := &WellKnownTypesPlain{}

	p.CreatedAt = pb.CreatedAt
	p.Ttl = pb.Ttl
	p.UpdatedAt = pb.UpdatedAt
	p.Latency = pb.Latency
	p.NullableString = pb.NullableString
	p.NullableInt32 = pb.NullableInt32
	p.NullableInt64 = pb.NullableInt64
	p.NullableUint32 = pb.NullableUint32
	p.NullableUint64 = pb.NullableUint64
	p.NullableFloat = pb.NullableFloat
	p.NullableDouble = pb.NullableDouble
	p.NullableBool = pb.NullableBool
	p.NullableBytes = pb.NullableBytes
	p.Metadata = pb.Metadata
	p.DynamicValue = pb.DynamicValue
	p.ListValue = pb.ListValue
	p.Payload = pb.Payload
	p.Payloads = pb.Payloads
	p.Empty = pb.Empty
	p.Timestamps = pb.Timestamps
	p.Durations = pb.Durations
	p.Strings = pb.Strings
	return p
}

// IntoPb converts plain struct to protobuf message
func (p *WellKnownTypesPlain) IntoPb() *WellKnownTypes {
	if p == nil {
		return nil
	}
	pb := &WellKnownTypes{}

	pb.CreatedAt = p.CreatedAt
	pb.Ttl = p.Ttl
	pb.UpdatedAt = p.UpdatedAt
	pb.Latency = p.Latency
	pb.NullableString = p.NullableString
	pb.NullableInt32 = p.NullableInt32
	pb.NullableInt64 = p.NullableInt64
	pb.NullableUint32 = p.NullableUint32
	pb.NullableUint64 = p.NullableUint64
	pb.NullableFloat = p.NullableFloat
	pb.NullableDouble = p.NullableDouble
	pb.NullableBool = p.NullableBool
	pb.NullableBytes = p.NullableBytes
	pb.Metadata = p.Metadata
	pb.DynamicValue = p.DynamicValue
	pb.ListValue = p.ListValue
	pb.Payload = p.Payload
	pb.Payloads = p.Payloads
	pb.Empty = p.Empty
	pb.Timestamps = p.Timestamps
	pb.Durations = p.Durations
	pb.Strings = p.Strings
	return pb
}

// IntoPlainReuse converts protobuf message to existing plain struct (for pool usage)
func (pb *WellKnownTypes) IntoPlainReuse(p *WellKnownTypesPlain) {
	if pb == nil || p == nil {
		return
	}
	// Reset before filling
	p.Reset()

	p.CreatedAt = pb.CreatedAt
	p.Ttl = pb.Ttl
	p.UpdatedAt = pb.UpdatedAt
	p.Latency = pb.Latency
	p.NullableString = pb.NullableString
	p.NullableInt32 = pb.NullableInt32
	p.NullableInt64 = pb.NullableInt64
	p.NullableUint32 = pb.NullableUint32
	p.NullableUint64 = pb.NullableUint64
	p.NullableFloat = pb.NullableFloat
	p.NullableDouble = pb.NullableDouble
	p.NullableBool = pb.NullableBool
	p.NullableBytes = pb.NullableBytes
	p.Metadata = pb.Metadata
	p.DynamicValue = pb.DynamicValue
	p.ListValue = pb.ListValue
	p.Payload = pb.Payload
	p.Payloads = pb.Payloads
	p.Empty = pb.Empty
	p.Timestamps = pb.Timestamps
	p.Durations = pb.Durations
	p.Strings = pb.Strings
}

// MarshalJX encodes WellKnownTypesPlain to JSON using jx.Encoder
func (p *WellKnownTypesPlain) MarshalJX(e *jx.Encoder) {
	if p == nil {
		e.Null()
		return
	}

	e.ObjStart()

	if p.CreatedAt != nil {
		e.FieldStart("createdAt")
		if data, err := protojson.Marshal(p.CreatedAt); err == nil {
			e.Raw(data)
		} else {
			e.Null()
		}
	}
	if p.Ttl != nil {
		e.FieldStart("ttl")
		if data, err := protojson.Marshal(p.Ttl); err == nil {
			e.Raw(data)
		} else {
			e.Null()
		}
	}
	if p.UpdatedAt != nil {
		e.FieldStart("updatedAt")
		if data, err := protojson.Marshal(p.UpdatedAt); err == nil {
			e.Raw(data)
		} else {
			e.Null()
		}
	}
	if p.Latency != nil {
		e.FieldStart("latency")
		if data, err := protojson.Marshal(p.Latency); err == nil {
			e.Raw(data)
		} else {
			e.Null()
		}
	}
	if p.NullableString != nil {
		e.FieldStart("nullableString")
		if data, err := protojson.Marshal(p.NullableString); err == nil {
			e.Raw(data)
		} else {
			e.Null()
		}
	}
	if p.NullableInt32 != nil {
		e.FieldStart("nullableInt32")
		if data, err := protojson.Marshal(p.NullableInt32); err == nil {
			e.Raw(data)
		} else {
			e.Null()
		}
	}
	if p.NullableInt64 != nil {
		e.FieldStart("nullableInt64")
		if data, err := protojson.Marshal(p.NullableInt64); err == nil {
			e.Raw(data)
		} else {
			e.Null()
		}
	}
	if p.NullableUint32 != nil {
		e.FieldStart("nullableUint32")
		if data, err := protojson.Marshal(p.NullableUint32); err == nil {
			e.Raw(data)
		} else {
			e.Null()
		}
	}
	if p.NullableUint64 != nil {
		e.FieldStart("nullableUint64")
		if data, err := protojson.Marshal(p.NullableUint64); err == nil {
			e.Raw(data)
		} else {
			e.Null()
		}
	}
	if p.NullableFloat != nil {
		e.FieldStart("nullableFloat")
		if data, err := protojson.Marshal(p.NullableFloat); err == nil {
			e.Raw(data)
		} else {
			e.Null()
		}
	}
	if p.NullableDouble != nil {
		e.FieldStart("nullableDouble")
		if data, err := protojson.Marshal(p.NullableDouble); err == nil {
			e.Raw(data)
		} else {
			e.Null()
		}
	}
	if p.NullableBool != nil {
		e.FieldStart("nullableBool")
		if data, err := protojson.Marshal(p.NullableBool); err == nil {
			e.Raw(data)
		} else {
			e.Null()
		}
	}
	if p.NullableBytes != nil {
		e.FieldStart("nullableBytes")
		if data, err := protojson.Marshal(p.NullableBytes); err == nil {
			e.Raw(data)
		} else {
			e.Null()
		}
	}
	if p.Metadata != nil {
		e.FieldStart("metadata")
		if data, err := protojson.Marshal(p.Metadata); err == nil {
			e.Raw(data)
		} else {
			e.Null()
		}
	}
	if p.DynamicValue != nil {
		e.FieldStart("dynamicValue")
		if data, err := protojson.Marshal(p.DynamicValue); err == nil {
			e.Raw(data)
		} else {
			e.Null()
		}
	}
	if p.ListValue != nil {
		e.FieldStart("listValue")
		if data, err := protojson.Marshal(p.ListValue); err == nil {
			e.Raw(data)
		} else {
			e.Null()
		}
	}
	if p.Payload != nil {
		e.FieldStart("payload")
		if data, err := protojson.Marshal(p.Payload); err == nil {
			e.Raw(data)
		} else {
			e.Null()
		}
	}
	if p.Payloads != nil {
		e.FieldStart("payloads")
		e.ArrStart()
		for _, v := range p.Payloads {
			if data, err := protojson.Marshal(v); err == nil {
				e.Raw(data)
			} else {
				e.Null()
			}
		}
		e.ArrEnd()
	}
	if p.Empty != nil {
		e.FieldStart("empty")
		if data, err := protojson.Marshal(p.Empty); err == nil {
			e.Raw(data)
		} else {
			e.Null()
		}
	}
	if p.Timestamps != nil {
		e.FieldStart("timestamps")
		e.ArrStart()
		for _, v := range p.Timestamps {
			if data, err := protojson.Marshal(v); err == nil {
				e.Raw(data)
			} else {
				e.Null()
			}
		}
		e.ArrEnd()
	}
	if p.Durations != nil {
		e.FieldStart("durations")
		e.ArrStart()
		for _, v := range p.Durations {
			if data, err := protojson.Marshal(v); err == nil {
				e.Raw(data)
			} else {
				e.Null()
			}
		}
		e.ArrEnd()
	}
	if p.Strings != nil {
		e.FieldStart("strings")
		e.ArrStart()
		for _, v := range p.Strings {
			if data, err := protojson.Marshal(v); err == nil {
				e.Raw(data)
			} else {
				e.Null()
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

// MarshalJSON implements json.Marshaler using jx
func (p *WellKnownTypesPlain) MarshalJSON() ([]byte, error) {
	e := jx.GetEncoder()
	defer jx.PutEncoder(e)
	p.MarshalJX(e)
	return e.Bytes(), nil
}

// UnmarshalJX decodes WellKnownTypesPlain from JSON using jx.Decoder
func (p *WellKnownTypesPlain) UnmarshalJX(d *jx.Decoder) error {
	if p == nil {
		return nil
	}

	return d.Obj(func(d *jx.Decoder, key string) error {
		switch key {
		case "createdAt":
			raw, err := d.Raw()
			if err != nil {
				return err
			}
			p.CreatedAt = &timestamppb.Timestamp{}
			if err := protojson.Unmarshal(raw, p.CreatedAt); err != nil {
				return err
			}
		case "ttl":
			raw, err := d.Raw()
			if err != nil {
				return err
			}
			p.Ttl = &durationpb.Duration{}
			if err := protojson.Unmarshal(raw, p.Ttl); err != nil {
				return err
			}
		case "updatedAt":
			raw, err := d.Raw()
			if err != nil {
				return err
			}
			p.UpdatedAt = &timestamppb.Timestamp{}
			if err := protojson.Unmarshal(raw, p.UpdatedAt); err != nil {
				return err
			}
		case "latency":
			raw, err := d.Raw()
			if err != nil {
				return err
			}
			p.Latency = &durationpb.Duration{}
			if err := protojson.Unmarshal(raw, p.Latency); err != nil {
				return err
			}
		case "nullableString":
			raw, err := d.Raw()
			if err != nil {
				return err
			}
			p.NullableString = &wrapperspb.StringValue{}
			if err := protojson.Unmarshal(raw, p.NullableString); err != nil {
				return err
			}
		case "nullableInt32":
			raw, err := d.Raw()
			if err != nil {
				return err
			}
			p.NullableInt32 = &wrapperspb.Int32Value{}
			if err := protojson.Unmarshal(raw, p.NullableInt32); err != nil {
				return err
			}
		case "nullableInt64":
			raw, err := d.Raw()
			if err != nil {
				return err
			}
			p.NullableInt64 = &wrapperspb.Int64Value{}
			if err := protojson.Unmarshal(raw, p.NullableInt64); err != nil {
				return err
			}
		case "nullableUint32":
			raw, err := d.Raw()
			if err != nil {
				return err
			}
			p.NullableUint32 = &wrapperspb.UInt32Value{}
			if err := protojson.Unmarshal(raw, p.NullableUint32); err != nil {
				return err
			}
		case "nullableUint64":
			raw, err := d.Raw()
			if err != nil {
				return err
			}
			p.NullableUint64 = &wrapperspb.UInt64Value{}
			if err := protojson.Unmarshal(raw, p.NullableUint64); err != nil {
				return err
			}
		case "nullableFloat":
			raw, err := d.Raw()
			if err != nil {
				return err
			}
			p.NullableFloat = &wrapperspb.FloatValue{}
			if err := protojson.Unmarshal(raw, p.NullableFloat); err != nil {
				return err
			}
		case "nullableDouble":
			raw, err := d.Raw()
			if err != nil {
				return err
			}
			p.NullableDouble = &wrapperspb.DoubleValue{}
			if err := protojson.Unmarshal(raw, p.NullableDouble); err != nil {
				return err
			}
		case "nullableBool":
			raw, err := d.Raw()
			if err != nil {
				return err
			}
			p.NullableBool = &wrapperspb.BoolValue{}
			if err := protojson.Unmarshal(raw, p.NullableBool); err != nil {
				return err
			}
		case "nullableBytes":
			raw, err := d.Raw()
			if err != nil {
				return err
			}
			p.NullableBytes = &wrapperspb.BytesValue{}
			if err := protojson.Unmarshal(raw, p.NullableBytes); err != nil {
				return err
			}
		case "metadata":
			raw, err := d.Raw()
			if err != nil {
				return err
			}
			p.Metadata = &structpb.Struct{}
			if err := protojson.Unmarshal(raw, p.Metadata); err != nil {
				return err
			}
		case "dynamicValue":
			raw, err := d.Raw()
			if err != nil {
				return err
			}
			p.DynamicValue = &structpb.Value{}
			if err := protojson.Unmarshal(raw, p.DynamicValue); err != nil {
				return err
			}
		case "listValue":
			raw, err := d.Raw()
			if err != nil {
				return err
			}
			p.ListValue = &structpb.ListValue{}
			if err := protojson.Unmarshal(raw, p.ListValue); err != nil {
				return err
			}
		case "payload":
			raw, err := d.Raw()
			if err != nil {
				return err
			}
			p.Payload = &anypb.Any{}
			if err := protojson.Unmarshal(raw, p.Payload); err != nil {
				return err
			}
		case "payloads":
			if err := d.Arr(func(d *jx.Decoder) error {
				raw, err := d.Raw()
				if err != nil {
					return err
				}
				var v anypb.Any
				if err := protojson.Unmarshal(raw, &v); err != nil {
					return err
				}
				p.Payloads = append(p.Payloads, &v)
				return nil
			}); err != nil {
				return err
			}
		case "empty":
			raw, err := d.Raw()
			if err != nil {
				return err
			}
			p.Empty = &emptypb.Empty{}
			if err := protojson.Unmarshal(raw, p.Empty); err != nil {
				return err
			}
		case "timestamps":
			if err := d.Arr(func(d *jx.Decoder) error {
				raw, err := d.Raw()
				if err != nil {
					return err
				}
				var v timestamppb.Timestamp
				if err := protojson.Unmarshal(raw, &v); err != nil {
					return err
				}
				p.Timestamps = append(p.Timestamps, &v)
				return nil
			}); err != nil {
				return err
			}
		case "durations":
			if err := d.Arr(func(d *jx.Decoder) error {
				raw, err := d.Raw()
				if err != nil {
					return err
				}
				var v durationpb.Duration
				if err := protojson.Unmarshal(raw, &v); err != nil {
					return err
				}
				p.Durations = append(p.Durations, &v)
				return nil
			}); err != nil {
				return err
			}
		case "strings":
			if err := d.Arr(func(d *jx.Decoder) error {
				raw, err := d.Raw()
				if err != nil {
					return err
				}
				var v wrapperspb.StringValue
				if err := protojson.Unmarshal(raw, &v); err != nil {
					return err
				}
				p.Strings = append(p.Strings, &v)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// UnmarshalJSON implements json.Unmarshaler using jx
func (p *WellKnownTypesPlain) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return p.UnmarshalJX(d)
}

// wellKnownTypesPlainPool is a sync.Pool for WellKnownTypesPlain objects
var wellKnownTypesPlainPool = sync.Pool{
	New: func() interface{} {
		return &WellKnownTypesPlain{}
	},
}

// GetWellKnownTypesPlain returns a WellKnownTypesPlain from the pool
func GetWellKnownTypesPlain() *WellKnownTypesPlain {
	return wellKnownTypesPlainPool.Get().(*WellKnownTypesPlain)
}

// PutWellKnownTypesPlain returns a WellKnownTypesPlain to the pool after resetting it
func PutWellKnownTypesPlain(p *WellKnownTypesPlain) {
	if p == nil {
		return
	}
	p.Reset()
	wellKnownTypesPlainPool.Put(p)
}

// Reset clears all fields in WellKnownTypesPlain for reuse
func (p *WellKnownTypesPlain) Reset() {
	if p == nil {
		return
	}

	p.CreatedAt = nil
	p.Ttl = nil
	p.UpdatedAt = nil
	p.Latency = nil
	p.NullableString = nil
	p.NullableInt32 = nil
	p.NullableInt64 = nil
	p.NullableUint32 = nil
	p.NullableUint64 = nil
	p.NullableFloat = nil
	p.NullableDouble = nil
	p.NullableBool = nil
	p.NullableBytes = nil
	p.Metadata = nil
	p.DynamicValue = nil
	p.ListValue = nil
	p.Payload = nil
	p.Payloads = nil
	p.Empty = nil
	p.Timestamps = nil
	p.Durations = nil
	p.Strings = nil
}

type MapShowcasePlain struct {
	StrStr       map[string]string       `json:"strStr"`
	StrInt32     map[string]int32        `json:"strInt32"`
	StrInt64     map[string]int64        `json:"strInt64"`
	StrUint32    map[string]uint32       `json:"strUint32"`
	StrUint64    map[string]uint64       `json:"strUint64"`
	StrFloat     map[string]float32      `json:"strFloat"`
	StrDouble    map[string]float64      `json:"strDouble"`
	StrBool      map[string]bool         `json:"strBool"`
	StrBytes     map[string][]byte       `json:"strBytes"`
	Int32Str     map[int32]string        `json:"int32Str"`
	Int64Str     map[int64]string        `json:"int64Str"`
	Uint32Str    map[uint32]string       `json:"uint32Str"`
	Uint64Str    map[uint64]string       `json:"uint64Str"`
	Sint32Str    map[int32]string        `json:"sint32Str"`
	Sint64Str    map[int64]string        `json:"sint64Str"`
	Fixed32Str   map[uint32]string       `json:"fixed32Str"`
	Fixed64Str   map[uint64]string       `json:"fixed64Str"`
	Sfixed32Str  map[int32]string        `json:"sfixed32Str"`
	Sfixed64Str  map[int64]string        `json:"sfixed64Str"`
	BoolStr      map[bool]string         `json:"boolStr"`
	StrMessage   map[string]*Address     `json:"strMessage"`
	Int32Message map[int32]*Address      `json:"int32Message"`
	Int64Message map[int64]*Metadata     `json:"int64Message"`
	StrEnum      map[string]Status       `json:"strEnum"`
	Int32Enum    map[int32]Priority      `json:"int32Enum"`
	Nested       map[string]*ConfigPlain `json:"nested"`
}

// IntoPlain converts protobuf message to plain struct
func (pb *MapShowcase) IntoPlain() *MapShowcasePlain {
	if pb == nil {
		return nil
	}
	p := &MapShowcasePlain{}

	p.StrStr = pb.StrStr
	p.StrInt32 = pb.StrInt32
	p.StrInt64 = pb.StrInt64
	p.StrUint32 = pb.StrUint32
	p.StrUint64 = pb.StrUint64
	p.StrFloat = pb.StrFloat
	p.StrDouble = pb.StrDouble
	p.StrBool = pb.StrBool
	p.StrBytes = pb.StrBytes
	p.Int32Str = pb.Int32Str
	p.Int64Str = pb.Int64Str
	p.Uint32Str = pb.Uint32Str
	p.Uint64Str = pb.Uint64Str
	p.Sint32Str = pb.Sint32Str
	p.Sint64Str = pb.Sint64Str
	p.Fixed32Str = pb.Fixed32Str
	p.Fixed64Str = pb.Fixed64Str
	p.Sfixed32Str = pb.Sfixed32Str
	p.Sfixed64Str = pb.Sfixed64Str
	p.BoolStr = pb.BoolStr
	p.StrMessage = pb.StrMessage
	p.Int32Message = pb.Int32Message
	p.Int64Message = pb.Int64Message
	p.StrEnum = pb.StrEnum
	p.Int32Enum = pb.Int32Enum
	if len(pb.Nested) > 0 {
		p.Nested = make(map[string]*ConfigPlain, len(pb.Nested))
		for k, v := range pb.Nested {
			if v != nil {
				p.Nested[k] = v.IntoPlain()
			}
		}
	}
	return p
}

// IntoPb converts plain struct to protobuf message
func (p *MapShowcasePlain) IntoPb() *MapShowcase {
	if p == nil {
		return nil
	}
	pb := &MapShowcase{}

	pb.StrStr = p.StrStr
	pb.StrInt32 = p.StrInt32
	pb.StrInt64 = p.StrInt64
	pb.StrUint32 = p.StrUint32
	pb.StrUint64 = p.StrUint64
	pb.StrFloat = p.StrFloat
	pb.StrDouble = p.StrDouble
	pb.StrBool = p.StrBool
	pb.StrBytes = p.StrBytes
	pb.Int32Str = p.Int32Str
	pb.Int64Str = p.Int64Str
	pb.Uint32Str = p.Uint32Str
	pb.Uint64Str = p.Uint64Str
	pb.Sint32Str = p.Sint32Str
	pb.Sint64Str = p.Sint64Str
	pb.Fixed32Str = p.Fixed32Str
	pb.Fixed64Str = p.Fixed64Str
	pb.Sfixed32Str = p.Sfixed32Str
	pb.Sfixed64Str = p.Sfixed64Str
	pb.BoolStr = p.BoolStr
	pb.StrMessage = p.StrMessage
	pb.Int32Message = p.Int32Message
	pb.Int64Message = p.Int64Message
	pb.StrEnum = p.StrEnum
	pb.Int32Enum = p.Int32Enum
	if len(p.Nested) > 0 {
		pb.Nested = make(map[string]*Config, len(p.Nested))
		for k, v := range p.Nested {
			if v != nil {
				pb.Nested[k] = v.IntoPb()
			}
		}
	}
	return pb
}

// IntoPlainReuse converts protobuf message to existing plain struct (for pool usage)
func (pb *MapShowcase) IntoPlainReuse(p *MapShowcasePlain) {
	if pb == nil || p == nil {
		return
	}
	// Reset before filling
	p.Reset()

	p.StrStr = pb.StrStr
	p.StrInt32 = pb.StrInt32
	p.StrInt64 = pb.StrInt64
	p.StrUint32 = pb.StrUint32
	p.StrUint64 = pb.StrUint64
	p.StrFloat = pb.StrFloat
	p.StrDouble = pb.StrDouble
	p.StrBool = pb.StrBool
	p.StrBytes = pb.StrBytes
	p.Int32Str = pb.Int32Str
	p.Int64Str = pb.Int64Str
	p.Uint32Str = pb.Uint32Str
	p.Uint64Str = pb.Uint64Str
	p.Sint32Str = pb.Sint32Str
	p.Sint64Str = pb.Sint64Str
	p.Fixed32Str = pb.Fixed32Str
	p.Fixed64Str = pb.Fixed64Str
	p.Sfixed32Str = pb.Sfixed32Str
	p.Sfixed64Str = pb.Sfixed64Str
	p.BoolStr = pb.BoolStr
	p.StrMessage = pb.StrMessage
	p.Int32Message = pb.Int32Message
	p.Int64Message = pb.Int64Message
	p.StrEnum = pb.StrEnum
	p.Int32Enum = pb.Int32Enum
	if len(pb.Nested) > 0 {
		p.Nested = make(map[string]*ConfigPlain, len(pb.Nested))
		for k, v := range pb.Nested {
			if v != nil {
				p.Nested[k] = v.IntoPlain()
			}
		}
	}
}

// MarshalJX encodes MapShowcasePlain to JSON using jx.Encoder
func (p *MapShowcasePlain) MarshalJX(e *jx.Encoder) {
	if p == nil {
		e.Null()
		return
	}

	e.ObjStart()

	e.FieldStart("strStr")
	e.ObjStart()
	for k, v := range p.StrStr {
		e.FieldStart(k)
		e.Str(v)
	}
	e.ObjEnd()
	e.FieldStart("strInt32")
	e.ObjStart()
	for k, v := range p.StrInt32 {
		e.FieldStart(k)
		e.Int32(v)
	}
	e.ObjEnd()
	e.FieldStart("strInt64")
	e.ObjStart()
	for k, v := range p.StrInt64 {
		e.FieldStart(k)
		e.Int64(v)
	}
	e.ObjEnd()
	e.FieldStart("strUint32")
	e.ObjStart()
	for k, v := range p.StrUint32 {
		e.FieldStart(k)
		e.UInt32(v)
	}
	e.ObjEnd()
	e.FieldStart("strUint64")
	e.ObjStart()
	for k, v := range p.StrUint64 {
		e.FieldStart(k)
		e.UInt64(v)
	}
	e.ObjEnd()
	e.FieldStart("strFloat")
	e.ObjStart()
	for k, v := range p.StrFloat {
		e.FieldStart(k)
		e.Float32(v)
	}
	e.ObjEnd()
	e.FieldStart("strDouble")
	e.ObjStart()
	for k, v := range p.StrDouble {
		e.FieldStart(k)
		e.Float64(v)
	}
	e.ObjEnd()
	e.FieldStart("strBool")
	e.ObjStart()
	for k, v := range p.StrBool {
		e.FieldStart(k)
		e.Bool(v)
	}
	e.ObjEnd()
	e.FieldStart("strBytes")
	e.ObjStart()
	for k, v := range p.StrBytes {
		e.FieldStart(k)
		e.Base64(v)
	}
	e.ObjEnd()
	e.FieldStart("int32Str")
	e.ObjStart()
	for k, v := range p.Int32Str {
		e.FieldStart(fmt.Sprint(k))
		e.Str(v)
	}
	e.ObjEnd()
	e.FieldStart("int64Str")
	e.ObjStart()
	for k, v := range p.Int64Str {
		e.FieldStart(fmt.Sprint(k))
		e.Str(v)
	}
	e.ObjEnd()
	e.FieldStart("uint32Str")
	e.ObjStart()
	for k, v := range p.Uint32Str {
		e.FieldStart(fmt.Sprint(k))
		e.Str(v)
	}
	e.ObjEnd()
	e.FieldStart("uint64Str")
	e.ObjStart()
	for k, v := range p.Uint64Str {
		e.FieldStart(fmt.Sprint(k))
		e.Str(v)
	}
	e.ObjEnd()
	e.FieldStart("sint32Str")
	e.ObjStart()
	for k, v := range p.Sint32Str {
		e.FieldStart(fmt.Sprint(k))
		e.Str(v)
	}
	e.ObjEnd()
	e.FieldStart("sint64Str")
	e.ObjStart()
	for k, v := range p.Sint64Str {
		e.FieldStart(fmt.Sprint(k))
		e.Str(v)
	}
	e.ObjEnd()
	e.FieldStart("fixed32Str")
	e.ObjStart()
	for k, v := range p.Fixed32Str {
		e.FieldStart(fmt.Sprint(k))
		e.Str(v)
	}
	e.ObjEnd()
	e.FieldStart("fixed64Str")
	e.ObjStart()
	for k, v := range p.Fixed64Str {
		e.FieldStart(fmt.Sprint(k))
		e.Str(v)
	}
	e.ObjEnd()
	e.FieldStart("sfixed32Str")
	e.ObjStart()
	for k, v := range p.Sfixed32Str {
		e.FieldStart(fmt.Sprint(k))
		e.Str(v)
	}
	e.ObjEnd()
	e.FieldStart("sfixed64Str")
	e.ObjStart()
	for k, v := range p.Sfixed64Str {
		e.FieldStart(fmt.Sprint(k))
		e.Str(v)
	}
	e.ObjEnd()
	e.FieldStart("boolStr")
	e.ObjStart()
	for k, v := range p.BoolStr {
		e.FieldStart(fmt.Sprint(k))
		e.Str(v)
	}
	e.ObjEnd()
	e.FieldStart("strMessage")
	e.ObjStart()
	for k, v := range p.StrMessage {
		e.FieldStart(k)
		v.MarshalJX(e)
	}
	e.ObjEnd()
	e.FieldStart("int32Message")
	e.ObjStart()
	for k, v := range p.Int32Message {
		e.FieldStart(fmt.Sprint(k))
		v.MarshalJX(e)
	}
	e.ObjEnd()
	e.FieldStart("int64Message")
	e.ObjStart()
	for k, v := range p.Int64Message {
		e.FieldStart(fmt.Sprint(k))
		v.MarshalJX(e)
	}
	e.ObjEnd()
	e.FieldStart("strEnum")
	e.ObjStart()
	for k, v := range p.StrEnum {
		e.FieldStart(k)
		e.Int32(int32(v))
	}
	e.ObjEnd()
	e.FieldStart("int32Enum")
	e.ObjStart()
	for k, v := range p.Int32Enum {
		e.FieldStart(fmt.Sprint(k))
		e.Int32(int32(v))
	}
	e.ObjEnd()
	e.FieldStart("nested")
	e.ObjStart()
	for k, v := range p.Nested {
		e.FieldStart(k)
		v.MarshalJX(e)
	}
	e.ObjEnd()
	e.ObjEnd()
}

// MarshalJSON implements json.Marshaler using jx
func (p *MapShowcasePlain) MarshalJSON() ([]byte, error) {
	e := jx.GetEncoder()
	defer jx.PutEncoder(e)
	p.MarshalJX(e)
	return e.Bytes(), nil
}

// UnmarshalJX decodes MapShowcasePlain from JSON using jx.Decoder
func (p *MapShowcasePlain) UnmarshalJX(d *jx.Decoder) error {
	if p == nil {
		return nil
	}

	return d.Obj(func(d *jx.Decoder, key string) error {
		switch key {
		case "strStr":
			if p.StrStr == nil {
				p.StrStr = make(map[string]string)
			}
			return d.Obj(func(d *jx.Decoder, key string) error {
				v, err := d.Str()
				if err != nil {
					return err
				}
				p.StrStr[key] = v
				return nil
			})
		case "strInt32":
			if p.StrInt32 == nil {
				p.StrInt32 = make(map[string]int32)
			}
			return d.Obj(func(d *jx.Decoder, key string) error {
				v, err := d.Int32()
				if err != nil {
					return err
				}
				p.StrInt32[key] = v
				return nil
			})
		case "strInt64":
			if p.StrInt64 == nil {
				p.StrInt64 = make(map[string]int64)
			}
			return d.Obj(func(d *jx.Decoder, key string) error {
				v, err := d.Int64()
				if err != nil {
					return err
				}
				p.StrInt64[key] = v
				return nil
			})
		case "strUint32":
			if p.StrUint32 == nil {
				p.StrUint32 = make(map[string]uint32)
			}
			return d.Obj(func(d *jx.Decoder, key string) error {
				v, err := d.UInt32()
				if err != nil {
					return err
				}
				p.StrUint32[key] = v
				return nil
			})
		case "strUint64":
			if p.StrUint64 == nil {
				p.StrUint64 = make(map[string]uint64)
			}
			return d.Obj(func(d *jx.Decoder, key string) error {
				v, err := d.UInt64()
				if err != nil {
					return err
				}
				p.StrUint64[key] = v
				return nil
			})
		case "strFloat":
			if p.StrFloat == nil {
				p.StrFloat = make(map[string]float32)
			}
			return d.Obj(func(d *jx.Decoder, key string) error {
				v, err := d.Float32()
				if err != nil {
					return err
				}
				p.StrFloat[key] = v
				return nil
			})
		case "strDouble":
			if p.StrDouble == nil {
				p.StrDouble = make(map[string]float64)
			}
			return d.Obj(func(d *jx.Decoder, key string) error {
				v, err := d.Float64()
				if err != nil {
					return err
				}
				p.StrDouble[key] = v
				return nil
			})
		case "strBool":
			if p.StrBool == nil {
				p.StrBool = make(map[string]bool)
			}
			return d.Obj(func(d *jx.Decoder, key string) error {
				v, err := d.Bool()
				if err != nil {
					return err
				}
				p.StrBool[key] = v
				return nil
			})
		case "strBytes":
			if p.StrBytes == nil {
				p.StrBytes = make(map[string][]byte)
			}
			return d.Obj(func(d *jx.Decoder, key string) error {
				v, err := d.Base64()
				if err != nil {
					return err
				}
				p.StrBytes[key] = v
				return nil
			})
		case "int32Str":
			if p.Int32Str == nil {
				p.Int32Str = make(map[int32]string)
			}
			return d.Obj(func(d *jx.Decoder, key string) error {
				_k, err := strconv.ParseInt(key, 10, 32)
				if err != nil {
					return err
				}
				_mapKey := int32(_k)
				v, err := d.Str()
				if err != nil {
					return err
				}
				p.Int32Str[_mapKey] = v
				return nil
			})
		case "int64Str":
			if p.Int64Str == nil {
				p.Int64Str = make(map[int64]string)
			}
			return d.Obj(func(d *jx.Decoder, key string) error {
				_mapKey, err := strconv.ParseInt(key, 10, 64)
				if err != nil {
					return err
				}
				v, err := d.Str()
				if err != nil {
					return err
				}
				p.Int64Str[_mapKey] = v
				return nil
			})
		case "uint32Str":
			if p.Uint32Str == nil {
				p.Uint32Str = make(map[uint32]string)
			}
			return d.Obj(func(d *jx.Decoder, key string) error {
				_k, err := strconv.ParseUint(key, 10, 32)
				if err != nil {
					return err
				}
				_mapKey := uint32(_k)
				v, err := d.Str()
				if err != nil {
					return err
				}
				p.Uint32Str[_mapKey] = v
				return nil
			})
		case "uint64Str":
			if p.Uint64Str == nil {
				p.Uint64Str = make(map[uint64]string)
			}
			return d.Obj(func(d *jx.Decoder, key string) error {
				_mapKey, err := strconv.ParseUint(key, 10, 64)
				if err != nil {
					return err
				}
				v, err := d.Str()
				if err != nil {
					return err
				}
				p.Uint64Str[_mapKey] = v
				return nil
			})
		case "sint32Str":
			if p.Sint32Str == nil {
				p.Sint32Str = make(map[int32]string)
			}
			return d.Obj(func(d *jx.Decoder, key string) error {
				_k, err := strconv.ParseInt(key, 10, 32)
				if err != nil {
					return err
				}
				_mapKey := int32(_k)
				v, err := d.Str()
				if err != nil {
					return err
				}
				p.Sint32Str[_mapKey] = v
				return nil
			})
		case "sint64Str":
			if p.Sint64Str == nil {
				p.Sint64Str = make(map[int64]string)
			}
			return d.Obj(func(d *jx.Decoder, key string) error {
				_mapKey, err := strconv.ParseInt(key, 10, 64)
				if err != nil {
					return err
				}
				v, err := d.Str()
				if err != nil {
					return err
				}
				p.Sint64Str[_mapKey] = v
				return nil
			})
		case "fixed32Str":
			if p.Fixed32Str == nil {
				p.Fixed32Str = make(map[uint32]string)
			}
			return d.Obj(func(d *jx.Decoder, key string) error {
				_k, err := strconv.ParseUint(key, 10, 32)
				if err != nil {
					return err
				}
				_mapKey := uint32(_k)
				v, err := d.Str()
				if err != nil {
					return err
				}
				p.Fixed32Str[_mapKey] = v
				return nil
			})
		case "fixed64Str":
			if p.Fixed64Str == nil {
				p.Fixed64Str = make(map[uint64]string)
			}
			return d.Obj(func(d *jx.Decoder, key string) error {
				_mapKey, err := strconv.ParseUint(key, 10, 64)
				if err != nil {
					return err
				}
				v, err := d.Str()
				if err != nil {
					return err
				}
				p.Fixed64Str[_mapKey] = v
				return nil
			})
		case "sfixed32Str":
			if p.Sfixed32Str == nil {
				p.Sfixed32Str = make(map[int32]string)
			}
			return d.Obj(func(d *jx.Decoder, key string) error {
				_k, err := strconv.ParseInt(key, 10, 32)
				if err != nil {
					return err
				}
				_mapKey := int32(_k)
				v, err := d.Str()
				if err != nil {
					return err
				}
				p.Sfixed32Str[_mapKey] = v
				return nil
			})
		case "sfixed64Str":
			if p.Sfixed64Str == nil {
				p.Sfixed64Str = make(map[int64]string)
			}
			return d.Obj(func(d *jx.Decoder, key string) error {
				_mapKey, err := strconv.ParseInt(key, 10, 64)
				if err != nil {
					return err
				}
				v, err := d.Str()
				if err != nil {
					return err
				}
				p.Sfixed64Str[_mapKey] = v
				return nil
			})
		case "boolStr":
			if p.BoolStr == nil {
				p.BoolStr = make(map[bool]string)
			}
			return d.Obj(func(d *jx.Decoder, key string) error {
				_mapKey, err := strconv.ParseBool(key)
				if err != nil {
					return err
				}
				v, err := d.Str()
				if err != nil {
					return err
				}
				p.BoolStr[_mapKey] = v
				return nil
			})
		case "strMessage":
			if p.StrMessage == nil {
				p.StrMessage = make(map[string]*Address)
			}
			return d.Obj(func(d *jx.Decoder, key string) error {
				p.StrMessage[key] = &Address{}
				if err := p.StrMessage[key].UnmarshalJX(d); err != nil {
					return err
				}
				return nil
			})
		case "int32Message":
			if p.Int32Message == nil {
				p.Int32Message = make(map[int32]*Address)
			}
			return d.Obj(func(d *jx.Decoder, key string) error {
				_k, err := strconv.ParseInt(key, 10, 32)
				if err != nil {
					return err
				}
				_mapKey := int32(_k)
				p.Int32Message[_mapKey] = &Address{}
				if err := p.Int32Message[_mapKey].UnmarshalJX(d); err != nil {
					return err
				}
				return nil
			})
		case "int64Message":
			if p.Int64Message == nil {
				p.Int64Message = make(map[int64]*Metadata)
			}
			return d.Obj(func(d *jx.Decoder, key string) error {
				_mapKey, err := strconv.ParseInt(key, 10, 64)
				if err != nil {
					return err
				}
				p.Int64Message[_mapKey] = &Metadata{}
				if err := p.Int64Message[_mapKey].UnmarshalJX(d); err != nil {
					return err
				}
				return nil
			})
		case "strEnum":
			if p.StrEnum == nil {
				p.StrEnum = make(map[string]Status)
			}
			return d.Obj(func(d *jx.Decoder, key string) error {
				v, err := d.Int32()
				if err != nil {
					return err
				}
				p.StrEnum[key] = Status(v)
				return nil
			})
		case "int32Enum":
			if p.Int32Enum == nil {
				p.Int32Enum = make(map[int32]Priority)
			}
			return d.Obj(func(d *jx.Decoder, key string) error {
				_k, err := strconv.ParseInt(key, 10, 32)
				if err != nil {
					return err
				}
				_mapKey := int32(_k)
				v, err := d.Int32()
				if err != nil {
					return err
				}
				p.Int32Enum[_mapKey] = Priority(v)
				return nil
			})
		case "nested":
			if p.Nested == nil {
				p.Nested = make(map[string]*ConfigPlain)
			}
			return d.Obj(func(d *jx.Decoder, key string) error {
				p.Nested[key] = &ConfigPlain{}
				if err := p.Nested[key].UnmarshalJX(d); err != nil {
					return err
				}
				return nil
			})
		default:
			return d.Skip()
		}
		return nil
	})
}

// UnmarshalJSON implements json.Unmarshaler using jx
func (p *MapShowcasePlain) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return p.UnmarshalJX(d)
}

// mapShowcasePlainPool is a sync.Pool for MapShowcasePlain objects
var mapShowcasePlainPool = sync.Pool{
	New: func() interface{} {
		return &MapShowcasePlain{}
	},
}

// GetMapShowcasePlain returns a MapShowcasePlain from the pool
func GetMapShowcasePlain() *MapShowcasePlain {
	return mapShowcasePlainPool.Get().(*MapShowcasePlain)
}

// PutMapShowcasePlain returns a MapShowcasePlain to the pool after resetting it
func PutMapShowcasePlain(p *MapShowcasePlain) {
	if p == nil {
		return
	}
	p.Reset()
	mapShowcasePlainPool.Put(p)
}

// Reset clears all fields in MapShowcasePlain for reuse
func (p *MapShowcasePlain) Reset() {
	if p == nil {
		return
	}

	for k := range p.StrStr {
		delete(p.StrStr, k)
	}
	for k := range p.StrInt32 {
		delete(p.StrInt32, k)
	}
	for k := range p.StrInt64 {
		delete(p.StrInt64, k)
	}
	for k := range p.StrUint32 {
		delete(p.StrUint32, k)
	}
	for k := range p.StrUint64 {
		delete(p.StrUint64, k)
	}
	for k := range p.StrFloat {
		delete(p.StrFloat, k)
	}
	for k := range p.StrDouble {
		delete(p.StrDouble, k)
	}
	for k := range p.StrBool {
		delete(p.StrBool, k)
	}
	for k := range p.StrBytes {
		delete(p.StrBytes, k)
	}
	for k := range p.Int32Str {
		delete(p.Int32Str, k)
	}
	for k := range p.Int64Str {
		delete(p.Int64Str, k)
	}
	for k := range p.Uint32Str {
		delete(p.Uint32Str, k)
	}
	for k := range p.Uint64Str {
		delete(p.Uint64Str, k)
	}
	for k := range p.Sint32Str {
		delete(p.Sint32Str, k)
	}
	for k := range p.Sint64Str {
		delete(p.Sint64Str, k)
	}
	for k := range p.Fixed32Str {
		delete(p.Fixed32Str, k)
	}
	for k := range p.Fixed64Str {
		delete(p.Fixed64Str, k)
	}
	for k := range p.Sfixed32Str {
		delete(p.Sfixed32Str, k)
	}
	for k := range p.Sfixed64Str {
		delete(p.Sfixed64Str, k)
	}
	for k := range p.BoolStr {
		delete(p.BoolStr, k)
	}
	for k := range p.StrMessage {
		delete(p.StrMessage, k)
	}
	for k := range p.Int32Message {
		delete(p.Int32Message, k)
	}
	for k := range p.Int64Message {
		delete(p.Int64Message, k)
	}
	for k := range p.StrEnum {
		delete(p.StrEnum, k)
	}
	for k := range p.Int32Enum {
		delete(p.Int32Enum, k)
	}
	for k := range p.Nested {
		delete(p.Nested, k)
	}
}

type OptionalShowcasePlain struct {
	OptDouble     float64  `json:"optDouble,omitempty"`
	OptFloat      float32  `json:"optFloat,omitempty"`
	OptInt32      int32    `json:"optInt32,omitempty"`
	OptInt64      int64    `json:"optInt64,omitempty"`
	OptUint32     uint32   `json:"optUint32,omitempty"`
	OptUint64     uint64   `json:"optUint64,omitempty"`
	OptSint32     int32    `json:"optSint32,omitempty"`
	OptSint64     int64    `json:"optSint64,omitempty"`
	OptFixed32    uint32   `json:"optFixed32,omitempty"`
	OptFixed64    uint64   `json:"optFixed64,omitempty"`
	OptSfixed32   int32    `json:"optSfixed32,omitempty"`
	OptSfixed64   int64    `json:"optSfixed64,omitempty"`
	OptBool       bool     `json:"optBool,omitempty"`
	OptString     string   `json:"optString,omitempty"`
	OptBytes      []byte   `json:"optBytes,omitempty"`
	OptStatus     Status   `json:"optStatus,omitempty"`
	OptPriority   Priority `json:"optPriority,omitempty"`
	RegularDouble float64  `json:"regularDouble"`
	RegularString string   `json:"regularString"`
	RegularBool   bool     `json:"regularBool"`
}

// IntoPlain converts protobuf message to plain struct
func (pb *OptionalShowcase) IntoPlain() *OptionalShowcasePlain {
	if pb == nil {
		return nil
	}
	p := &OptionalShowcasePlain{}

	if pb.OptDouble != nil {
		p.OptDouble = *pb.OptDouble
	}
	if pb.OptFloat != nil {
		p.OptFloat = *pb.OptFloat
	}
	if pb.OptInt32 != nil {
		p.OptInt32 = *pb.OptInt32
	}
	if pb.OptInt64 != nil {
		p.OptInt64 = *pb.OptInt64
	}
	if pb.OptUint32 != nil {
		p.OptUint32 = *pb.OptUint32
	}
	if pb.OptUint64 != nil {
		p.OptUint64 = *pb.OptUint64
	}
	if pb.OptSint32 != nil {
		p.OptSint32 = *pb.OptSint32
	}
	if pb.OptSint64 != nil {
		p.OptSint64 = *pb.OptSint64
	}
	if pb.OptFixed32 != nil {
		p.OptFixed32 = *pb.OptFixed32
	}
	if pb.OptFixed64 != nil {
		p.OptFixed64 = *pb.OptFixed64
	}
	if pb.OptSfixed32 != nil {
		p.OptSfixed32 = *pb.OptSfixed32
	}
	if pb.OptSfixed64 != nil {
		p.OptSfixed64 = *pb.OptSfixed64
	}
	if pb.OptBool != nil {
		p.OptBool = *pb.OptBool
	}
	if pb.OptString != nil {
		p.OptString = *pb.OptString
	}
	p.OptBytes = pb.OptBytes
	if pb.OptStatus != nil {
		p.OptStatus = *pb.OptStatus
	}
	if pb.OptPriority != nil {
		p.OptPriority = *pb.OptPriority
	}
	p.RegularDouble = pb.RegularDouble
	p.RegularString = pb.RegularString
	p.RegularBool = pb.RegularBool
	return p
}

// IntoPb converts plain struct to protobuf message
func (p *OptionalShowcasePlain) IntoPb() *OptionalShowcase {
	if p == nil {
		return nil
	}
	pb := &OptionalShowcase{}

	pb.OptDouble = &p.OptDouble
	pb.OptFloat = &p.OptFloat
	pb.OptInt32 = &p.OptInt32
	pb.OptInt64 = &p.OptInt64
	pb.OptUint32 = &p.OptUint32
	pb.OptUint64 = &p.OptUint64
	pb.OptSint32 = &p.OptSint32
	pb.OptSint64 = &p.OptSint64
	pb.OptFixed32 = &p.OptFixed32
	pb.OptFixed64 = &p.OptFixed64
	pb.OptSfixed32 = &p.OptSfixed32
	pb.OptSfixed64 = &p.OptSfixed64
	pb.OptBool = &p.OptBool
	if p.OptString != "" {
		pb.OptString = &p.OptString
	}
	pb.OptBytes = p.OptBytes
	pb.OptStatus = &p.OptStatus
	pb.OptPriority = &p.OptPriority
	pb.RegularDouble = p.RegularDouble
	pb.RegularString = p.RegularString
	pb.RegularBool = p.RegularBool
	return pb
}

// IntoPlainReuse converts protobuf message to existing plain struct (for pool usage)
func (pb *OptionalShowcase) IntoPlainReuse(p *OptionalShowcasePlain) {
	if pb == nil || p == nil {
		return
	}
	// Reset before filling
	p.Reset()

	if pb.OptDouble != nil {
		p.OptDouble = *pb.OptDouble
	}
	if pb.OptFloat != nil {
		p.OptFloat = *pb.OptFloat
	}
	if pb.OptInt32 != nil {
		p.OptInt32 = *pb.OptInt32
	}
	if pb.OptInt64 != nil {
		p.OptInt64 = *pb.OptInt64
	}
	if pb.OptUint32 != nil {
		p.OptUint32 = *pb.OptUint32
	}
	if pb.OptUint64 != nil {
		p.OptUint64 = *pb.OptUint64
	}
	if pb.OptSint32 != nil {
		p.OptSint32 = *pb.OptSint32
	}
	if pb.OptSint64 != nil {
		p.OptSint64 = *pb.OptSint64
	}
	if pb.OptFixed32 != nil {
		p.OptFixed32 = *pb.OptFixed32
	}
	if pb.OptFixed64 != nil {
		p.OptFixed64 = *pb.OptFixed64
	}
	if pb.OptSfixed32 != nil {
		p.OptSfixed32 = *pb.OptSfixed32
	}
	if pb.OptSfixed64 != nil {
		p.OptSfixed64 = *pb.OptSfixed64
	}
	if pb.OptBool != nil {
		p.OptBool = *pb.OptBool
	}
	if pb.OptString != nil {
		p.OptString = *pb.OptString
	}
	p.OptBytes = pb.OptBytes
	if pb.OptStatus != nil {
		p.OptStatus = *pb.OptStatus
	}
	if pb.OptPriority != nil {
		p.OptPriority = *pb.OptPriority
	}
	p.RegularDouble = pb.RegularDouble
	p.RegularString = pb.RegularString
	p.RegularBool = pb.RegularBool
}

// MarshalJX encodes OptionalShowcasePlain to JSON using jx.Encoder
func (p *OptionalShowcasePlain) MarshalJX(e *jx.Encoder) {
	if p == nil {
		e.Null()
		return
	}

	e.ObjStart()

	if p.OptDouble != 0 {
		e.FieldStart("optDouble")
		e.Float64(p.OptDouble)
	}
	if p.OptFloat != 0 {
		e.FieldStart("optFloat")
		e.Float32(p.OptFloat)
	}
	if p.OptInt32 != 0 {
		e.FieldStart("optInt32")
		e.Int32(p.OptInt32)
	}
	if p.OptInt64 != 0 {
		e.FieldStart("optInt64")
		e.Int64(p.OptInt64)
	}
	if p.OptUint32 != 0 {
		e.FieldStart("optUint32")
		e.UInt32(p.OptUint32)
	}
	if p.OptUint64 != 0 {
		e.FieldStart("optUint64")
		e.UInt64(p.OptUint64)
	}
	if p.OptSint32 != 0 {
		e.FieldStart("optSint32")
		e.Int32(p.OptSint32)
	}
	if p.OptSint64 != 0 {
		e.FieldStart("optSint64")
		e.Int64(p.OptSint64)
	}
	if p.OptFixed32 != 0 {
		e.FieldStart("optFixed32")
		e.UInt32(p.OptFixed32)
	}
	if p.OptFixed64 != 0 {
		e.FieldStart("optFixed64")
		e.UInt64(p.OptFixed64)
	}
	if p.OptSfixed32 != 0 {
		e.FieldStart("optSfixed32")
		e.Int32(p.OptSfixed32)
	}
	if p.OptSfixed64 != 0 {
		e.FieldStart("optSfixed64")
		e.Int64(p.OptSfixed64)
	}
	if p.OptBool {
		e.FieldStart("optBool")
		e.Bool(p.OptBool)
	}
	if p.OptString != "" {
		e.FieldStart("optString")
		e.Str(p.OptString)
	}
	if len(p.OptBytes) > 0 {
		e.FieldStart("optBytes")
		e.Base64(p.OptBytes)
	}
	e.FieldStart("optStatus")
	e.Int32(int32(p.OptStatus))
	e.FieldStart("optPriority")
	e.Int32(int32(p.OptPriority))
	if p.RegularDouble != 0 {
		e.FieldStart("regularDouble")
		e.Float64(p.RegularDouble)
	}
	if p.RegularString != "" {
		e.FieldStart("regularString")
		e.Str(p.RegularString)
	}
	if p.RegularBool {
		e.FieldStart("regularBool")
		e.Bool(p.RegularBool)
	}
	e.ObjEnd()
}

// MarshalJSON implements json.Marshaler using jx
func (p *OptionalShowcasePlain) MarshalJSON() ([]byte, error) {
	e := jx.GetEncoder()
	defer jx.PutEncoder(e)
	p.MarshalJX(e)
	return e.Bytes(), nil
}

// UnmarshalJX decodes OptionalShowcasePlain from JSON using jx.Decoder
func (p *OptionalShowcasePlain) UnmarshalJX(d *jx.Decoder) error {
	if p == nil {
		return nil
	}

	return d.Obj(func(d *jx.Decoder, key string) error {
		switch key {
		case "optDouble":
			v, err := d.Float64()
			if err != nil {
				return err
			}
			p.OptDouble = v
		case "optFloat":
			v, err := d.Float32()
			if err != nil {
				return err
			}
			p.OptFloat = v
		case "optInt32":
			v, err := d.Int32()
			if err != nil {
				return err
			}
			p.OptInt32 = v
		case "optInt64":
			v, err := d.Int64()
			if err != nil {
				return err
			}
			p.OptInt64 = v
		case "optUint32":
			v, err := d.UInt32()
			if err != nil {
				return err
			}
			p.OptUint32 = v
		case "optUint64":
			v, err := d.UInt64()
			if err != nil {
				return err
			}
			p.OptUint64 = v
		case "optSint32":
			v, err := d.Int32()
			if err != nil {
				return err
			}
			p.OptSint32 = v
		case "optSint64":
			v, err := d.Int64()
			if err != nil {
				return err
			}
			p.OptSint64 = v
		case "optFixed32":
			v, err := d.UInt32()
			if err != nil {
				return err
			}
			p.OptFixed32 = v
		case "optFixed64":
			v, err := d.UInt64()
			if err != nil {
				return err
			}
			p.OptFixed64 = v
		case "optSfixed32":
			v, err := d.Int32()
			if err != nil {
				return err
			}
			p.OptSfixed32 = v
		case "optSfixed64":
			v, err := d.Int64()
			if err != nil {
				return err
			}
			p.OptSfixed64 = v
		case "optBool":
			v, err := d.Bool()
			if err != nil {
				return err
			}
			p.OptBool = v
		case "optString":
			v, err := d.Str()
			if err != nil {
				return err
			}
			p.OptString = v
		case "optBytes":
			v, err := d.Base64()
			if err != nil {
				return err
			}
			p.OptBytes = v
		case "optStatus":
			v, err := d.Int32()
			if err != nil {
				return err
			}
			p.OptStatus = Status(v)
		case "optPriority":
			v, err := d.Int32()
			if err != nil {
				return err
			}
			p.OptPriority = Priority(v)
		case "regularDouble":
			v, err := d.Float64()
			if err != nil {
				return err
			}
			p.RegularDouble = v
		case "regularString":
			v, err := d.Str()
			if err != nil {
				return err
			}
			p.RegularString = v
		case "regularBool":
			v, err := d.Bool()
			if err != nil {
				return err
			}
			p.RegularBool = v
		default:
			return d.Skip()
		}
		return nil
	})
}

// UnmarshalJSON implements json.Unmarshaler using jx
func (p *OptionalShowcasePlain) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return p.UnmarshalJX(d)
}

// optionalShowcasePlainPool is a sync.Pool for OptionalShowcasePlain objects
var optionalShowcasePlainPool = sync.Pool{
	New: func() interface{} {
		return &OptionalShowcasePlain{}
	},
}

// GetOptionalShowcasePlain returns a OptionalShowcasePlain from the pool
func GetOptionalShowcasePlain() *OptionalShowcasePlain {
	return optionalShowcasePlainPool.Get().(*OptionalShowcasePlain)
}

// PutOptionalShowcasePlain returns a OptionalShowcasePlain to the pool after resetting it
func PutOptionalShowcasePlain(p *OptionalShowcasePlain) {
	if p == nil {
		return
	}
	p.Reset()
	optionalShowcasePlainPool.Put(p)
}

// Reset clears all fields in OptionalShowcasePlain for reuse
func (p *OptionalShowcasePlain) Reset() {
	if p == nil {
		return
	}

	p.OptDouble = 0
	p.OptFloat = 0
	p.OptInt32 = 0
	p.OptInt64 = 0
	p.OptUint32 = 0
	p.OptUint64 = 0
	p.OptSint32 = 0
	p.OptSint64 = 0
	p.OptFixed32 = 0
	p.OptFixed64 = 0
	p.OptSfixed32 = 0
	p.OptSfixed64 = 0
	p.OptBool = false
	p.OptString = ""
	p.OptBytes = nil
	p.OptStatus = 0
	p.OptPriority = 0
	p.RegularDouble = 0
	p.RegularString = ""
	p.RegularBool = false
}

type OneofShowcasePlain struct {
	Id         string        `json:"id"`
	TextText   *TextContent  `json:"textText"`   // origin: oneof_embed, empath: text.text
	ImageImage *ImageContent `json:"imageImage"` // origin: oneof_embed, empath: image.image
	CodeCode   *CodeContent  `json:"codeCode"`   // origin: oneof_embed, empath: code.code
	// ContentCase indicates which variant of content oneof is set
	ContentCase string `json:"content_case,omitempty"`
}

// IntoPlain converts protobuf message to plain struct
func (pb *OneofShowcase) IntoPlain() *OneofShowcasePlain {
	if pb == nil {
		return nil
	}
	p := &OneofShowcasePlain{}

	// Detect content oneof case
	switch pb.Content.(type) {
	case *OneofShowcase_Text:
		p.ContentCase = "text"
	case *OneofShowcase_Image:
		p.ContentCase = "image"
	case *OneofShowcase_Code:
		p.ContentCase = "code"
	}

	p.Id = pb.Id
	// TextText from text.text
	if pb.GetText() != nil {
		p.TextText = pb.GetText()
	}
	// ImageImage from image.image
	if pb.GetImage() != nil {
		p.ImageImage = pb.GetImage()
	}
	// CodeCode from code.code
	if pb.GetCode() != nil {
		p.CodeCode = pb.GetCode()
	}
	return p
}

// IntoPb converts plain struct to protobuf message
func (p *OneofShowcasePlain) IntoPb() *OneofShowcase {
	if p == nil {
		return nil
	}
	pb := &OneofShowcase{}

	pb.Id = p.Id
	// TextText -> text.text
	if p.TextText != nil && p.ContentCase == "text" {
		pb.Content = &OneofShowcase_Text{Text: p.TextText}
	}
	// ImageImage -> image.image
	if p.ImageImage != nil && p.ContentCase == "image" {
		pb.Content = &OneofShowcase_Image{Image: p.ImageImage}
	}
	// CodeCode -> code.code
	if p.CodeCode != nil && p.ContentCase == "code" {
		pb.Content = &OneofShowcase_Code{Code: p.CodeCode}
	}
	return pb
}

// IntoPlainReuse converts protobuf message to existing plain struct (for pool usage)
func (pb *OneofShowcase) IntoPlainReuse(p *OneofShowcasePlain) {
	if pb == nil || p == nil {
		return
	}
	// Reset before filling
	p.Reset()

	// Detect content oneof case
	switch pb.Content.(type) {
	case *OneofShowcase_Text:
		p.ContentCase = "text"
	case *OneofShowcase_Image:
		p.ContentCase = "image"
	case *OneofShowcase_Code:
		p.ContentCase = "code"
	}

	p.Id = pb.Id
	// TextText from text.text
	if pb.GetText() != nil {
		p.TextText = pb.GetText()
	}
	// ImageImage from image.image
	if pb.GetImage() != nil {
		p.ImageImage = pb.GetImage()
	}
	// CodeCode from code.code
	if pb.GetCode() != nil {
		p.CodeCode = pb.GetCode()
	}
}

// MarshalJX encodes OneofShowcasePlain to JSON using jx.Encoder
func (p *OneofShowcasePlain) MarshalJX(e *jx.Encoder) {
	if p == nil {
		e.Null()
		return
	}

	e.ObjStart()

	if p.ContentCase != "" {
		e.FieldStart("content_case")
		e.Str(p.ContentCase)
	}
	if p.Id != "" {
		e.FieldStart("id")
		e.Str(p.Id)
	}
	if p.TextText != nil {
		e.FieldStart("textText")
		p.TextText.MarshalJX(e)
	}
	if p.ImageImage != nil {
		e.FieldStart("imageImage")
		p.ImageImage.MarshalJX(e)
	}
	if p.CodeCode != nil {
		e.FieldStart("codeCode")
		p.CodeCode.MarshalJX(e)
	}
	e.ObjEnd()
}

// MarshalJSON implements json.Marshaler using jx
func (p *OneofShowcasePlain) MarshalJSON() ([]byte, error) {
	e := jx.GetEncoder()
	defer jx.PutEncoder(e)
	p.MarshalJX(e)
	return e.Bytes(), nil
}

// UnmarshalJX decodes OneofShowcasePlain from JSON using jx.Decoder
func (p *OneofShowcasePlain) UnmarshalJX(d *jx.Decoder) error {
	if p == nil {
		return nil
	}

	return d.Obj(func(d *jx.Decoder, key string) error {
		switch key {
		case "content_case":
			v, err := d.Str()
			if err != nil {
				return err
			}
			p.ContentCase = v
		case "id":
			v, err := d.Str()
			if err != nil {
				return err
			}
			p.Id = v
		case "textText":
			p.TextText = &TextContent{}
			if err := p.TextText.UnmarshalJX(d); err != nil {
				return err
			}
		case "imageImage":
			p.ImageImage = &ImageContent{}
			if err := p.ImageImage.UnmarshalJX(d); err != nil {
				return err
			}
		case "codeCode":
			p.CodeCode = &CodeContent{}
			if err := p.CodeCode.UnmarshalJX(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// UnmarshalJSON implements json.Unmarshaler using jx
func (p *OneofShowcasePlain) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return p.UnmarshalJX(d)
}

// oneofShowcasePlainPool is a sync.Pool for OneofShowcasePlain objects
var oneofShowcasePlainPool = sync.Pool{
	New: func() interface{} {
		return &OneofShowcasePlain{}
	},
}

// GetOneofShowcasePlain returns a OneofShowcasePlain from the pool
func GetOneofShowcasePlain() *OneofShowcasePlain {
	return oneofShowcasePlainPool.Get().(*OneofShowcasePlain)
}

// PutOneofShowcasePlain returns a OneofShowcasePlain to the pool after resetting it
func PutOneofShowcasePlain(p *OneofShowcasePlain) {
	if p == nil {
		return
	}
	p.Reset()
	oneofShowcasePlainPool.Put(p)
}

// Reset clears all fields in OneofShowcasePlain for reuse
func (p *OneofShowcasePlain) Reset() {
	if p == nil {
		return
	}

	p.ContentCase = ""
	p.Id = ""
	p.TextText = nil
	p.ImageImage = nil
	p.CodeCode = nil
}

// This demonstrates oneof with embed=true where variants also have embed=true
//
//	Result: all fields from Heartbeat/ProcessStarted/ProcessExited/NetworkEvent
//	are flattened directly into PlatformEventPlain
type PlatformEventPlain struct {
	EventId                   string            `json:"eventId"`
	EventTime                 int64             `json:"eventTime"`
	Source                    string            `json:"source"`
	Labels                    map[string]string `json:"labels"`
	HeartbeatTimestamp        int64             `json:"heartbeatTimestamp"`        // origin: oneof_embed, empath: heartbeat.timestamp
	HeartbeatNodeId           string            `json:"heartbeatNodeId"`           // origin: oneof_embed, empath: heartbeat.node_id
	HeartbeatCpuPercent       int32             `json:"heartbeatCpuPercent"`       // origin: oneof_embed, empath: heartbeat.cpu_percent
	HeartbeatMemoryBytes      int64             `json:"heartbeatMemoryBytes"`      // origin: oneof_embed, empath: heartbeat.memory_bytes
	ProcessStartedProcessId   string            `json:"processStartedProcessId"`   // origin: oneof_embed, empath: process_started.process_id
	ProcessStartedCommand     string            `json:"processStartedCommand"`     // origin: oneof_embed, empath: process_started.command
	ProcessStartedArgs        []string          `json:"processStartedArgs"`        // origin: oneof_embed, empath: process_started.args
	ProcessStartedStartTime   int64             `json:"processStartedStartTime"`   // origin: oneof_embed, empath: process_started.start_time
	ProcessExitedProcessId    string            `json:"processExitedProcessId"`    // origin: oneof_embed, empath: process_exited.process_id
	ProcessExitedExitCode     int32             `json:"processExitedExitCode"`     // origin: oneof_embed, empath: process_exited.exit_code
	ProcessExitedExitTime     int64             `json:"processExitedExitTime"`     // origin: oneof_embed, empath: process_exited.exit_time
	ProcessExitedSignal       string            `json:"processExitedSignal"`       // origin: oneof_embed, empath: process_exited.signal
	NetworkEventInterfaceName string            `json:"networkEventInterfaceName"` // origin: oneof_embed, empath: network_event.interface_name
	NetworkEventRemoteAddr    string            `json:"networkEventRemoteAddr"`    // origin: oneof_embed, empath: network_event.remote_addr
	NetworkEventRemotePort    int32             `json:"networkEventRemotePort"`    // origin: oneof_embed, empath: network_event.remote_port
	NetworkEventProtocol      string            `json:"networkEventProtocol"`      // origin: oneof_embed, empath: network_event.protocol
	NetworkEventBytesSent     int64             `json:"networkEventBytesSent"`     // origin: oneof_embed, empath: network_event.bytes_sent
	NetworkEventBytesReceived int64             `json:"networkEventBytesReceived"` // origin: oneof_embed, empath: network_event.bytes_received
	// PlatformEventCase indicates which variant of platform_event oneof is set
	PlatformEventCase string `json:"platform_event_case,omitempty"`
}

// IntoPlain converts protobuf message to plain struct
func (pb *PlatformEvent) IntoPlain() *PlatformEventPlain {
	if pb == nil {
		return nil
	}
	p := &PlatformEventPlain{}

	// Detect platform_event oneof case
	switch pb.PlatformEvent.(type) {
	case *PlatformEvent_Heartbeat:
		p.PlatformEventCase = "heartbeat"
	case *PlatformEvent_ProcessStarted:
		p.PlatformEventCase = "process_started"
	case *PlatformEvent_ProcessExited:
		p.PlatformEventCase = "process_exited"
	case *PlatformEvent_NetworkEvent:
		p.PlatformEventCase = "network_event"
	}

	p.EventId = pb.EventId
	p.EventTime = pb.EventTime
	p.Source = pb.Source
	p.Labels = pb.Labels
	// HeartbeatTimestamp from heartbeat.timestamp
	if pb.GetHeartbeat() != nil {
		p.HeartbeatTimestamp = pb.GetHeartbeat().GetTimestamp()
	}
	// HeartbeatNodeId from heartbeat.node_id
	if pb.GetHeartbeat() != nil {
		p.HeartbeatNodeId = pb.GetHeartbeat().GetNodeId()
	}
	// HeartbeatCpuPercent from heartbeat.cpu_percent
	if pb.GetHeartbeat() != nil {
		p.HeartbeatCpuPercent = pb.GetHeartbeat().GetCpuPercent()
	}
	// HeartbeatMemoryBytes from heartbeat.memory_bytes
	if pb.GetHeartbeat() != nil {
		p.HeartbeatMemoryBytes = pb.GetHeartbeat().GetMemoryBytes()
	}
	// ProcessStartedProcessId from process_started.process_id
	if pb.GetProcessStarted() != nil {
		p.ProcessStartedProcessId = pb.GetProcessStarted().GetProcessId()
	}
	// ProcessStartedCommand from process_started.command
	if pb.GetProcessStarted() != nil {
		p.ProcessStartedCommand = pb.GetProcessStarted().GetCommand()
	}
	// ProcessStartedArgs from process_started.args
	if pb.GetProcessStarted() != nil {
		p.ProcessStartedArgs = pb.GetProcessStarted().GetArgs()
	}
	// ProcessStartedStartTime from process_started.start_time
	if pb.GetProcessStarted() != nil {
		p.ProcessStartedStartTime = pb.GetProcessStarted().GetStartTime()
	}
	// ProcessExitedProcessId from process_exited.process_id
	if pb.GetProcessExited() != nil {
		p.ProcessExitedProcessId = pb.GetProcessExited().GetProcessId()
	}
	// ProcessExitedExitCode from process_exited.exit_code
	if pb.GetProcessExited() != nil {
		p.ProcessExitedExitCode = pb.GetProcessExited().GetExitCode()
	}
	// ProcessExitedExitTime from process_exited.exit_time
	if pb.GetProcessExited() != nil {
		p.ProcessExitedExitTime = pb.GetProcessExited().GetExitTime()
	}
	// ProcessExitedSignal from process_exited.signal
	if pb.GetProcessExited() != nil {
		p.ProcessExitedSignal = pb.GetProcessExited().GetSignal()
	}
	// NetworkEventInterfaceName from network_event.interface_name
	if pb.GetNetworkEvent() != nil {
		p.NetworkEventInterfaceName = pb.GetNetworkEvent().GetInterfaceName()
	}
	// NetworkEventRemoteAddr from network_event.remote_addr
	if pb.GetNetworkEvent() != nil {
		p.NetworkEventRemoteAddr = pb.GetNetworkEvent().GetRemoteAddr()
	}
	// NetworkEventRemotePort from network_event.remote_port
	if pb.GetNetworkEvent() != nil {
		p.NetworkEventRemotePort = pb.GetNetworkEvent().GetRemotePort()
	}
	// NetworkEventProtocol from network_event.protocol
	if pb.GetNetworkEvent() != nil {
		p.NetworkEventProtocol = pb.GetNetworkEvent().GetProtocol()
	}
	// NetworkEventBytesSent from network_event.bytes_sent
	if pb.GetNetworkEvent() != nil {
		p.NetworkEventBytesSent = pb.GetNetworkEvent().GetBytesSent()
	}
	// NetworkEventBytesReceived from network_event.bytes_received
	if pb.GetNetworkEvent() != nil {
		p.NetworkEventBytesReceived = pb.GetNetworkEvent().GetBytesReceived()
	}
	return p
}

// IntoPb converts plain struct to protobuf message
func (p *PlatformEventPlain) IntoPb() *PlatformEvent {
	if p == nil {
		return nil
	}
	pb := &PlatformEvent{}

	pb.EventId = p.EventId
	pb.EventTime = p.EventTime
	pb.Source = p.Source
	pb.Labels = p.Labels
	// HeartbeatTimestamp -> heartbeat.timestamp
	if p.PlatformEventCase == "heartbeat" {
		if _, ok := pb.PlatformEvent.(*PlatformEvent_Heartbeat); !ok || pb.PlatformEvent == nil {
			pb.PlatformEvent = &PlatformEvent_Heartbeat{Heartbeat: &Heartbeat{}}
		}
		pb.PlatformEvent.(*PlatformEvent_Heartbeat).Heartbeat.Timestamp = p.HeartbeatTimestamp
	}
	// HeartbeatNodeId -> heartbeat.node_id
	if p.PlatformEventCase == "heartbeat" {
		if _, ok := pb.PlatformEvent.(*PlatformEvent_Heartbeat); !ok || pb.PlatformEvent == nil {
			pb.PlatformEvent = &PlatformEvent_Heartbeat{Heartbeat: &Heartbeat{}}
		}
		pb.PlatformEvent.(*PlatformEvent_Heartbeat).Heartbeat.NodeId = p.HeartbeatNodeId
	}
	// HeartbeatCpuPercent -> heartbeat.cpu_percent
	if p.PlatformEventCase == "heartbeat" {
		if _, ok := pb.PlatformEvent.(*PlatformEvent_Heartbeat); !ok || pb.PlatformEvent == nil {
			pb.PlatformEvent = &PlatformEvent_Heartbeat{Heartbeat: &Heartbeat{}}
		}
		pb.PlatformEvent.(*PlatformEvent_Heartbeat).Heartbeat.CpuPercent = p.HeartbeatCpuPercent
	}
	// HeartbeatMemoryBytes -> heartbeat.memory_bytes
	if p.PlatformEventCase == "heartbeat" {
		if _, ok := pb.PlatformEvent.(*PlatformEvent_Heartbeat); !ok || pb.PlatformEvent == nil {
			pb.PlatformEvent = &PlatformEvent_Heartbeat{Heartbeat: &Heartbeat{}}
		}
		pb.PlatformEvent.(*PlatformEvent_Heartbeat).Heartbeat.MemoryBytes = p.HeartbeatMemoryBytes
	}
	// ProcessStartedProcessId -> process_started.process_id
	if p.PlatformEventCase == "process_started" {
		if _, ok := pb.PlatformEvent.(*PlatformEvent_ProcessStarted); !ok || pb.PlatformEvent == nil {
			pb.PlatformEvent = &PlatformEvent_ProcessStarted{ProcessStarted: &ProcessStarted{}}
		}
		pb.PlatformEvent.(*PlatformEvent_ProcessStarted).ProcessStarted.ProcessId = p.ProcessStartedProcessId
	}
	// ProcessStartedCommand -> process_started.command
	if p.PlatformEventCase == "process_started" {
		if _, ok := pb.PlatformEvent.(*PlatformEvent_ProcessStarted); !ok || pb.PlatformEvent == nil {
			pb.PlatformEvent = &PlatformEvent_ProcessStarted{ProcessStarted: &ProcessStarted{}}
		}
		pb.PlatformEvent.(*PlatformEvent_ProcessStarted).ProcessStarted.Command = p.ProcessStartedCommand
	}
	// ProcessStartedArgs -> process_started.args
	if len(p.ProcessStartedArgs) > 0 && p.PlatformEventCase == "process_started" {
		if _, ok := pb.PlatformEvent.(*PlatformEvent_ProcessStarted); !ok || pb.PlatformEvent == nil {
			pb.PlatformEvent = &PlatformEvent_ProcessStarted{ProcessStarted: &ProcessStarted{}}
		}
		pb.PlatformEvent.(*PlatformEvent_ProcessStarted).ProcessStarted.Args = p.ProcessStartedArgs
	}
	// ProcessStartedStartTime -> process_started.start_time
	if p.PlatformEventCase == "process_started" {
		if _, ok := pb.PlatformEvent.(*PlatformEvent_ProcessStarted); !ok || pb.PlatformEvent == nil {
			pb.PlatformEvent = &PlatformEvent_ProcessStarted{ProcessStarted: &ProcessStarted{}}
		}
		pb.PlatformEvent.(*PlatformEvent_ProcessStarted).ProcessStarted.StartTime = p.ProcessStartedStartTime
	}
	// ProcessExitedProcessId -> process_exited.process_id
	if p.PlatformEventCase == "process_exited" {
		if _, ok := pb.PlatformEvent.(*PlatformEvent_ProcessExited); !ok || pb.PlatformEvent == nil {
			pb.PlatformEvent = &PlatformEvent_ProcessExited{ProcessExited: &ProcessExited{}}
		}
		pb.PlatformEvent.(*PlatformEvent_ProcessExited).ProcessExited.ProcessId = p.ProcessExitedProcessId
	}
	// ProcessExitedExitCode -> process_exited.exit_code
	if p.PlatformEventCase == "process_exited" {
		if _, ok := pb.PlatformEvent.(*PlatformEvent_ProcessExited); !ok || pb.PlatformEvent == nil {
			pb.PlatformEvent = &PlatformEvent_ProcessExited{ProcessExited: &ProcessExited{}}
		}
		pb.PlatformEvent.(*PlatformEvent_ProcessExited).ProcessExited.ExitCode = p.ProcessExitedExitCode
	}
	// ProcessExitedExitTime -> process_exited.exit_time
	if p.PlatformEventCase == "process_exited" {
		if _, ok := pb.PlatformEvent.(*PlatformEvent_ProcessExited); !ok || pb.PlatformEvent == nil {
			pb.PlatformEvent = &PlatformEvent_ProcessExited{ProcessExited: &ProcessExited{}}
		}
		pb.PlatformEvent.(*PlatformEvent_ProcessExited).ProcessExited.ExitTime = p.ProcessExitedExitTime
	}
	// ProcessExitedSignal -> process_exited.signal
	if p.PlatformEventCase == "process_exited" {
		if _, ok := pb.PlatformEvent.(*PlatformEvent_ProcessExited); !ok || pb.PlatformEvent == nil {
			pb.PlatformEvent = &PlatformEvent_ProcessExited{ProcessExited: &ProcessExited{}}
		}
		pb.PlatformEvent.(*PlatformEvent_ProcessExited).ProcessExited.Signal = p.ProcessExitedSignal
	}
	// NetworkEventInterfaceName -> network_event.interface_name
	if p.PlatformEventCase == "network_event" {
		if _, ok := pb.PlatformEvent.(*PlatformEvent_NetworkEvent); !ok || pb.PlatformEvent == nil {
			pb.PlatformEvent = &PlatformEvent_NetworkEvent{NetworkEvent: &NetworkEvent{}}
		}
		pb.PlatformEvent.(*PlatformEvent_NetworkEvent).NetworkEvent.InterfaceName = p.NetworkEventInterfaceName
	}
	// NetworkEventRemoteAddr -> network_event.remote_addr
	if p.PlatformEventCase == "network_event" {
		if _, ok := pb.PlatformEvent.(*PlatformEvent_NetworkEvent); !ok || pb.PlatformEvent == nil {
			pb.PlatformEvent = &PlatformEvent_NetworkEvent{NetworkEvent: &NetworkEvent{}}
		}
		pb.PlatformEvent.(*PlatformEvent_NetworkEvent).NetworkEvent.RemoteAddr = p.NetworkEventRemoteAddr
	}
	// NetworkEventRemotePort -> network_event.remote_port
	if p.PlatformEventCase == "network_event" {
		if _, ok := pb.PlatformEvent.(*PlatformEvent_NetworkEvent); !ok || pb.PlatformEvent == nil {
			pb.PlatformEvent = &PlatformEvent_NetworkEvent{NetworkEvent: &NetworkEvent{}}
		}
		pb.PlatformEvent.(*PlatformEvent_NetworkEvent).NetworkEvent.RemotePort = p.NetworkEventRemotePort
	}
	// NetworkEventProtocol -> network_event.protocol
	if p.PlatformEventCase == "network_event" {
		if _, ok := pb.PlatformEvent.(*PlatformEvent_NetworkEvent); !ok || pb.PlatformEvent == nil {
			pb.PlatformEvent = &PlatformEvent_NetworkEvent{NetworkEvent: &NetworkEvent{}}
		}
		pb.PlatformEvent.(*PlatformEvent_NetworkEvent).NetworkEvent.Protocol = p.NetworkEventProtocol
	}
	// NetworkEventBytesSent -> network_event.bytes_sent
	if p.PlatformEventCase == "network_event" {
		if _, ok := pb.PlatformEvent.(*PlatformEvent_NetworkEvent); !ok || pb.PlatformEvent == nil {
			pb.PlatformEvent = &PlatformEvent_NetworkEvent{NetworkEvent: &NetworkEvent{}}
		}
		pb.PlatformEvent.(*PlatformEvent_NetworkEvent).NetworkEvent.BytesSent = p.NetworkEventBytesSent
	}
	// NetworkEventBytesReceived -> network_event.bytes_received
	if p.PlatformEventCase == "network_event" {
		if _, ok := pb.PlatformEvent.(*PlatformEvent_NetworkEvent); !ok || pb.PlatformEvent == nil {
			pb.PlatformEvent = &PlatformEvent_NetworkEvent{NetworkEvent: &NetworkEvent{}}
		}
		pb.PlatformEvent.(*PlatformEvent_NetworkEvent).NetworkEvent.BytesReceived = p.NetworkEventBytesReceived
	}
	return pb
}

// IntoPlainReuse converts protobuf message to existing plain struct (for pool usage)
func (pb *PlatformEvent) IntoPlainReuse(p *PlatformEventPlain) {
	if pb == nil || p == nil {
		return
	}
	// Reset before filling
	p.Reset()

	// Detect platform_event oneof case
	switch pb.PlatformEvent.(type) {
	case *PlatformEvent_Heartbeat:
		p.PlatformEventCase = "heartbeat"
	case *PlatformEvent_ProcessStarted:
		p.PlatformEventCase = "process_started"
	case *PlatformEvent_ProcessExited:
		p.PlatformEventCase = "process_exited"
	case *PlatformEvent_NetworkEvent:
		p.PlatformEventCase = "network_event"
	}

	p.EventId = pb.EventId
	p.EventTime = pb.EventTime
	p.Source = pb.Source
	p.Labels = pb.Labels
	// HeartbeatTimestamp from heartbeat.timestamp
	if pb.GetHeartbeat() != nil {
		p.HeartbeatTimestamp = pb.GetHeartbeat().GetTimestamp()
	}
	// HeartbeatNodeId from heartbeat.node_id
	if pb.GetHeartbeat() != nil {
		p.HeartbeatNodeId = pb.GetHeartbeat().GetNodeId()
	}
	// HeartbeatCpuPercent from heartbeat.cpu_percent
	if pb.GetHeartbeat() != nil {
		p.HeartbeatCpuPercent = pb.GetHeartbeat().GetCpuPercent()
	}
	// HeartbeatMemoryBytes from heartbeat.memory_bytes
	if pb.GetHeartbeat() != nil {
		p.HeartbeatMemoryBytes = pb.GetHeartbeat().GetMemoryBytes()
	}
	// ProcessStartedProcessId from process_started.process_id
	if pb.GetProcessStarted() != nil {
		p.ProcessStartedProcessId = pb.GetProcessStarted().GetProcessId()
	}
	// ProcessStartedCommand from process_started.command
	if pb.GetProcessStarted() != nil {
		p.ProcessStartedCommand = pb.GetProcessStarted().GetCommand()
	}
	// ProcessStartedArgs from process_started.args
	if pb.GetProcessStarted() != nil {
		p.ProcessStartedArgs = pb.GetProcessStarted().GetArgs()
	}
	// ProcessStartedStartTime from process_started.start_time
	if pb.GetProcessStarted() != nil {
		p.ProcessStartedStartTime = pb.GetProcessStarted().GetStartTime()
	}
	// ProcessExitedProcessId from process_exited.process_id
	if pb.GetProcessExited() != nil {
		p.ProcessExitedProcessId = pb.GetProcessExited().GetProcessId()
	}
	// ProcessExitedExitCode from process_exited.exit_code
	if pb.GetProcessExited() != nil {
		p.ProcessExitedExitCode = pb.GetProcessExited().GetExitCode()
	}
	// ProcessExitedExitTime from process_exited.exit_time
	if pb.GetProcessExited() != nil {
		p.ProcessExitedExitTime = pb.GetProcessExited().GetExitTime()
	}
	// ProcessExitedSignal from process_exited.signal
	if pb.GetProcessExited() != nil {
		p.ProcessExitedSignal = pb.GetProcessExited().GetSignal()
	}
	// NetworkEventInterfaceName from network_event.interface_name
	if pb.GetNetworkEvent() != nil {
		p.NetworkEventInterfaceName = pb.GetNetworkEvent().GetInterfaceName()
	}
	// NetworkEventRemoteAddr from network_event.remote_addr
	if pb.GetNetworkEvent() != nil {
		p.NetworkEventRemoteAddr = pb.GetNetworkEvent().GetRemoteAddr()
	}
	// NetworkEventRemotePort from network_event.remote_port
	if pb.GetNetworkEvent() != nil {
		p.NetworkEventRemotePort = pb.GetNetworkEvent().GetRemotePort()
	}
	// NetworkEventProtocol from network_event.protocol
	if pb.GetNetworkEvent() != nil {
		p.NetworkEventProtocol = pb.GetNetworkEvent().GetProtocol()
	}
	// NetworkEventBytesSent from network_event.bytes_sent
	if pb.GetNetworkEvent() != nil {
		p.NetworkEventBytesSent = pb.GetNetworkEvent().GetBytesSent()
	}
	// NetworkEventBytesReceived from network_event.bytes_received
	if pb.GetNetworkEvent() != nil {
		p.NetworkEventBytesReceived = pb.GetNetworkEvent().GetBytesReceived()
	}
}

// MarshalJX encodes PlatformEventPlain to JSON using jx.Encoder
func (p *PlatformEventPlain) MarshalJX(e *jx.Encoder) {
	if p == nil {
		e.Null()
		return
	}

	e.ObjStart()

	if p.PlatformEventCase != "" {
		e.FieldStart("platform_event_case")
		e.Str(p.PlatformEventCase)
	}
	if p.EventId != "" {
		e.FieldStart("eventId")
		e.Str(p.EventId)
	}
	if p.EventTime != 0 {
		e.FieldStart("eventTime")
		e.Int64(p.EventTime)
	}
	if p.Source != "" {
		e.FieldStart("source")
		e.Str(p.Source)
	}
	e.FieldStart("labels")
	e.ObjStart()
	for k, v := range p.Labels {
		e.FieldStart(k)
		e.Str(v)
	}
	e.ObjEnd()
	if p.HeartbeatTimestamp != 0 {
		e.FieldStart("heartbeatTimestamp")
		e.Int64(p.HeartbeatTimestamp)
	}
	if p.HeartbeatNodeId != "" {
		e.FieldStart("heartbeatNodeId")
		e.Str(p.HeartbeatNodeId)
	}
	if p.HeartbeatCpuPercent != 0 {
		e.FieldStart("heartbeatCpuPercent")
		e.Int32(p.HeartbeatCpuPercent)
	}
	if p.HeartbeatMemoryBytes != 0 {
		e.FieldStart("heartbeatMemoryBytes")
		e.Int64(p.HeartbeatMemoryBytes)
	}
	if p.ProcessStartedProcessId != "" {
		e.FieldStart("processStartedProcessId")
		e.Str(p.ProcessStartedProcessId)
	}
	if p.ProcessStartedCommand != "" {
		e.FieldStart("processStartedCommand")
		e.Str(p.ProcessStartedCommand)
	}
	if len(p.ProcessStartedArgs) > 0 {
		e.FieldStart("processStartedArgs")
		e.ArrStart()
		for _, v := range p.ProcessStartedArgs {
			e.Str(v)
		}
		e.ArrEnd()
	}
	if p.ProcessStartedStartTime != 0 {
		e.FieldStart("processStartedStartTime")
		e.Int64(p.ProcessStartedStartTime)
	}
	if p.ProcessExitedProcessId != "" {
		e.FieldStart("processExitedProcessId")
		e.Str(p.ProcessExitedProcessId)
	}
	if p.ProcessExitedExitCode != 0 {
		e.FieldStart("processExitedExitCode")
		e.Int32(p.ProcessExitedExitCode)
	}
	if p.ProcessExitedExitTime != 0 {
		e.FieldStart("processExitedExitTime")
		e.Int64(p.ProcessExitedExitTime)
	}
	if p.ProcessExitedSignal != "" {
		e.FieldStart("processExitedSignal")
		e.Str(p.ProcessExitedSignal)
	}
	if p.NetworkEventInterfaceName != "" {
		e.FieldStart("networkEventInterfaceName")
		e.Str(p.NetworkEventInterfaceName)
	}
	if p.NetworkEventRemoteAddr != "" {
		e.FieldStart("networkEventRemoteAddr")
		e.Str(p.NetworkEventRemoteAddr)
	}
	if p.NetworkEventRemotePort != 0 {
		e.FieldStart("networkEventRemotePort")
		e.Int32(p.NetworkEventRemotePort)
	}
	if p.NetworkEventProtocol != "" {
		e.FieldStart("networkEventProtocol")
		e.Str(p.NetworkEventProtocol)
	}
	if p.NetworkEventBytesSent != 0 {
		e.FieldStart("networkEventBytesSent")
		e.Int64(p.NetworkEventBytesSent)
	}
	if p.NetworkEventBytesReceived != 0 {
		e.FieldStart("networkEventBytesReceived")
		e.Int64(p.NetworkEventBytesReceived)
	}
	e.ObjEnd()
}

// MarshalJSON implements json.Marshaler using jx
func (p *PlatformEventPlain) MarshalJSON() ([]byte, error) {
	e := jx.GetEncoder()
	defer jx.PutEncoder(e)
	p.MarshalJX(e)
	return e.Bytes(), nil
}

// UnmarshalJX decodes PlatformEventPlain from JSON using jx.Decoder
func (p *PlatformEventPlain) UnmarshalJX(d *jx.Decoder) error {
	if p == nil {
		return nil
	}

	return d.Obj(func(d *jx.Decoder, key string) error {
		switch key {
		case "platform_event_case":
			v, err := d.Str()
			if err != nil {
				return err
			}
			p.PlatformEventCase = v
		case "eventId":
			v, err := d.Str()
			if err != nil {
				return err
			}
			p.EventId = v
		case "eventTime":
			v, err := d.Int64()
			if err != nil {
				return err
			}
			p.EventTime = v
		case "source":
			v, err := d.Str()
			if err != nil {
				return err
			}
			p.Source = v
		case "labels":
			if p.Labels == nil {
				p.Labels = make(map[string]string)
			}
			return d.Obj(func(d *jx.Decoder, key string) error {
				v, err := d.Str()
				if err != nil {
					return err
				}
				p.Labels[key] = v
				return nil
			})
		case "heartbeatTimestamp":
			v, err := d.Int64()
			if err != nil {
				return err
			}
			p.HeartbeatTimestamp = v
		case "heartbeatNodeId":
			v, err := d.Str()
			if err != nil {
				return err
			}
			p.HeartbeatNodeId = v
		case "heartbeatCpuPercent":
			v, err := d.Int32()
			if err != nil {
				return err
			}
			p.HeartbeatCpuPercent = v
		case "heartbeatMemoryBytes":
			v, err := d.Int64()
			if err != nil {
				return err
			}
			p.HeartbeatMemoryBytes = v
		case "processStartedProcessId":
			v, err := d.Str()
			if err != nil {
				return err
			}
			p.ProcessStartedProcessId = v
		case "processStartedCommand":
			v, err := d.Str()
			if err != nil {
				return err
			}
			p.ProcessStartedCommand = v
		case "processStartedArgs":
			if err := d.Arr(func(d *jx.Decoder) error {
				v, err := d.Str()
				if err != nil {
					return err
				}
				p.ProcessStartedArgs = append(p.ProcessStartedArgs, v)
				return nil
			}); err != nil {
				return err
			}
		case "processStartedStartTime":
			v, err := d.Int64()
			if err != nil {
				return err
			}
			p.ProcessStartedStartTime = v
		case "processExitedProcessId":
			v, err := d.Str()
			if err != nil {
				return err
			}
			p.ProcessExitedProcessId = v
		case "processExitedExitCode":
			v, err := d.Int32()
			if err != nil {
				return err
			}
			p.ProcessExitedExitCode = v
		case "processExitedExitTime":
			v, err := d.Int64()
			if err != nil {
				return err
			}
			p.ProcessExitedExitTime = v
		case "processExitedSignal":
			v, err := d.Str()
			if err != nil {
				return err
			}
			p.ProcessExitedSignal = v
		case "networkEventInterfaceName":
			v, err := d.Str()
			if err != nil {
				return err
			}
			p.NetworkEventInterfaceName = v
		case "networkEventRemoteAddr":
			v, err := d.Str()
			if err != nil {
				return err
			}
			p.NetworkEventRemoteAddr = v
		case "networkEventRemotePort":
			v, err := d.Int32()
			if err != nil {
				return err
			}
			p.NetworkEventRemotePort = v
		case "networkEventProtocol":
			v, err := d.Str()
			if err != nil {
				return err
			}
			p.NetworkEventProtocol = v
		case "networkEventBytesSent":
			v, err := d.Int64()
			if err != nil {
				return err
			}
			p.NetworkEventBytesSent = v
		case "networkEventBytesReceived":
			v, err := d.Int64()
			if err != nil {
				return err
			}
			p.NetworkEventBytesReceived = v
		default:
			return d.Skip()
		}
		return nil
	})
}

// UnmarshalJSON implements json.Unmarshaler using jx
func (p *PlatformEventPlain) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return p.UnmarshalJX(d)
}

// platformEventPlainPool is a sync.Pool for PlatformEventPlain objects
var platformEventPlainPool = sync.Pool{
	New: func() interface{} {
		return &PlatformEventPlain{}
	},
}

// GetPlatformEventPlain returns a PlatformEventPlain from the pool
func GetPlatformEventPlain() *PlatformEventPlain {
	return platformEventPlainPool.Get().(*PlatformEventPlain)
}

// PutPlatformEventPlain returns a PlatformEventPlain to the pool after resetting it
func PutPlatformEventPlain(p *PlatformEventPlain) {
	if p == nil {
		return
	}
	p.Reset()
	platformEventPlainPool.Put(p)
}

// Reset clears all fields in PlatformEventPlain for reuse
func (p *PlatformEventPlain) Reset() {
	if p == nil {
		return
	}

	p.PlatformEventCase = ""
	p.EventId = ""
	p.EventTime = 0
	p.Source = ""
	for k := range p.Labels {
		delete(p.Labels, k)
	}
	p.HeartbeatTimestamp = 0
	p.HeartbeatNodeId = ""
	p.HeartbeatCpuPercent = 0
	p.HeartbeatMemoryBytes = 0
	p.ProcessStartedProcessId = ""
	p.ProcessStartedCommand = ""
	p.ProcessStartedArgs = p.ProcessStartedArgs[:0]
	p.ProcessStartedStartTime = 0
	p.ProcessExitedProcessId = ""
	p.ProcessExitedExitCode = 0
	p.ProcessExitedExitTime = 0
	p.ProcessExitedSignal = ""
	p.NetworkEventInterfaceName = ""
	p.NetworkEventRemoteAddr = ""
	p.NetworkEventRemotePort = 0
	p.NetworkEventProtocol = ""
	p.NetworkEventBytesSent = 0
	p.NetworkEventBytesReceived = 0
}

type DeprecatedShowcasePlain struct {
	Id          string `json:"id"`
	Name        string `json:"name"`
	OldField    string `json:"oldField"`
	LegacyCount int32  `json:"legacyCount"`
	NewField    string `json:"newField"`
}

// IntoPlain converts protobuf message to plain struct
func (pb *DeprecatedShowcase) IntoPlain() *DeprecatedShowcasePlain {
	if pb == nil {
		return nil
	}
	p := &DeprecatedShowcasePlain{}

	p.Id = pb.Id
	p.Name = pb.Name
	p.OldField = pb.OldField
	p.LegacyCount = pb.LegacyCount
	p.NewField = pb.NewField
	return p
}

// IntoPb converts plain struct to protobuf message
func (p *DeprecatedShowcasePlain) IntoPb() *DeprecatedShowcase {
	if p == nil {
		return nil
	}
	pb := &DeprecatedShowcase{}

	pb.Id = p.Id
	pb.Name = p.Name
	pb.OldField = p.OldField
	pb.LegacyCount = p.LegacyCount
	pb.NewField = p.NewField
	return pb
}

// IntoPlainReuse converts protobuf message to existing plain struct (for pool usage)
func (pb *DeprecatedShowcase) IntoPlainReuse(p *DeprecatedShowcasePlain) {
	if pb == nil || p == nil {
		return
	}
	// Reset before filling
	p.Reset()

	p.Id = pb.Id
	p.Name = pb.Name
	p.OldField = pb.OldField
	p.LegacyCount = pb.LegacyCount
	p.NewField = pb.NewField
}

// MarshalJX encodes DeprecatedShowcasePlain to JSON using jx.Encoder
func (p *DeprecatedShowcasePlain) MarshalJX(e *jx.Encoder) {
	if p == nil {
		e.Null()
		return
	}

	e.ObjStart()

	if p.Id != "" {
		e.FieldStart("id")
		e.Str(p.Id)
	}
	if p.Name != "" {
		e.FieldStart("name")
		e.Str(p.Name)
	}
	if p.OldField != "" {
		e.FieldStart("oldField")
		e.Str(p.OldField)
	}
	if p.LegacyCount != 0 {
		e.FieldStart("legacyCount")
		e.Int32(p.LegacyCount)
	}
	if p.NewField != "" {
		e.FieldStart("newField")
		e.Str(p.NewField)
	}
	e.ObjEnd()
}

// MarshalJSON implements json.Marshaler using jx
func (p *DeprecatedShowcasePlain) MarshalJSON() ([]byte, error) {
	e := jx.GetEncoder()
	defer jx.PutEncoder(e)
	p.MarshalJX(e)
	return e.Bytes(), nil
}

// UnmarshalJX decodes DeprecatedShowcasePlain from JSON using jx.Decoder
func (p *DeprecatedShowcasePlain) UnmarshalJX(d *jx.Decoder) error {
	if p == nil {
		return nil
	}

	return d.Obj(func(d *jx.Decoder, key string) error {
		switch key {
		case "id":
			v, err := d.Str()
			if err != nil {
				return err
			}
			p.Id = v
		case "name":
			v, err := d.Str()
			if err != nil {
				return err
			}
			p.Name = v
		case "oldField":
			v, err := d.Str()
			if err != nil {
				return err
			}
			p.OldField = v
		case "legacyCount":
			v, err := d.Int32()
			if err != nil {
				return err
			}
			p.LegacyCount = v
		case "newField":
			v, err := d.Str()
			if err != nil {
				return err
			}
			p.NewField = v
		default:
			return d.Skip()
		}
		return nil
	})
}

// UnmarshalJSON implements json.Unmarshaler using jx
func (p *DeprecatedShowcasePlain) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return p.UnmarshalJX(d)
}

// deprecatedShowcasePlainPool is a sync.Pool for DeprecatedShowcasePlain objects
var deprecatedShowcasePlainPool = sync.Pool{
	New: func() interface{} {
		return &DeprecatedShowcasePlain{}
	},
}

// GetDeprecatedShowcasePlain returns a DeprecatedShowcasePlain from the pool
func GetDeprecatedShowcasePlain() *DeprecatedShowcasePlain {
	return deprecatedShowcasePlainPool.Get().(*DeprecatedShowcasePlain)
}

// PutDeprecatedShowcasePlain returns a DeprecatedShowcasePlain to the pool after resetting it
func PutDeprecatedShowcasePlain(p *DeprecatedShowcasePlain) {
	if p == nil {
		return
	}
	p.Reset()
	deprecatedShowcasePlainPool.Put(p)
}

// Reset clears all fields in DeprecatedShowcasePlain for reuse
func (p *DeprecatedShowcasePlain) Reset() {
	if p == nil {
		return
	}

	p.Id = ""
	p.Name = ""
	p.OldField = ""
	p.LegacyCount = 0
	p.NewField = ""
}

type DefaultsShowcasePlain struct {
	EmptyString  string            `json:"emptyString"`
	ZeroInt      int32             `json:"zeroInt"`
	ZeroLong     int64             `json:"zeroLong"`
	ZeroDouble   float64           `json:"zeroDouble"`
	FalseBool    bool              `json:"falseBool"`
	EmptyBytes   []byte            `json:"emptyBytes"`
	ZeroEnum     Status            `json:"zeroEnum"`
	EmptyList    []string          `json:"emptyList"`
	EmptyIntList []int32           `json:"emptyIntList"`
	EmptyMap     map[string]string `json:"emptyMap"`
	NilMessage   *Address          `json:"nilMessage"`
}

// IntoPlain converts protobuf message to plain struct
func (pb *DefaultsShowcase) IntoPlain() *DefaultsShowcasePlain {
	if pb == nil {
		return nil
	}
	p := &DefaultsShowcasePlain{}

	p.EmptyString = pb.EmptyString
	p.ZeroInt = pb.ZeroInt
	p.ZeroLong = pb.ZeroLong
	p.ZeroDouble = pb.ZeroDouble
	p.FalseBool = pb.FalseBool
	p.EmptyBytes = pb.EmptyBytes
	p.ZeroEnum = pb.ZeroEnum
	p.EmptyList = pb.EmptyList
	p.EmptyIntList = pb.EmptyIntList
	p.EmptyMap = pb.EmptyMap
	p.NilMessage = pb.NilMessage
	return p
}

// IntoPb converts plain struct to protobuf message
func (p *DefaultsShowcasePlain) IntoPb() *DefaultsShowcase {
	if p == nil {
		return nil
	}
	pb := &DefaultsShowcase{}

	pb.EmptyString = p.EmptyString
	pb.ZeroInt = p.ZeroInt
	pb.ZeroLong = p.ZeroLong
	pb.ZeroDouble = p.ZeroDouble
	pb.FalseBool = p.FalseBool
	pb.EmptyBytes = p.EmptyBytes
	pb.ZeroEnum = p.ZeroEnum
	pb.EmptyList = p.EmptyList
	pb.EmptyIntList = p.EmptyIntList
	pb.EmptyMap = p.EmptyMap
	pb.NilMessage = p.NilMessage
	return pb
}

// IntoPlainReuse converts protobuf message to existing plain struct (for pool usage)
func (pb *DefaultsShowcase) IntoPlainReuse(p *DefaultsShowcasePlain) {
	if pb == nil || p == nil {
		return
	}
	// Reset before filling
	p.Reset()

	p.EmptyString = pb.EmptyString
	p.ZeroInt = pb.ZeroInt
	p.ZeroLong = pb.ZeroLong
	p.ZeroDouble = pb.ZeroDouble
	p.FalseBool = pb.FalseBool
	p.EmptyBytes = pb.EmptyBytes
	p.ZeroEnum = pb.ZeroEnum
	p.EmptyList = pb.EmptyList
	p.EmptyIntList = pb.EmptyIntList
	p.EmptyMap = pb.EmptyMap
	p.NilMessage = pb.NilMessage
}

// MarshalJX encodes DefaultsShowcasePlain to JSON using jx.Encoder
func (p *DefaultsShowcasePlain) MarshalJX(e *jx.Encoder) {
	if p == nil {
		e.Null()
		return
	}

	e.ObjStart()

	if p.EmptyString != "" {
		e.FieldStart("emptyString")
		e.Str(p.EmptyString)
	}
	if p.ZeroInt != 0 {
		e.FieldStart("zeroInt")
		e.Int32(p.ZeroInt)
	}
	if p.ZeroLong != 0 {
		e.FieldStart("zeroLong")
		e.Int64(p.ZeroLong)
	}
	if p.ZeroDouble != 0 {
		e.FieldStart("zeroDouble")
		e.Float64(p.ZeroDouble)
	}
	if p.FalseBool {
		e.FieldStart("falseBool")
		e.Bool(p.FalseBool)
	}
	if len(p.EmptyBytes) > 0 {
		e.FieldStart("emptyBytes")
		e.Base64(p.EmptyBytes)
	}
	e.FieldStart("zeroEnum")
	e.Int32(int32(p.ZeroEnum))
	if len(p.EmptyList) > 0 {
		e.FieldStart("emptyList")
		e.ArrStart()
		for _, v := range p.EmptyList {
			e.Str(v)
		}
		e.ArrEnd()
	}
	if len(p.EmptyIntList) > 0 {
		e.FieldStart("emptyIntList")
		e.ArrStart()
		for _, v := range p.EmptyIntList {
			e.Int32(v)
		}
		e.ArrEnd()
	}
	e.FieldStart("emptyMap")
	e.ObjStart()
	for k, v := range p.EmptyMap {
		e.FieldStart(k)
		e.Str(v)
	}
	e.ObjEnd()
	if p.NilMessage != nil {
		e.FieldStart("nilMessage")
		p.NilMessage.MarshalJX(e)
	}
	e.ObjEnd()
}

// MarshalJSON implements json.Marshaler using jx
func (p *DefaultsShowcasePlain) MarshalJSON() ([]byte, error) {
	e := jx.GetEncoder()
	defer jx.PutEncoder(e)
	p.MarshalJX(e)
	return e.Bytes(), nil
}

// UnmarshalJX decodes DefaultsShowcasePlain from JSON using jx.Decoder
func (p *DefaultsShowcasePlain) UnmarshalJX(d *jx.Decoder) error {
	if p == nil {
		return nil
	}

	return d.Obj(func(d *jx.Decoder, key string) error {
		switch key {
		case "emptyString":
			v, err := d.Str()
			if err != nil {
				return err
			}
			p.EmptyString = v
		case "zeroInt":
			v, err := d.Int32()
			if err != nil {
				return err
			}
			p.ZeroInt = v
		case "zeroLong":
			v, err := d.Int64()
			if err != nil {
				return err
			}
			p.ZeroLong = v
		case "zeroDouble":
			v, err := d.Float64()
			if err != nil {
				return err
			}
			p.ZeroDouble = v
		case "falseBool":
			v, err := d.Bool()
			if err != nil {
				return err
			}
			p.FalseBool = v
		case "emptyBytes":
			v, err := d.Base64()
			if err != nil {
				return err
			}
			p.EmptyBytes = v
		case "zeroEnum":
			v, err := d.Int32()
			if err != nil {
				return err
			}
			p.ZeroEnum = Status(v)
		case "emptyList":
			if err := d.Arr(func(d *jx.Decoder) error {
				v, err := d.Str()
				if err != nil {
					return err
				}
				p.EmptyList = append(p.EmptyList, v)
				return nil
			}); err != nil {
				return err
			}
		case "emptyIntList":
			if err := d.Arr(func(d *jx.Decoder) error {
				v, err := d.Int32()
				if err != nil {
					return err
				}
				p.EmptyIntList = append(p.EmptyIntList, v)
				return nil
			}); err != nil {
				return err
			}
		case "emptyMap":
			if p.EmptyMap == nil {
				p.EmptyMap = make(map[string]string)
			}
			return d.Obj(func(d *jx.Decoder, key string) error {
				v, err := d.Str()
				if err != nil {
					return err
				}
				p.EmptyMap[key] = v
				return nil
			})
		case "nilMessage":
			p.NilMessage = &Address{}
			if err := p.NilMessage.UnmarshalJX(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// UnmarshalJSON implements json.Unmarshaler using jx
func (p *DefaultsShowcasePlain) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return p.UnmarshalJX(d)
}

// defaultsShowcasePlainPool is a sync.Pool for DefaultsShowcasePlain objects
var defaultsShowcasePlainPool = sync.Pool{
	New: func() interface{} {
		return &DefaultsShowcasePlain{}
	},
}

// GetDefaultsShowcasePlain returns a DefaultsShowcasePlain from the pool
func GetDefaultsShowcasePlain() *DefaultsShowcasePlain {
	return defaultsShowcasePlainPool.Get().(*DefaultsShowcasePlain)
}

// PutDefaultsShowcasePlain returns a DefaultsShowcasePlain to the pool after resetting it
func PutDefaultsShowcasePlain(p *DefaultsShowcasePlain) {
	if p == nil {
		return
	}
	p.Reset()
	defaultsShowcasePlainPool.Put(p)
}

// Reset clears all fields in DefaultsShowcasePlain for reuse
func (p *DefaultsShowcasePlain) Reset() {
	if p == nil {
		return
	}

	p.EmptyString = ""
	p.ZeroInt = 0
	p.ZeroLong = 0
	p.ZeroDouble = 0
	p.FalseBool = false
	p.EmptyBytes = nil
	p.ZeroEnum = 0
	p.EmptyList = p.EmptyList[:0]
	p.EmptyIntList = p.EmptyIntList[:0]
	for k := range p.EmptyMap {
		delete(p.EmptyMap, k)
	}
	p.NilMessage = nil
}

type ComplexNestedPlain struct {
	Id            string                          `json:"id"`
	Inner         *ComplexNested_Inner            `json:"inner"`
	InnerList     []*ComplexNested_Inner          `json:"innerList"`
	InnerMap      map[string]*ComplexNested_Inner `json:"innerMap"`
	InnerEnum     ComplexNested_InnerEnum         `json:"innerEnum"`
	InnerEnumList []ComplexNested_InnerEnum       `json:"innerEnumList"`
}

// IntoPlain converts protobuf message to plain struct
func (pb *ComplexNested) IntoPlain() *ComplexNestedPlain {
	if pb == nil {
		return nil
	}
	p := &ComplexNestedPlain{}

	p.Id = pb.Id
	p.Inner = pb.Inner
	p.InnerList = pb.InnerList
	p.InnerMap = pb.InnerMap
	p.InnerEnum = pb.InnerEnum
	p.InnerEnumList = pb.InnerEnumList
	return p
}

// IntoPb converts plain struct to protobuf message
func (p *ComplexNestedPlain) IntoPb() *ComplexNested {
	if p == nil {
		return nil
	}
	pb := &ComplexNested{}

	pb.Id = p.Id
	pb.Inner = p.Inner
	pb.InnerList = p.InnerList
	pb.InnerMap = p.InnerMap
	pb.InnerEnum = p.InnerEnum
	pb.InnerEnumList = p.InnerEnumList
	return pb
}

// IntoPlainReuse converts protobuf message to existing plain struct (for pool usage)
func (pb *ComplexNested) IntoPlainReuse(p *ComplexNestedPlain) {
	if pb == nil || p == nil {
		return
	}
	// Reset before filling
	p.Reset()

	p.Id = pb.Id
	p.Inner = pb.Inner
	p.InnerList = pb.InnerList
	p.InnerMap = pb.InnerMap
	p.InnerEnum = pb.InnerEnum
	p.InnerEnumList = pb.InnerEnumList
}

// MarshalJX encodes ComplexNestedPlain to JSON using jx.Encoder
func (p *ComplexNestedPlain) MarshalJX(e *jx.Encoder) {
	if p == nil {
		e.Null()
		return
	}

	e.ObjStart()

	if p.Id != "" {
		e.FieldStart("id")
		e.Str(p.Id)
	}
	if p.Inner != nil {
		e.FieldStart("inner")
		p.Inner.MarshalJX(e)
	}
	if p.InnerList != nil {
		e.FieldStart("innerList")
		e.ArrStart()
		for _, v := range p.InnerList {
			v.MarshalJX(e)
		}
		e.ArrEnd()
	}
	e.FieldStart("innerMap")
	e.ObjStart()
	for k, v := range p.InnerMap {
		e.FieldStart(k)
		v.MarshalJX(e)
	}
	e.ObjEnd()
	e.FieldStart("innerEnum")
	e.Int32(int32(p.InnerEnum))
	if len(p.InnerEnumList) > 0 {
		e.FieldStart("innerEnumList")
		e.ArrStart()
		for _, v := range p.InnerEnumList {
			e.Int32(int32(v))
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

// MarshalJSON implements json.Marshaler using jx
func (p *ComplexNestedPlain) MarshalJSON() ([]byte, error) {
	e := jx.GetEncoder()
	defer jx.PutEncoder(e)
	p.MarshalJX(e)
	return e.Bytes(), nil
}

// UnmarshalJX decodes ComplexNestedPlain from JSON using jx.Decoder
func (p *ComplexNestedPlain) UnmarshalJX(d *jx.Decoder) error {
	if p == nil {
		return nil
	}

	return d.Obj(func(d *jx.Decoder, key string) error {
		switch key {
		case "id":
			v, err := d.Str()
			if err != nil {
				return err
			}
			p.Id = v
		case "inner":
			p.Inner = &ComplexNested_Inner{}
			if err := p.Inner.UnmarshalJX(d); err != nil {
				return err
			}
		case "innerList":
			if err := d.Arr(func(d *jx.Decoder) error {
				var v ComplexNested_Inner
				if err := v.UnmarshalJX(d); err != nil {
					return err
				}
				p.InnerList = append(p.InnerList, &v)
				return nil
			}); err != nil {
				return err
			}
		case "innerMap":
			if p.InnerMap == nil {
				p.InnerMap = make(map[string]*ComplexNested_Inner)
			}
			return d.Obj(func(d *jx.Decoder, key string) error {
				p.InnerMap[key] = &ComplexNested_Inner{}
				if err := p.InnerMap[key].UnmarshalJX(d); err != nil {
					return err
				}
				return nil
			})
		case "innerEnum":
			v, err := d.Int32()
			if err != nil {
				return err
			}
			p.InnerEnum = ComplexNested_InnerEnum(v)
		case "innerEnumList":
			if err := d.Arr(func(d *jx.Decoder) error {
				v, err := d.Int32()
				if err != nil {
					return err
				}
				p.InnerEnumList = append(p.InnerEnumList, ComplexNested_InnerEnum(v))
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// UnmarshalJSON implements json.Unmarshaler using jx
func (p *ComplexNestedPlain) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return p.UnmarshalJX(d)
}

// complexNestedPlainPool is a sync.Pool for ComplexNestedPlain objects
var complexNestedPlainPool = sync.Pool{
	New: func() interface{} {
		return &ComplexNestedPlain{}
	},
}

// GetComplexNestedPlain returns a ComplexNestedPlain from the pool
func GetComplexNestedPlain() *ComplexNestedPlain {
	return complexNestedPlainPool.Get().(*ComplexNestedPlain)
}

// PutComplexNestedPlain returns a ComplexNestedPlain to the pool after resetting it
func PutComplexNestedPlain(p *ComplexNestedPlain) {
	if p == nil {
		return
	}
	p.Reset()
	complexNestedPlainPool.Put(p)
}

// Reset clears all fields in ComplexNestedPlain for reuse
func (p *ComplexNestedPlain) Reset() {
	if p == nil {
		return
	}

	p.Id = ""
	p.Inner = nil
	p.InnerList = nil
	for k := range p.InnerMap {
		delete(p.InnerMap, k)
	}
	p.InnerEnum = 0
	p.InnerEnumList = p.InnerEnumList[:0]
}
