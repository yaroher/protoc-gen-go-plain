// Code generated by protoc-gen-go-plain. DO NOT EDIT.
// source: test/full/showcase.proto

package full

import (
	fmt "fmt"
	jx "github.com/go-faster/jx"
	protojson "google.golang.org/protobuf/encoding/protojson"
	proto "google.golang.org/protobuf/proto"
	anypb "google.golang.org/protobuf/types/known/anypb"
	durationpb "google.golang.org/protobuf/types/known/durationpb"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
	structpb "google.golang.org/protobuf/types/known/structpb"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
	wrapperspb "google.golang.org/protobuf/types/known/wrapperspb"
	strconv "strconv"
	sync "sync"
)

type DocumentPlain struct {
	Id                              string            `json:"id"`
	Title                           string            `json:"title"`
	Status                          Status            `json:"status"`
	Priority                        Priority          `json:"priority"`
	Description                     string            `json:"description"` // origin: type_alias, empath: description
	Version                         int64             `json:"version"`     // origin: type_alias, empath: version
	IsPublic                        bool              `json:"isPublic"`    // origin: type_alias, empath: is_public
	Email                           string            `json:"email"`
	Phone                           string            `json:"phone"`
	Address                         *Address          `json:"address"`
	Metadata                        *Metadata         `json:"metadata"`
	Performance                     []byte            `json:"performance"` // origin: serialized, empath: performance
	Keywords                        []string          `json:"keywords"`
	Attributes                      map[string]string `json:"attributes"`
	Locations                       []*Address        `json:"locations"`
	Structure                       *Level1           `json:"structure"`
	Children                        []DocumentPlain   `json:"children"`
	Parent                          *DocumentPlain    `json:"parent"`
	ContentTextContentTextContent   *TextContent      `json:"contentTextContentTextContent"`   // origin: oneof_embed, empath: content_text_content.text_content
	ContentImageContentImageContent *ImageContent     `json:"contentImageContentImageContent"` // origin: oneof_embed, empath: content_image_content.image_content
	ContentVideoContentVideoContent *VideoContent     `json:"contentVideoContentVideoContent"` // origin: oneof_embed, empath: content_video_content.video_content
	ContentCodeContentCodeContent   *CodeContent      `json:"contentCodeContentCodeContent"`   // origin: oneof_embed, empath: content_code_content.code_content
	ContentTableContentTableContent *TableContent     `json:"contentTableContentTableContent"` // origin: oneof_embed, empath: content_table_content.table_content
	ComputedHash                    string            `json:"computedHash"`                    // origin: virtual, empath: virtual
	IsValid                         bool              `json:"isValid"`                         // origin: virtual, empath: virtual
	// ContentCase indicates which variant of content oneof is set
	ContentCase string `json:"content_case,omitempty"`
	// Src_ contains indices of populated fields for sparse serialization
	Src_ []uint16 `json:"_src,omitempty"`
}

// IntoPlain converts protobuf message to plain struct
func (pb *Document) IntoPlain() *DocumentPlain {
	if pb == nil {
		return nil
	}
	p := &DocumentPlain{}

	// Detect content oneof case
	switch pb.Content.(type) {
	case *Document_TextContent:
		p.ContentCase = "text_content"
	case *Document_ImageContent:
		p.ContentCase = "image_content"
	case *Document_VideoContent:
		p.ContentCase = "video_content"
	case *Document_CodeContent:
		p.ContentCase = "code_content"
	case *Document_TableContent:
		p.ContentCase = "table_content"
	}

	p.Id = pb.Id
	p.Src_ = append(p.Src_, 0)
	p.Title = pb.Title
	p.Src_ = append(p.Src_, 1)
	p.Status = pb.Status
	p.Src_ = append(p.Src_, 2)
	p.Priority = pb.Priority
	p.Src_ = append(p.Src_, 3)
	// Description type alias from description
	if pb.GetDescription() != nil {
		p.Description = pb.GetDescription().GetValue()
		p.Src_ = append(p.Src_, 4)
	}
	// Version type alias from version
	if pb.GetVersion() != nil {
		p.Version = pb.GetVersion().GetValue()
		p.Src_ = append(p.Src_, 5)
	}
	// IsPublic type alias from is_public
	if pb.GetIsPublic() != nil {
		p.IsPublic = pb.GetIsPublic().GetValue()
		p.Src_ = append(p.Src_, 6)
	}
	// Email from
	if pb.GetAuthor() != nil {
		p.Email = pb.GetAuthor().GetEmail()
		p.Src_ = append(p.Src_, 7)
	}
	// Phone from
	if pb.GetAuthor() != nil {
		p.Phone = pb.GetAuthor().GetPhone()
		p.Src_ = append(p.Src_, 8)
	}
	// Address from
	if pb.GetAuthor() != nil && pb.GetAuthor().GetAddress() != nil {
		p.Address = pb.GetAuthor().GetAddress()
		p.Src_ = append(p.Src_, 9)
	}
	p.Metadata = pb.Metadata
	p.Src_ = append(p.Src_, 10)
	// Performance serialized from performance
	if pb.Performance != nil {
		if data, err := proto.Marshal(pb.Performance); err == nil {
			p.Performance = data
			p.Src_ = append(p.Src_, 11)
		}
	}
	p.Keywords = pb.Keywords
	p.Src_ = append(p.Src_, 12)
	p.Attributes = pb.Attributes
	p.Src_ = append(p.Src_, 13)
	p.Locations = pb.Locations
	p.Src_ = append(p.Src_, 14)
	p.Structure = pb.Structure
	p.Src_ = append(p.Src_, 15)
	if len(pb.Children) > 0 {
		p.Children = make([]DocumentPlain, len(pb.Children))
		for i, v := range pb.Children {
			if v != nil {
				p.Children[i] = *v.IntoPlain()
			}
		}
		p.Src_ = append(p.Src_, 16)
	}
	if pb.Parent != nil {
		p.Parent = pb.Parent.IntoPlain()
		p.Src_ = append(p.Src_, 17)
	}
	// ContentTextContentTextContent from content_text_content.text_content
	if pb.GetTextContent() != nil {
		p.ContentTextContentTextContent = pb.GetTextContent()
		p.Src_ = append(p.Src_, 18)
	}
	// ContentImageContentImageContent from content_image_content.image_content
	if pb.GetImageContent() != nil {
		p.ContentImageContentImageContent = pb.GetImageContent()
		p.Src_ = append(p.Src_, 19)
	}
	// ContentVideoContentVideoContent from content_video_content.video_content
	if pb.GetVideoContent() != nil {
		p.ContentVideoContentVideoContent = pb.GetVideoContent()
		p.Src_ = append(p.Src_, 20)
	}
	// ContentCodeContentCodeContent from content_code_content.code_content
	if pb.GetCodeContent() != nil {
		p.ContentCodeContentCodeContent = pb.GetCodeContent()
		p.Src_ = append(p.Src_, 21)
	}
	// ContentTableContentTableContent from content_table_content.table_content
	if pb.GetTableContent() != nil {
		p.ContentTableContentTableContent = pb.GetTableContent()
		p.Src_ = append(p.Src_, 22)
	}
	// ComputedHash is virtual, no source in protobuf
	// IsValid is virtual, no source in protobuf
	return p
}

// IntoPb converts plain struct to protobuf message
func (p *DocumentPlain) IntoPb() *Document {
	if p == nil {
		return nil
	}
	pb := &Document{}

	pb.Id = p.Id
	pb.Title = p.Title
	pb.Status = p.Status
	pb.Priority = p.Priority
	// Description type alias -> description
	if p.Description != "" {
		pb.Description = &StringValue{Value: p.Description}
	}
	// Version type alias -> version
	{
		pb.Version = &Int64Value{Value: p.Version}
	}
	// IsPublic type alias -> is_public
	{
		pb.IsPublic = &BoolValue{Value: p.IsPublic}
	}
	// Email ->
	if p.Email != "" {
		if pb.Author == nil {
			pb.Author = &ContactInfo{}
		}
		pb.Author.Email = p.Email
	}
	// Phone ->
	if p.Phone != "" {
		if pb.Author == nil {
			pb.Author = &ContactInfo{}
		}
		pb.Author.Phone = p.Phone
	}
	// Address ->
	if p.Address != nil {
		if pb.Author == nil {
			pb.Author = &ContactInfo{}
		}
		pb.Author.Address = p.Address
	}
	pb.Metadata = p.Metadata
	// Performance deserialize -> performance
	if len(p.Performance) > 0 {
		// TODO: Initialize parent structures for Performance
		var msg Metrics
		if err := proto.Unmarshal(p.Performance, &msg); err == nil {
			pb.Performance = &msg
		}
	}
	pb.Keywords = p.Keywords
	pb.Attributes = p.Attributes
	pb.Locations = p.Locations
	pb.Structure = p.Structure
	if len(p.Children) > 0 {
		pb.Children = make([]*Document, len(p.Children))
		for i := range p.Children {
			pb.Children[i] = (&p.Children[i]).IntoPb()
		}
	}
	if p.Parent != nil {
		pb.Parent = p.Parent.IntoPb()
	}
	// ContentTextContentTextContent -> content_text_content.text_content
	if p.ContentTextContentTextContent != nil && p.ContentCase == "text_content" {
		pb.Content = &Document_TextContent{TextContent: p.ContentTextContentTextContent}
	}
	// ContentImageContentImageContent -> content_image_content.image_content
	if p.ContentImageContentImageContent != nil && p.ContentCase == "image_content" {
		pb.Content = &Document_ImageContent{ImageContent: p.ContentImageContentImageContent}
	}
	// ContentVideoContentVideoContent -> content_video_content.video_content
	if p.ContentVideoContentVideoContent != nil && p.ContentCase == "video_content" {
		pb.Content = &Document_VideoContent{VideoContent: p.ContentVideoContentVideoContent}
	}
	// ContentCodeContentCodeContent -> content_code_content.code_content
	if p.ContentCodeContentCodeContent != nil && p.ContentCase == "code_content" {
		pb.Content = &Document_CodeContent{CodeContent: p.ContentCodeContentCodeContent}
	}
	// ContentTableContentTableContent -> content_table_content.table_content
	if p.ContentTableContentTableContent != nil && p.ContentCase == "table_content" {
		pb.Content = &Document_TableContent{TableContent: p.ContentTableContentTableContent}
	}
	// ComputedHash is virtual, skipping
	// IsValid is virtual, skipping
	return pb
}

// IntoPlainReuse converts protobuf message to existing plain struct (for pool usage)
func (pb *Document) IntoPlainReuse(p *DocumentPlain) {
	if pb == nil || p == nil {
		return
	}
	// Reset before filling
	p.Reset()

	// Detect content oneof case
	switch pb.Content.(type) {
	case *Document_TextContent:
		p.ContentCase = "text_content"
	case *Document_ImageContent:
		p.ContentCase = "image_content"
	case *Document_VideoContent:
		p.ContentCase = "video_content"
	case *Document_CodeContent:
		p.ContentCase = "code_content"
	case *Document_TableContent:
		p.ContentCase = "table_content"
	}

	p.Id = pb.Id
	p.Src_ = append(p.Src_, 0)
	p.Title = pb.Title
	p.Src_ = append(p.Src_, 1)
	p.Status = pb.Status
	p.Src_ = append(p.Src_, 2)
	p.Priority = pb.Priority
	p.Src_ = append(p.Src_, 3)
	// Description type alias from description
	if pb.GetDescription() != nil {
		p.Description = pb.GetDescription().GetValue()
		p.Src_ = append(p.Src_, 4)
	}
	// Version type alias from version
	if pb.GetVersion() != nil {
		p.Version = pb.GetVersion().GetValue()
		p.Src_ = append(p.Src_, 5)
	}
	// IsPublic type alias from is_public
	if pb.GetIsPublic() != nil {
		p.IsPublic = pb.GetIsPublic().GetValue()
		p.Src_ = append(p.Src_, 6)
	}
	// Email from
	if pb.GetAuthor() != nil {
		p.Email = pb.GetAuthor().GetEmail()
		p.Src_ = append(p.Src_, 7)
	}
	// Phone from
	if pb.GetAuthor() != nil {
		p.Phone = pb.GetAuthor().GetPhone()
		p.Src_ = append(p.Src_, 8)
	}
	// Address from
	if pb.GetAuthor() != nil && pb.GetAuthor().GetAddress() != nil {
		p.Address = pb.GetAuthor().GetAddress()
		p.Src_ = append(p.Src_, 9)
	}
	p.Metadata = pb.Metadata
	p.Src_ = append(p.Src_, 10)
	// Performance serialized from performance
	if pb.Performance != nil {
		if data, err := proto.Marshal(pb.Performance); err == nil {
			p.Performance = data
			p.Src_ = append(p.Src_, 11)
		}
	}
	p.Keywords = pb.Keywords
	p.Src_ = append(p.Src_, 12)
	p.Attributes = pb.Attributes
	p.Src_ = append(p.Src_, 13)
	p.Locations = pb.Locations
	p.Src_ = append(p.Src_, 14)
	p.Structure = pb.Structure
	p.Src_ = append(p.Src_, 15)
	if len(pb.Children) > 0 {
		p.Children = make([]DocumentPlain, len(pb.Children))
		for i, v := range pb.Children {
			if v != nil {
				p.Children[i] = *v.IntoPlain()
			}
		}
		p.Src_ = append(p.Src_, 16)
	}
	if pb.Parent != nil {
		p.Parent = pb.Parent.IntoPlain()
		p.Src_ = append(p.Src_, 17)
	}
	// ContentTextContentTextContent from content_text_content.text_content
	if pb.GetTextContent() != nil {
		p.ContentTextContentTextContent = pb.GetTextContent()
		p.Src_ = append(p.Src_, 18)
	}
	// ContentImageContentImageContent from content_image_content.image_content
	if pb.GetImageContent() != nil {
		p.ContentImageContentImageContent = pb.GetImageContent()
		p.Src_ = append(p.Src_, 19)
	}
	// ContentVideoContentVideoContent from content_video_content.video_content
	if pb.GetVideoContent() != nil {
		p.ContentVideoContentVideoContent = pb.GetVideoContent()
		p.Src_ = append(p.Src_, 20)
	}
	// ContentCodeContentCodeContent from content_code_content.code_content
	if pb.GetCodeContent() != nil {
		p.ContentCodeContentCodeContent = pb.GetCodeContent()
		p.Src_ = append(p.Src_, 21)
	}
	// ContentTableContentTableContent from content_table_content.table_content
	if pb.GetTableContent() != nil {
		p.ContentTableContentTableContent = pb.GetTableContent()
		p.Src_ = append(p.Src_, 22)
	}
	// ComputedHash is virtual, no source in protobuf
	// IsValid is virtual, no source in protobuf
}

// MarshalJX encodes DocumentPlain to JSON using jx.Encoder
func (p *DocumentPlain) MarshalJX(e *jx.Encoder) {
	if p == nil {
		e.Null()
		return
	}

	e.ObjStart()

	if p.ContentCase != "" {
		e.FieldStart("content_case")
		e.Str(p.ContentCase)
	}
	if p.Id != "" {
		e.FieldStart("id")
		e.Str(p.Id)
	}
	if p.Title != "" {
		e.FieldStart("title")
		e.Str(p.Title)
	}
	e.FieldStart("status")
	e.Int32(int32(p.Status))
	e.FieldStart("priority")
	e.Int32(int32(p.Priority))
	if p.Description != "" {
		e.FieldStart("description")
		e.Str(p.Description)
	}
	if p.Version != 0 {
		e.FieldStart("version")
		e.Int64(p.Version)
	}
	if p.IsPublic {
		e.FieldStart("isPublic")
		e.Bool(p.IsPublic)
	}
	if p.Email != "" {
		e.FieldStart("email")
		e.Str(p.Email)
	}
	if p.Phone != "" {
		e.FieldStart("phone")
		e.Str(p.Phone)
	}
	if p.Address != nil {
		e.FieldStart("address")
		if data, err := protojson.Marshal(p.Address); err == nil {
			e.Raw(data)
		} else {
			e.Null()
		}
	}
	if p.Metadata != nil {
		e.FieldStart("metadata")
		if data, err := protojson.Marshal(p.Metadata); err == nil {
			e.Raw(data)
		} else {
			e.Null()
		}
	}
	if len(p.Performance) > 0 {
		e.FieldStart("performance")
		e.Base64(p.Performance)
	}
	if len(p.Keywords) > 0 {
		e.FieldStart("keywords")
		e.ArrStart()
		for _, v := range p.Keywords {
			e.Str(v)
		}
		e.ArrEnd()
	}
	e.FieldStart("attributes")
	e.ObjStart()
	for k, v := range p.Attributes {
		e.FieldStart(k)
		e.Str(v)
	}
	e.ObjEnd()
	if p.Locations != nil {
		e.FieldStart("locations")
		e.ArrStart()
		for _, v := range p.Locations {
			if data, err := protojson.Marshal(v); err == nil {
				e.Raw(data)
			} else {
				e.Null()
			}
		}
		e.ArrEnd()
	}
	if p.Structure != nil {
		e.FieldStart("structure")
		if data, err := protojson.Marshal(p.Structure); err == nil {
			e.Raw(data)
		} else {
			e.Null()
		}
	}
	if len(p.Children) > 0 {
		e.FieldStart("children")
		e.ArrStart()
		for _, v := range p.Children {
			(&v).MarshalJX(e)
		}
		e.ArrEnd()
	}
	if p.Parent != nil {
		e.FieldStart("parent")
		p.Parent.MarshalJX(e)
	}
	if p.ContentTextContentTextContent != nil {
		e.FieldStart("contentTextContentTextContent")
		if data, err := protojson.Marshal(p.ContentTextContentTextContent); err == nil {
			e.Raw(data)
		} else {
			e.Null()
		}
	}
	if p.ContentImageContentImageContent != nil {
		e.FieldStart("contentImageContentImageContent")
		if data, err := protojson.Marshal(p.ContentImageContentImageContent); err == nil {
			e.Raw(data)
		} else {
			e.Null()
		}
	}
	if p.ContentVideoContentVideoContent != nil {
		e.FieldStart("contentVideoContentVideoContent")
		if data, err := protojson.Marshal(p.ContentVideoContentVideoContent); err == nil {
			e.Raw(data)
		} else {
			e.Null()
		}
	}
	if p.ContentCodeContentCodeContent != nil {
		e.FieldStart("contentCodeContentCodeContent")
		if data, err := protojson.Marshal(p.ContentCodeContentCodeContent); err == nil {
			e.Raw(data)
		} else {
			e.Null()
		}
	}
	if p.ContentTableContentTableContent != nil {
		e.FieldStart("contentTableContentTableContent")
		if data, err := protojson.Marshal(p.ContentTableContentTableContent); err == nil {
			e.Raw(data)
		} else {
			e.Null()
		}
	}
	if p.ComputedHash != "" {
		e.FieldStart("computedHash")
		e.Str(p.ComputedHash)
	}
	if p.IsValid {
		e.FieldStart("isValid")
		e.Bool(p.IsValid)
	}
	e.ObjEnd()
}

// MarshalJSON implements json.Marshaler using jx
func (p *DocumentPlain) MarshalJSON() ([]byte, error) {
	e := jx.GetEncoder()
	defer jx.PutEncoder(e)
	p.MarshalJX(e)
	return e.Bytes(), nil
}

// UnmarshalJX decodes DocumentPlain from JSON using jx.Decoder
// Populates Src_ with indices of decoded fields
func (p *DocumentPlain) UnmarshalJX(d *jx.Decoder) error {
	if p == nil {
		return nil
	}

	return d.Obj(func(d *jx.Decoder, key string) error {
		switch key {
		case "_src":
			return d.Arr(func(d *jx.Decoder) error {
				v, err := d.UInt16()
				if err != nil {
					return err
				}
				p.Src_ = append(p.Src_, v)
				return nil
			})
		case "content_case":
			v, err := d.Str()
			if err != nil {
				return err
			}
			p.ContentCase = v
		case "id":
			v, err := d.Str()
			if err != nil {
				return err
			}
			p.Id = v
			p.Src_ = append(p.Src_, 0)
		case "title":
			v, err := d.Str()
			if err != nil {
				return err
			}
			p.Title = v
			p.Src_ = append(p.Src_, 1)
		case "status":
			v, err := d.Int32()
			if err != nil {
				return err
			}
			p.Status = Status(v)
			p.Src_ = append(p.Src_, 2)
		case "priority":
			v, err := d.Int32()
			if err != nil {
				return err
			}
			p.Priority = Priority(v)
			p.Src_ = append(p.Src_, 3)
		case "description":
			v, err := d.Str()
			if err != nil {
				return err
			}
			p.Description = v
			p.Src_ = append(p.Src_, 4)
		case "version":
			v, err := d.Int64()
			if err != nil {
				return err
			}
			p.Version = v
			p.Src_ = append(p.Src_, 5)
		case "isPublic":
			v, err := d.Bool()
			if err != nil {
				return err
			}
			p.IsPublic = v
			p.Src_ = append(p.Src_, 6)
		case "email":
			v, err := d.Str()
			if err != nil {
				return err
			}
			p.Email = v
			p.Src_ = append(p.Src_, 7)
		case "phone":
			v, err := d.Str()
			if err != nil {
				return err
			}
			p.Phone = v
			p.Src_ = append(p.Src_, 8)
		case "address":
			raw, err := d.Raw()
			if err != nil {
				return err
			}
			p.Address = &Address{}
			if err := protojson.Unmarshal(raw, p.Address); err != nil {
				return err
			}
			p.Src_ = append(p.Src_, 9)
		case "metadata":
			raw, err := d.Raw()
			if err != nil {
				return err
			}
			p.Metadata = &Metadata{}
			if err := protojson.Unmarshal(raw, p.Metadata); err != nil {
				return err
			}
			p.Src_ = append(p.Src_, 10)
		case "performance":
			v, err := d.Base64()
			if err != nil {
				return err
			}
			p.Performance = v
			p.Src_ = append(p.Src_, 11)
		case "keywords":
			if err := d.Arr(func(d *jx.Decoder) error {
				v, err := d.Str()
				if err != nil {
					return err
				}
				p.Keywords = append(p.Keywords, v)
				return nil
			}); err != nil {
				return err
			}
			p.Src_ = append(p.Src_, 12)
		case "attributes":
			if p.Attributes == nil {
				p.Attributes = make(map[string]string)
			}
			return d.Obj(func(d *jx.Decoder, key string) error {
				v, err := d.Str()
				if err != nil {
					return err
				}
				p.Attributes[key] = v
				return nil
			})
			p.Src_ = append(p.Src_, 13)
		case "locations":
			if err := d.Arr(func(d *jx.Decoder) error {
				raw, err := d.Raw()
				if err != nil {
					return err
				}
				var v Address
				if err := protojson.Unmarshal(raw, &v); err != nil {
					return err
				}
				p.Locations = append(p.Locations, &v)
				return nil
			}); err != nil {
				return err
			}
			p.Src_ = append(p.Src_, 14)
		case "structure":
			raw, err := d.Raw()
			if err != nil {
				return err
			}
			p.Structure = &Level1{}
			if err := protojson.Unmarshal(raw, p.Structure); err != nil {
				return err
			}
			p.Src_ = append(p.Src_, 15)
		case "children":
			if err := d.Arr(func(d *jx.Decoder) error {
				var v DocumentPlain
				if err := v.UnmarshalJX(d); err != nil {
					return err
				}
				p.Children = append(p.Children, v)
				return nil
			}); err != nil {
				return err
			}
			p.Src_ = append(p.Src_, 16)
		case "parent":
			p.Parent = &DocumentPlain{}
			if err := p.Parent.UnmarshalJX(d); err != nil {
				return err
			}
			p.Src_ = append(p.Src_, 17)
		case "contentTextContentTextContent":
			raw, err := d.Raw()
			if err != nil {
				return err
			}
			p.ContentTextContentTextContent = &TextContent{}
			if err := protojson.Unmarshal(raw, p.ContentTextContentTextContent); err != nil {
				return err
			}
			p.Src_ = append(p.Src_, 18)
		case "contentImageContentImageContent":
			raw, err := d.Raw()
			if err != nil {
				return err
			}
			p.ContentImageContentImageContent = &ImageContent{}
			if err := protojson.Unmarshal(raw, p.ContentImageContentImageContent); err != nil {
				return err
			}
			p.Src_ = append(p.Src_, 19)
		case "contentVideoContentVideoContent":
			raw, err := d.Raw()
			if err != nil {
				return err
			}
			p.ContentVideoContentVideoContent = &VideoContent{}
			if err := protojson.Unmarshal(raw, p.ContentVideoContentVideoContent); err != nil {
				return err
			}
			p.Src_ = append(p.Src_, 20)
		case "contentCodeContentCodeContent":
			raw, err := d.Raw()
			if err != nil {
				return err
			}
			p.ContentCodeContentCodeContent = &CodeContent{}
			if err := protojson.Unmarshal(raw, p.ContentCodeContentCodeContent); err != nil {
				return err
			}
			p.Src_ = append(p.Src_, 21)
		case "contentTableContentTableContent":
			raw, err := d.Raw()
			if err != nil {
				return err
			}
			p.ContentTableContentTableContent = &TableContent{}
			if err := protojson.Unmarshal(raw, p.ContentTableContentTableContent); err != nil {
				return err
			}
			p.Src_ = append(p.Src_, 22)
		case "computedHash":
			v, err := d.Str()
			if err != nil {
				return err
			}
			p.ComputedHash = v
			p.Src_ = append(p.Src_, 23)
		case "isValid":
			v, err := d.Bool()
			if err != nil {
				return err
			}
			p.IsValid = v
			p.Src_ = append(p.Src_, 24)
		default:
			return d.Skip()
		}
		return nil
	})
}

// UnmarshalJSON implements json.Unmarshaler using jx
func (p *DocumentPlain) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return p.UnmarshalJX(d)
}

// documentPlainPool is a sync.Pool for DocumentPlain objects
var documentPlainPool = sync.Pool{
	New: func() interface{} {
		return &DocumentPlain{
			Src_: make([]uint16, 0, 32),
		}
	},
}

// GetDocumentPlain returns a DocumentPlain from the pool
func GetDocumentPlain() *DocumentPlain {
	return documentPlainPool.Get().(*DocumentPlain)
}

// PutDocumentPlain returns a DocumentPlain to the pool after resetting it
func PutDocumentPlain(p *DocumentPlain) {
	if p == nil {
		return
	}
	p.Reset()
	documentPlainPool.Put(p)
}

// Reset clears all fields in DocumentPlain for reuse
func (p *DocumentPlain) Reset() {
	if p == nil {
		return
	}

	p.Src_ = p.Src_[:0]

	p.ContentCase = ""
	p.Id = ""
	p.Title = ""
	p.Status = 0
	p.Priority = 0
	p.Description = ""
	p.Version = 0
	p.IsPublic = false
	p.Email = ""
	p.Phone = ""
	p.Address = nil
	p.Metadata = nil
	p.Performance = nil
	p.Keywords = p.Keywords[:0]
	for k := range p.Attributes {
		delete(p.Attributes, k)
	}
	p.Locations = nil
	p.Structure = nil
	p.Children = p.Children[:0]
	p.Parent = nil
	p.ContentTextContentTextContent = nil
	p.ContentImageContentImageContent = nil
	p.ContentVideoContentVideoContent = nil
	p.ContentCodeContentCodeContent = nil
	p.ContentTableContentTableContent = nil
	p.ComputedHash = ""
	p.IsValid = false
}

type TreeNodePlain struct {
	Id                string            `json:"id"`
	Name              string            `json:"name"`
	Type              string            `json:"type"`
	Children          []TreeNodePlain   `json:"children"`
	Parent            *TreeNodePlain    `json:"parent"`
	CreatedBy         string            `json:"createdBy"`
	CreatedAt         int64             `json:"createdAt"`
	ModifiedBy        string            `json:"modifiedBy"`
	ModifiedAt        int64             `json:"modifiedAt"`
	Labels            map[string]string `json:"labels"`
	Tags              []string          `json:"tags"`
	PayloadTextText   *TextContent      `json:"payloadTextText"`   // origin: oneof_embed, empath: payload_text.text
	PayloadImageImage *ImageContent     `json:"payloadImageImage"` // origin: oneof_embed, empath: payload_image.image
	PayloadCodeCode   *CodeContent      `json:"payloadCodeCode"`   // origin: oneof_embed, empath: payload_code.code
	// PayloadCase indicates which variant of payload oneof is set
	PayloadCase string `json:"payload_case,omitempty"`
	// Src_ contains indices of populated fields for sparse serialization
	Src_ []uint16 `json:"_src,omitempty"`
}

// IntoPlain converts protobuf message to plain struct
func (pb *TreeNode) IntoPlain() *TreeNodePlain {
	if pb == nil {
		return nil
	}
	p := &TreeNodePlain{}

	// Detect payload oneof case
	switch pb.Payload.(type) {
	case *TreeNode_Text:
		p.PayloadCase = "text"
	case *TreeNode_Image:
		p.PayloadCase = "image"
	case *TreeNode_Code:
		p.PayloadCase = "code"
	}

	p.Id = pb.Id
	p.Src_ = append(p.Src_, 0)
	p.Name = pb.Name
	p.Src_ = append(p.Src_, 1)
	p.Type = pb.Type
	p.Src_ = append(p.Src_, 2)
	if len(pb.Children) > 0 {
		p.Children = make([]TreeNodePlain, len(pb.Children))
		for i, v := range pb.Children {
			if v != nil {
				p.Children[i] = *v.IntoPlain()
			}
		}
		p.Src_ = append(p.Src_, 3)
	}
	if pb.Parent != nil {
		p.Parent = pb.Parent.IntoPlain()
		p.Src_ = append(p.Src_, 4)
	}
	// CreatedBy from
	if pb.GetInfo() != nil {
		p.CreatedBy = pb.GetInfo().GetCreatedBy()
		p.Src_ = append(p.Src_, 5)
	}
	// CreatedAt from
	if pb.GetInfo() != nil {
		p.CreatedAt = pb.GetInfo().GetCreatedAt()
		p.Src_ = append(p.Src_, 6)
	}
	// ModifiedBy from
	if pb.GetInfo() != nil {
		p.ModifiedBy = pb.GetInfo().GetModifiedBy()
		p.Src_ = append(p.Src_, 7)
	}
	// ModifiedAt from
	if pb.GetInfo() != nil {
		p.ModifiedAt = pb.GetInfo().GetModifiedAt()
		p.Src_ = append(p.Src_, 8)
	}
	// Labels from
	if pb.GetInfo() != nil && pb.GetInfo().GetLabels() != nil {
		p.Labels = pb.GetInfo().GetLabels()
		p.Src_ = append(p.Src_, 9)
	}
	// Tags from
	if pb.GetInfo() != nil {
		p.Tags = pb.GetInfo().GetTags()
		p.Src_ = append(p.Src_, 10)
	}
	// PayloadTextText from payload_text.text
	if pb.GetText() != nil {
		p.PayloadTextText = pb.GetText()
		p.Src_ = append(p.Src_, 11)
	}
	// PayloadImageImage from payload_image.image
	if pb.GetImage() != nil {
		p.PayloadImageImage = pb.GetImage()
		p.Src_ = append(p.Src_, 12)
	}
	// PayloadCodeCode from payload_code.code
	if pb.GetCode() != nil {
		p.PayloadCodeCode = pb.GetCode()
		p.Src_ = append(p.Src_, 13)
	}
	return p
}

// IntoPb converts plain struct to protobuf message
func (p *TreeNodePlain) IntoPb() *TreeNode {
	if p == nil {
		return nil
	}
	pb := &TreeNode{}

	pb.Id = p.Id
	pb.Name = p.Name
	pb.Type = p.Type
	if len(p.Children) > 0 {
		pb.Children = make([]*TreeNode, len(p.Children))
		for i := range p.Children {
			pb.Children[i] = (&p.Children[i]).IntoPb()
		}
	}
	if p.Parent != nil {
		pb.Parent = p.Parent.IntoPb()
	}
	// CreatedBy ->
	if p.CreatedBy != "" {
		if pb.Info == nil {
			pb.Info = &Metadata{}
		}
		pb.Info.CreatedBy = p.CreatedBy
	}
	// CreatedAt ->
	if pb.Info == nil {
		pb.Info = &Metadata{}
	}
	pb.Info.CreatedAt = p.CreatedAt
	// ModifiedBy ->
	if p.ModifiedBy != "" {
		if pb.Info == nil {
			pb.Info = &Metadata{}
		}
		pb.Info.ModifiedBy = p.ModifiedBy
	}
	// ModifiedAt ->
	if pb.Info == nil {
		pb.Info = &Metadata{}
	}
	pb.Info.ModifiedAt = p.ModifiedAt
	// Labels ->
	if pb.Info == nil {
		pb.Info = &Metadata{}
	}
	pb.Info.Labels = p.Labels
	// Tags ->
	if len(p.Tags) > 0 {
		if pb.Info == nil {
			pb.Info = &Metadata{}
		}
		pb.Info.Tags = p.Tags
	}
	// PayloadTextText -> payload_text.text
	if p.PayloadTextText != nil && p.PayloadCase == "text" {
		pb.Payload = &TreeNode_Text{Text: p.PayloadTextText}
	}
	// PayloadImageImage -> payload_image.image
	if p.PayloadImageImage != nil && p.PayloadCase == "image" {
		pb.Payload = &TreeNode_Image{Image: p.PayloadImageImage}
	}
	// PayloadCodeCode -> payload_code.code
	if p.PayloadCodeCode != nil && p.PayloadCase == "code" {
		pb.Payload = &TreeNode_Code{Code: p.PayloadCodeCode}
	}
	return pb
}

// IntoPlainReuse converts protobuf message to existing plain struct (for pool usage)
func (pb *TreeNode) IntoPlainReuse(p *TreeNodePlain) {
	if pb == nil || p == nil {
		return
	}
	// Reset before filling
	p.Reset()

	// Detect payload oneof case
	switch pb.Payload.(type) {
	case *TreeNode_Text:
		p.PayloadCase = "text"
	case *TreeNode_Image:
		p.PayloadCase = "image"
	case *TreeNode_Code:
		p.PayloadCase = "code"
	}

	p.Id = pb.Id
	p.Src_ = append(p.Src_, 0)
	p.Name = pb.Name
	p.Src_ = append(p.Src_, 1)
	p.Type = pb.Type
	p.Src_ = append(p.Src_, 2)
	if len(pb.Children) > 0 {
		p.Children = make([]TreeNodePlain, len(pb.Children))
		for i, v := range pb.Children {
			if v != nil {
				p.Children[i] = *v.IntoPlain()
			}
		}
		p.Src_ = append(p.Src_, 3)
	}
	if pb.Parent != nil {
		p.Parent = pb.Parent.IntoPlain()
		p.Src_ = append(p.Src_, 4)
	}
	// CreatedBy from
	if pb.GetInfo() != nil {
		p.CreatedBy = pb.GetInfo().GetCreatedBy()
		p.Src_ = append(p.Src_, 5)
	}
	// CreatedAt from
	if pb.GetInfo() != nil {
		p.CreatedAt = pb.GetInfo().GetCreatedAt()
		p.Src_ = append(p.Src_, 6)
	}
	// ModifiedBy from
	if pb.GetInfo() != nil {
		p.ModifiedBy = pb.GetInfo().GetModifiedBy()
		p.Src_ = append(p.Src_, 7)
	}
	// ModifiedAt from
	if pb.GetInfo() != nil {
		p.ModifiedAt = pb.GetInfo().GetModifiedAt()
		p.Src_ = append(p.Src_, 8)
	}
	// Labels from
	if pb.GetInfo() != nil && pb.GetInfo().GetLabels() != nil {
		p.Labels = pb.GetInfo().GetLabels()
		p.Src_ = append(p.Src_, 9)
	}
	// Tags from
	if pb.GetInfo() != nil {
		p.Tags = pb.GetInfo().GetTags()
		p.Src_ = append(p.Src_, 10)
	}
	// PayloadTextText from payload_text.text
	if pb.GetText() != nil {
		p.PayloadTextText = pb.GetText()
		p.Src_ = append(p.Src_, 11)
	}
	// PayloadImageImage from payload_image.image
	if pb.GetImage() != nil {
		p.PayloadImageImage = pb.GetImage()
		p.Src_ = append(p.Src_, 12)
	}
	// PayloadCodeCode from payload_code.code
	if pb.GetCode() != nil {
		p.PayloadCodeCode = pb.GetCode()
		p.Src_ = append(p.Src_, 13)
	}
}

// MarshalJX encodes TreeNodePlain to JSON using jx.Encoder
func (p *TreeNodePlain) MarshalJX(e *jx.Encoder) {
	if p == nil {
		e.Null()
		return
	}

	e.ObjStart()

	if p.PayloadCase != "" {
		e.FieldStart("payload_case")
		e.Str(p.PayloadCase)
	}
	if p.Id != "" {
		e.FieldStart("id")
		e.Str(p.Id)
	}
	if p.Name != "" {
		e.FieldStart("name")
		e.Str(p.Name)
	}
	if p.Type != "" {
		e.FieldStart("type")
		e.Str(p.Type)
	}
	if len(p.Children) > 0 {
		e.FieldStart("children")
		e.ArrStart()
		for _, v := range p.Children {
			(&v).MarshalJX(e)
		}
		e.ArrEnd()
	}
	if p.Parent != nil {
		e.FieldStart("parent")
		p.Parent.MarshalJX(e)
	}
	if p.CreatedBy != "" {
		e.FieldStart("createdBy")
		e.Str(p.CreatedBy)
	}
	if p.CreatedAt != 0 {
		e.FieldStart("createdAt")
		e.Int64(p.CreatedAt)
	}
	if p.ModifiedBy != "" {
		e.FieldStart("modifiedBy")
		e.Str(p.ModifiedBy)
	}
	if p.ModifiedAt != 0 {
		e.FieldStart("modifiedAt")
		e.Int64(p.ModifiedAt)
	}
	e.FieldStart("labels")
	e.ObjStart()
	for k, v := range p.Labels {
		e.FieldStart(k)
		e.Str(v)
	}
	e.ObjEnd()
	if len(p.Tags) > 0 {
		e.FieldStart("tags")
		e.ArrStart()
		for _, v := range p.Tags {
			e.Str(v)
		}
		e.ArrEnd()
	}
	if p.PayloadTextText != nil {
		e.FieldStart("payloadTextText")
		if data, err := protojson.Marshal(p.PayloadTextText); err == nil {
			e.Raw(data)
		} else {
			e.Null()
		}
	}
	if p.PayloadImageImage != nil {
		e.FieldStart("payloadImageImage")
		if data, err := protojson.Marshal(p.PayloadImageImage); err == nil {
			e.Raw(data)
		} else {
			e.Null()
		}
	}
	if p.PayloadCodeCode != nil {
		e.FieldStart("payloadCodeCode")
		if data, err := protojson.Marshal(p.PayloadCodeCode); err == nil {
			e.Raw(data)
		} else {
			e.Null()
		}
	}
	e.ObjEnd()
}

// MarshalJSON implements json.Marshaler using jx
func (p *TreeNodePlain) MarshalJSON() ([]byte, error) {
	e := jx.GetEncoder()
	defer jx.PutEncoder(e)
	p.MarshalJX(e)
	return e.Bytes(), nil
}

// UnmarshalJX decodes TreeNodePlain from JSON using jx.Decoder
// Populates Src_ with indices of decoded fields
func (p *TreeNodePlain) UnmarshalJX(d *jx.Decoder) error {
	if p == nil {
		return nil
	}

	return d.Obj(func(d *jx.Decoder, key string) error {
		switch key {
		case "_src":
			return d.Arr(func(d *jx.Decoder) error {
				v, err := d.UInt16()
				if err != nil {
					return err
				}
				p.Src_ = append(p.Src_, v)
				return nil
			})
		case "payload_case":
			v, err := d.Str()
			if err != nil {
				return err
			}
			p.PayloadCase = v
		case "id":
			v, err := d.Str()
			if err != nil {
				return err
			}
			p.Id = v
			p.Src_ = append(p.Src_, 0)
		case "name":
			v, err := d.Str()
			if err != nil {
				return err
			}
			p.Name = v
			p.Src_ = append(p.Src_, 1)
		case "type":
			v, err := d.Str()
			if err != nil {
				return err
			}
			p.Type = v
			p.Src_ = append(p.Src_, 2)
		case "children":
			if err := d.Arr(func(d *jx.Decoder) error {
				var v TreeNodePlain
				if err := v.UnmarshalJX(d); err != nil {
					return err
				}
				p.Children = append(p.Children, v)
				return nil
			}); err != nil {
				return err
			}
			p.Src_ = append(p.Src_, 3)
		case "parent":
			p.Parent = &TreeNodePlain{}
			if err := p.Parent.UnmarshalJX(d); err != nil {
				return err
			}
			p.Src_ = append(p.Src_, 4)
		case "createdBy":
			v, err := d.Str()
			if err != nil {
				return err
			}
			p.CreatedBy = v
			p.Src_ = append(p.Src_, 5)
		case "createdAt":
			v, err := d.Int64()
			if err != nil {
				return err
			}
			p.CreatedAt = v
			p.Src_ = append(p.Src_, 6)
		case "modifiedBy":
			v, err := d.Str()
			if err != nil {
				return err
			}
			p.ModifiedBy = v
			p.Src_ = append(p.Src_, 7)
		case "modifiedAt":
			v, err := d.Int64()
			if err != nil {
				return err
			}
			p.ModifiedAt = v
			p.Src_ = append(p.Src_, 8)
		case "labels":
			if p.Labels == nil {
				p.Labels = make(map[string]string)
			}
			return d.Obj(func(d *jx.Decoder, key string) error {
				v, err := d.Str()
				if err != nil {
					return err
				}
				p.Labels[key] = v
				return nil
			})
			p.Src_ = append(p.Src_, 9)
		case "tags":
			if err := d.Arr(func(d *jx.Decoder) error {
				v, err := d.Str()
				if err != nil {
					return err
				}
				p.Tags = append(p.Tags, v)
				return nil
			}); err != nil {
				return err
			}
			p.Src_ = append(p.Src_, 10)
		case "payloadTextText":
			raw, err := d.Raw()
			if err != nil {
				return err
			}
			p.PayloadTextText = &TextContent{}
			if err := protojson.Unmarshal(raw, p.PayloadTextText); err != nil {
				return err
			}
			p.Src_ = append(p.Src_, 11)
		case "payloadImageImage":
			raw, err := d.Raw()
			if err != nil {
				return err
			}
			p.PayloadImageImage = &ImageContent{}
			if err := protojson.Unmarshal(raw, p.PayloadImageImage); err != nil {
				return err
			}
			p.Src_ = append(p.Src_, 12)
		case "payloadCodeCode":
			raw, err := d.Raw()
			if err != nil {
				return err
			}
			p.PayloadCodeCode = &CodeContent{}
			if err := protojson.Unmarshal(raw, p.PayloadCodeCode); err != nil {
				return err
			}
			p.Src_ = append(p.Src_, 13)
		default:
			return d.Skip()
		}
		return nil
	})
}

// UnmarshalJSON implements json.Unmarshaler using jx
func (p *TreeNodePlain) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return p.UnmarshalJX(d)
}

// treeNodePlainPool is a sync.Pool for TreeNodePlain objects
var treeNodePlainPool = sync.Pool{
	New: func() interface{} {
		return &TreeNodePlain{
			Src_: make([]uint16, 0, 32),
		}
	},
}

// GetTreeNodePlain returns a TreeNodePlain from the pool
func GetTreeNodePlain() *TreeNodePlain {
	return treeNodePlainPool.Get().(*TreeNodePlain)
}

// PutTreeNodePlain returns a TreeNodePlain to the pool after resetting it
func PutTreeNodePlain(p *TreeNodePlain) {
	if p == nil {
		return
	}
	p.Reset()
	treeNodePlainPool.Put(p)
}

// Reset clears all fields in TreeNodePlain for reuse
func (p *TreeNodePlain) Reset() {
	if p == nil {
		return
	}

	p.Src_ = p.Src_[:0]

	p.PayloadCase = ""
	p.Id = ""
	p.Name = ""
	p.Type = ""
	p.Children = p.Children[:0]
	p.Parent = nil
	p.CreatedBy = ""
	p.CreatedAt = 0
	p.ModifiedBy = ""
	p.ModifiedAt = 0
	for k := range p.Labels {
		delete(p.Labels, k)
	}
	p.Tags = p.Tags[:0]
	p.PayloadTextText = nil
	p.PayloadImageImage = nil
	p.PayloadCodeCode = nil
}

type EventPlain struct {
	EventId                             string               `json:"eventId"`
	EventType                           string               `json:"eventType"`
	Timestamp                           int64                `json:"timestamp"`
	Source                              string               `json:"source"`
	Meta                                *Metadata            `json:"meta"`
	PayloadUserCreatedUserCreated       *UserCreatedEvent    `json:"payloadUserCreatedUserCreated"`       // origin: oneof_embed, empath: payload_user_created.user_created
	PayloadUserUpdatedUserUpdated       *UserUpdatedEvent    `json:"payloadUserUpdatedUserUpdated"`       // origin: oneof_embed, empath: payload_user_updated.user_updated
	PayloadUserDeletedUserDeleted       *UserDeletedEvent    `json:"payloadUserDeletedUserDeleted"`       // origin: oneof_embed, empath: payload_user_deleted.user_deleted
	PayloadOrderCreatedOrderCreated     *OrderCreatedEvent   `json:"payloadOrderCreatedOrderCreated"`     // origin: oneof_embed, empath: payload_order_created.order_created
	PayloadOrderCompletedOrderCompleted *OrderCompletedEvent `json:"payloadOrderCompletedOrderCompleted"` // origin: oneof_embed, empath: payload_order_completed.order_completed
	// PayloadCase indicates which variant of payload oneof is set
	PayloadCase string `json:"payload_case,omitempty"`
	// Src_ contains indices of populated fields for sparse serialization
	Src_ []uint16 `json:"_src,omitempty"`
}

// IntoPlain converts protobuf message to plain struct
func (pb *Event) IntoPlain() *EventPlain {
	if pb == nil {
		return nil
	}
	p := &EventPlain{}

	// Detect payload oneof case
	switch pb.Payload.(type) {
	case *Event_UserCreated:
		p.PayloadCase = "user_created"
	case *Event_UserUpdated:
		p.PayloadCase = "user_updated"
	case *Event_UserDeleted:
		p.PayloadCase = "user_deleted"
	case *Event_OrderCreated:
		p.PayloadCase = "order_created"
	case *Event_OrderCompleted:
		p.PayloadCase = "order_completed"
	}

	p.EventId = pb.EventId
	p.Src_ = append(p.Src_, 0)
	p.EventType = pb.EventType
	p.Src_ = append(p.Src_, 1)
	p.Timestamp = pb.Timestamp
	p.Src_ = append(p.Src_, 2)
	p.Source = pb.Source
	p.Src_ = append(p.Src_, 3)
	p.Meta = pb.Meta
	p.Src_ = append(p.Src_, 4)
	// PayloadUserCreatedUserCreated from payload_user_created.user_created
	if pb.GetUserCreated() != nil {
		p.PayloadUserCreatedUserCreated = pb.GetUserCreated()
		p.Src_ = append(p.Src_, 5)
	}
	// PayloadUserUpdatedUserUpdated from payload_user_updated.user_updated
	if pb.GetUserUpdated() != nil {
		p.PayloadUserUpdatedUserUpdated = pb.GetUserUpdated()
		p.Src_ = append(p.Src_, 6)
	}
	// PayloadUserDeletedUserDeleted from payload_user_deleted.user_deleted
	if pb.GetUserDeleted() != nil {
		p.PayloadUserDeletedUserDeleted = pb.GetUserDeleted()
		p.Src_ = append(p.Src_, 7)
	}
	// PayloadOrderCreatedOrderCreated from payload_order_created.order_created
	if pb.GetOrderCreated() != nil {
		p.PayloadOrderCreatedOrderCreated = pb.GetOrderCreated()
		p.Src_ = append(p.Src_, 8)
	}
	// PayloadOrderCompletedOrderCompleted from payload_order_completed.order_completed
	if pb.GetOrderCompleted() != nil {
		p.PayloadOrderCompletedOrderCompleted = pb.GetOrderCompleted()
		p.Src_ = append(p.Src_, 9)
	}
	return p
}

// IntoPb converts plain struct to protobuf message
func (p *EventPlain) IntoPb() *Event {
	if p == nil {
		return nil
	}
	pb := &Event{}

	pb.EventId = p.EventId
	pb.EventType = p.EventType
	pb.Timestamp = p.Timestamp
	pb.Source = p.Source
	pb.Meta = p.Meta
	// PayloadUserCreatedUserCreated -> payload_user_created.user_created
	if p.PayloadUserCreatedUserCreated != nil && p.PayloadCase == "user_created" {
		pb.Payload = &Event_UserCreated{UserCreated: p.PayloadUserCreatedUserCreated}
	}
	// PayloadUserUpdatedUserUpdated -> payload_user_updated.user_updated
	if p.PayloadUserUpdatedUserUpdated != nil && p.PayloadCase == "user_updated" {
		pb.Payload = &Event_UserUpdated{UserUpdated: p.PayloadUserUpdatedUserUpdated}
	}
	// PayloadUserDeletedUserDeleted -> payload_user_deleted.user_deleted
	if p.PayloadUserDeletedUserDeleted != nil && p.PayloadCase == "user_deleted" {
		pb.Payload = &Event_UserDeleted{UserDeleted: p.PayloadUserDeletedUserDeleted}
	}
	// PayloadOrderCreatedOrderCreated -> payload_order_created.order_created
	if p.PayloadOrderCreatedOrderCreated != nil && p.PayloadCase == "order_created" {
		pb.Payload = &Event_OrderCreated{OrderCreated: p.PayloadOrderCreatedOrderCreated}
	}
	// PayloadOrderCompletedOrderCompleted -> payload_order_completed.order_completed
	if p.PayloadOrderCompletedOrderCompleted != nil && p.PayloadCase == "order_completed" {
		pb.Payload = &Event_OrderCompleted{OrderCompleted: p.PayloadOrderCompletedOrderCompleted}
	}
	return pb
}

// IntoPlainReuse converts protobuf message to existing plain struct (for pool usage)
func (pb *Event) IntoPlainReuse(p *EventPlain) {
	if pb == nil || p == nil {
		return
	}
	// Reset before filling
	p.Reset()

	// Detect payload oneof case
	switch pb.Payload.(type) {
	case *Event_UserCreated:
		p.PayloadCase = "user_created"
	case *Event_UserUpdated:
		p.PayloadCase = "user_updated"
	case *Event_UserDeleted:
		p.PayloadCase = "user_deleted"
	case *Event_OrderCreated:
		p.PayloadCase = "order_created"
	case *Event_OrderCompleted:
		p.PayloadCase = "order_completed"
	}

	p.EventId = pb.EventId
	p.Src_ = append(p.Src_, 0)
	p.EventType = pb.EventType
	p.Src_ = append(p.Src_, 1)
	p.Timestamp = pb.Timestamp
	p.Src_ = append(p.Src_, 2)
	p.Source = pb.Source
	p.Src_ = append(p.Src_, 3)
	p.Meta = pb.Meta
	p.Src_ = append(p.Src_, 4)
	// PayloadUserCreatedUserCreated from payload_user_created.user_created
	if pb.GetUserCreated() != nil {
		p.PayloadUserCreatedUserCreated = pb.GetUserCreated()
		p.Src_ = append(p.Src_, 5)
	}
	// PayloadUserUpdatedUserUpdated from payload_user_updated.user_updated
	if pb.GetUserUpdated() != nil {
		p.PayloadUserUpdatedUserUpdated = pb.GetUserUpdated()
		p.Src_ = append(p.Src_, 6)
	}
	// PayloadUserDeletedUserDeleted from payload_user_deleted.user_deleted
	if pb.GetUserDeleted() != nil {
		p.PayloadUserDeletedUserDeleted = pb.GetUserDeleted()
		p.Src_ = append(p.Src_, 7)
	}
	// PayloadOrderCreatedOrderCreated from payload_order_created.order_created
	if pb.GetOrderCreated() != nil {
		p.PayloadOrderCreatedOrderCreated = pb.GetOrderCreated()
		p.Src_ = append(p.Src_, 8)
	}
	// PayloadOrderCompletedOrderCompleted from payload_order_completed.order_completed
	if pb.GetOrderCompleted() != nil {
		p.PayloadOrderCompletedOrderCompleted = pb.GetOrderCompleted()
		p.Src_ = append(p.Src_, 9)
	}
}

// MarshalJX encodes EventPlain to JSON using jx.Encoder
func (p *EventPlain) MarshalJX(e *jx.Encoder) {
	if p == nil {
		e.Null()
		return
	}

	e.ObjStart()

	if p.PayloadCase != "" {
		e.FieldStart("payload_case")
		e.Str(p.PayloadCase)
	}
	if p.EventId != "" {
		e.FieldStart("eventId")
		e.Str(p.EventId)
	}
	if p.EventType != "" {
		e.FieldStart("eventType")
		e.Str(p.EventType)
	}
	if p.Timestamp != 0 {
		e.FieldStart("timestamp")
		e.Int64(p.Timestamp)
	}
	if p.Source != "" {
		e.FieldStart("source")
		e.Str(p.Source)
	}
	if p.Meta != nil {
		e.FieldStart("meta")
		if data, err := protojson.Marshal(p.Meta); err == nil {
			e.Raw(data)
		} else {
			e.Null()
		}
	}
	if p.PayloadUserCreatedUserCreated != nil {
		e.FieldStart("payloadUserCreatedUserCreated")
		if data, err := protojson.Marshal(p.PayloadUserCreatedUserCreated); err == nil {
			e.Raw(data)
		} else {
			e.Null()
		}
	}
	if p.PayloadUserUpdatedUserUpdated != nil {
		e.FieldStart("payloadUserUpdatedUserUpdated")
		if data, err := protojson.Marshal(p.PayloadUserUpdatedUserUpdated); err == nil {
			e.Raw(data)
		} else {
			e.Null()
		}
	}
	if p.PayloadUserDeletedUserDeleted != nil {
		e.FieldStart("payloadUserDeletedUserDeleted")
		if data, err := protojson.Marshal(p.PayloadUserDeletedUserDeleted); err == nil {
			e.Raw(data)
		} else {
			e.Null()
		}
	}
	if p.PayloadOrderCreatedOrderCreated != nil {
		e.FieldStart("payloadOrderCreatedOrderCreated")
		if data, err := protojson.Marshal(p.PayloadOrderCreatedOrderCreated); err == nil {
			e.Raw(data)
		} else {
			e.Null()
		}
	}
	if p.PayloadOrderCompletedOrderCompleted != nil {
		e.FieldStart("payloadOrderCompletedOrderCompleted")
		if data, err := protojson.Marshal(p.PayloadOrderCompletedOrderCompleted); err == nil {
			e.Raw(data)
		} else {
			e.Null()
		}
	}
	e.ObjEnd()
}

// MarshalJSON implements json.Marshaler using jx
func (p *EventPlain) MarshalJSON() ([]byte, error) {
	e := jx.GetEncoder()
	defer jx.PutEncoder(e)
	p.MarshalJX(e)
	return e.Bytes(), nil
}

// UnmarshalJX decodes EventPlain from JSON using jx.Decoder
// Populates Src_ with indices of decoded fields
func (p *EventPlain) UnmarshalJX(d *jx.Decoder) error {
	if p == nil {
		return nil
	}

	return d.Obj(func(d *jx.Decoder, key string) error {
		switch key {
		case "_src":
			return d.Arr(func(d *jx.Decoder) error {
				v, err := d.UInt16()
				if err != nil {
					return err
				}
				p.Src_ = append(p.Src_, v)
				return nil
			})
		case "payload_case":
			v, err := d.Str()
			if err != nil {
				return err
			}
			p.PayloadCase = v
		case "eventId":
			v, err := d.Str()
			if err != nil {
				return err
			}
			p.EventId = v
			p.Src_ = append(p.Src_, 0)
		case "eventType":
			v, err := d.Str()
			if err != nil {
				return err
			}
			p.EventType = v
			p.Src_ = append(p.Src_, 1)
		case "timestamp":
			v, err := d.Int64()
			if err != nil {
				return err
			}
			p.Timestamp = v
			p.Src_ = append(p.Src_, 2)
		case "source":
			v, err := d.Str()
			if err != nil {
				return err
			}
			p.Source = v
			p.Src_ = append(p.Src_, 3)
		case "meta":
			raw, err := d.Raw()
			if err != nil {
				return err
			}
			p.Meta = &Metadata{}
			if err := protojson.Unmarshal(raw, p.Meta); err != nil {
				return err
			}
			p.Src_ = append(p.Src_, 4)
		case "payloadUserCreatedUserCreated":
			raw, err := d.Raw()
			if err != nil {
				return err
			}
			p.PayloadUserCreatedUserCreated = &UserCreatedEvent{}
			if err := protojson.Unmarshal(raw, p.PayloadUserCreatedUserCreated); err != nil {
				return err
			}
			p.Src_ = append(p.Src_, 5)
		case "payloadUserUpdatedUserUpdated":
			raw, err := d.Raw()
			if err != nil {
				return err
			}
			p.PayloadUserUpdatedUserUpdated = &UserUpdatedEvent{}
			if err := protojson.Unmarshal(raw, p.PayloadUserUpdatedUserUpdated); err != nil {
				return err
			}
			p.Src_ = append(p.Src_, 6)
		case "payloadUserDeletedUserDeleted":
			raw, err := d.Raw()
			if err != nil {
				return err
			}
			p.PayloadUserDeletedUserDeleted = &UserDeletedEvent{}
			if err := protojson.Unmarshal(raw, p.PayloadUserDeletedUserDeleted); err != nil {
				return err
			}
			p.Src_ = append(p.Src_, 7)
		case "payloadOrderCreatedOrderCreated":
			raw, err := d.Raw()
			if err != nil {
				return err
			}
			p.PayloadOrderCreatedOrderCreated = &OrderCreatedEvent{}
			if err := protojson.Unmarshal(raw, p.PayloadOrderCreatedOrderCreated); err != nil {
				return err
			}
			p.Src_ = append(p.Src_, 8)
		case "payloadOrderCompletedOrderCompleted":
			raw, err := d.Raw()
			if err != nil {
				return err
			}
			p.PayloadOrderCompletedOrderCompleted = &OrderCompletedEvent{}
			if err := protojson.Unmarshal(raw, p.PayloadOrderCompletedOrderCompleted); err != nil {
				return err
			}
			p.Src_ = append(p.Src_, 9)
		default:
			return d.Skip()
		}
		return nil
	})
}

// UnmarshalJSON implements json.Unmarshaler using jx
func (p *EventPlain) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return p.UnmarshalJX(d)
}

// eventPlainPool is a sync.Pool for EventPlain objects
var eventPlainPool = sync.Pool{
	New: func() interface{} {
		return &EventPlain{
			Src_: make([]uint16, 0, 32),
		}
	},
}

// GetEventPlain returns a EventPlain from the pool
func GetEventPlain() *EventPlain {
	return eventPlainPool.Get().(*EventPlain)
}

// PutEventPlain returns a EventPlain to the pool after resetting it
func PutEventPlain(p *EventPlain) {
	if p == nil {
		return
	}
	p.Reset()
	eventPlainPool.Put(p)
}

// Reset clears all fields in EventPlain for reuse
func (p *EventPlain) Reset() {
	if p == nil {
		return
	}

	p.Src_ = p.Src_[:0]

	p.PayloadCase = ""
	p.EventId = ""
	p.EventType = ""
	p.Timestamp = 0
	p.Source = ""
	p.Meta = nil
	p.PayloadUserCreatedUserCreated = nil
	p.PayloadUserUpdatedUserUpdated = nil
	p.PayloadUserDeletedUserDeleted = nil
	p.PayloadOrderCreatedOrderCreated = nil
	p.PayloadOrderCompletedOrderCompleted = nil
}

type ConfigPlain struct {
	DoubleVal        float64                         `json:"doubleVal"`
	FloatVal         float32                         `json:"floatVal"`
	Int32Val         int32                           `json:"int32Val"`
	Int64Val         int64                           `json:"int64Val"`
	Uint32Val        uint32                          `json:"uint32Val"`
	Uint64Val        uint64                          `json:"uint64Val"`
	Sint32Val        int32                           `json:"sint32Val"`
	Sint64Val        int64                           `json:"sint64Val"`
	Fixed32Val       uint32                          `json:"fixed32Val"`
	Fixed64Val       uint64                          `json:"fixed64Val"`
	Sfixed32Val      int32                           `json:"sfixed32Val"`
	Sfixed64Val      int64                           `json:"sfixed64Val"`
	BoolVal          bool                            `json:"boolVal"`
	StringVal        string                          `json:"stringVal"`
	BytesVal         []byte                          `json:"bytesVal"`
	OptionalString   string                          `json:"optionalString,omitempty"`
	OptionalInt      int32                           `json:"optionalInt,omitempty"`
	OptionalBool     bool                            `json:"optionalBool,omitempty"`
	OptionalDouble   float64                         `json:"optionalDouble,omitempty"`
	OptionalBytes    []byte                          `json:"optionalBytes,omitempty"`
	StringList       []string                        `json:"stringList"`
	IntList          []int32                         `json:"intList"`
	DoubleList       []float64                       `json:"doubleList"`
	BytesList        [][]byte                        `json:"bytesList"`
	BoolList         []bool                          `json:"boolList"`
	FloatList        []float32                       `json:"floatList"`
	Int64List        []int64                         `json:"int64List"`
	Uint32List       []uint32                        `json:"uint32List"`
	Uint64List       []uint64                        `json:"uint64List"`
	StringMap        map[string]string               `json:"stringMap"`
	IntMap           map[string]int32                `json:"intMap"`
	IntKeyMap        map[int32]string                `json:"intKeyMap"`
	NestedMap        map[string]*ConfigPlain         `json:"nestedMap"`
	Int64KeyMap      map[int64]string                `json:"int64KeyMap"`
	Uint32KeyMap     map[uint32]string               `json:"uint32KeyMap"`
	Uint64KeyMap     map[uint64]string               `json:"uint64KeyMap"`
	Sint32KeyMap     map[int32]string                `json:"sint32KeyMap"`
	Sint64KeyMap     map[int64]string                `json:"sint64KeyMap"`
	Fixed32KeyMap    map[uint32]string               `json:"fixed32KeyMap"`
	Fixed64KeyMap    map[uint64]string               `json:"fixed64KeyMap"`
	Sfixed32KeyMap   map[int32]string                `json:"sfixed32KeyMap"`
	Sfixed64KeyMap   map[int64]string                `json:"sfixed64KeyMap"`
	BoolKeyMap       map[bool]string                 `json:"boolKeyMap"`
	DoubleMap        map[string]float64              `json:"doubleMap"`
	BytesMap         map[string][]byte               `json:"bytesMap"`
	BoolMap          map[string]bool                 `json:"boolMap"`
	FloatMap         map[string]float32              `json:"floatMap"`
	Status           Status                          `json:"status"`
	StatusList       []Status                        `json:"statusList"`
	StatusMap        map[string]Status               `json:"statusMap"`
	OptionalStatus   Status                          `json:"optionalStatus,omitempty"`
	NestedEnum       Config_NestedEnum               `json:"nestedEnum"`
	NestedEnumList   []Config_NestedEnum             `json:"nestedEnumList"`
	NestedConfig     *Config_NestedConfig            `json:"nestedConfig"`
	NestedConfigList []*Config_NestedConfig          `json:"nestedConfigList"`
	NestedConfigMap  map[string]*Config_NestedConfig `json:"nestedConfigMap"`
	Parent           *ConfigPlain                    `json:"parent"`
	Children         []ConfigPlain                   `json:"children"`
	// Src_ contains indices of populated fields for sparse serialization
	Src_ []uint16 `json:"_src,omitempty"`
}

// IntoPlain converts protobuf message to plain struct
func (pb *Config) IntoPlain() *ConfigPlain {
	if pb == nil {
		return nil
	}
	p := &ConfigPlain{}

	p.DoubleVal = pb.DoubleVal
	p.Src_ = append(p.Src_, 0)
	p.FloatVal = pb.FloatVal
	p.Src_ = append(p.Src_, 1)
	p.Int32Val = pb.Int32Val
	p.Src_ = append(p.Src_, 2)
	p.Int64Val = pb.Int64Val
	p.Src_ = append(p.Src_, 3)
	p.Uint32Val = pb.Uint32Val
	p.Src_ = append(p.Src_, 4)
	p.Uint64Val = pb.Uint64Val
	p.Src_ = append(p.Src_, 5)
	p.Sint32Val = pb.Sint32Val
	p.Src_ = append(p.Src_, 6)
	p.Sint64Val = pb.Sint64Val
	p.Src_ = append(p.Src_, 7)
	p.Fixed32Val = pb.Fixed32Val
	p.Src_ = append(p.Src_, 8)
	p.Fixed64Val = pb.Fixed64Val
	p.Src_ = append(p.Src_, 9)
	p.Sfixed32Val = pb.Sfixed32Val
	p.Src_ = append(p.Src_, 10)
	p.Sfixed64Val = pb.Sfixed64Val
	p.Src_ = append(p.Src_, 11)
	p.BoolVal = pb.BoolVal
	p.Src_ = append(p.Src_, 12)
	p.StringVal = pb.StringVal
	p.Src_ = append(p.Src_, 13)
	p.BytesVal = pb.BytesVal
	p.Src_ = append(p.Src_, 14)
	if pb.OptionalString != nil {
		p.OptionalString = *pb.OptionalString
		p.Src_ = append(p.Src_, 15)
	}
	if pb.OptionalInt != nil {
		p.OptionalInt = *pb.OptionalInt
		p.Src_ = append(p.Src_, 16)
	}
	if pb.OptionalBool != nil {
		p.OptionalBool = *pb.OptionalBool
		p.Src_ = append(p.Src_, 17)
	}
	if pb.OptionalDouble != nil {
		p.OptionalDouble = *pb.OptionalDouble
		p.Src_ = append(p.Src_, 18)
	}
	p.OptionalBytes = pb.OptionalBytes
	p.Src_ = append(p.Src_, 19)
	p.StringList = pb.StringList
	p.Src_ = append(p.Src_, 20)
	p.IntList = pb.IntList
	p.Src_ = append(p.Src_, 21)
	p.DoubleList = pb.DoubleList
	p.Src_ = append(p.Src_, 22)
	p.BytesList = pb.BytesList
	p.Src_ = append(p.Src_, 23)
	p.BoolList = pb.BoolList
	p.Src_ = append(p.Src_, 24)
	p.FloatList = pb.FloatList
	p.Src_ = append(p.Src_, 25)
	p.Int64List = pb.Int64List
	p.Src_ = append(p.Src_, 26)
	p.Uint32List = pb.Uint32List
	p.Src_ = append(p.Src_, 27)
	p.Uint64List = pb.Uint64List
	p.Src_ = append(p.Src_, 28)
	p.StringMap = pb.StringMap
	p.Src_ = append(p.Src_, 29)
	p.IntMap = pb.IntMap
	p.Src_ = append(p.Src_, 30)
	p.IntKeyMap = pb.IntKeyMap
	p.Src_ = append(p.Src_, 31)
	if len(pb.NestedMap) > 0 {
		p.NestedMap = make(map[string]*ConfigPlain, len(pb.NestedMap))
		for k, v := range pb.NestedMap {
			if v != nil {
				p.NestedMap[k] = v.IntoPlain()
			}
		}
		p.Src_ = append(p.Src_, 32)
	}
	p.Int64KeyMap = pb.Int64KeyMap
	p.Src_ = append(p.Src_, 33)
	p.Uint32KeyMap = pb.Uint32KeyMap
	p.Src_ = append(p.Src_, 34)
	p.Uint64KeyMap = pb.Uint64KeyMap
	p.Src_ = append(p.Src_, 35)
	p.Sint32KeyMap = pb.Sint32KeyMap
	p.Src_ = append(p.Src_, 36)
	p.Sint64KeyMap = pb.Sint64KeyMap
	p.Src_ = append(p.Src_, 37)
	p.Fixed32KeyMap = pb.Fixed32KeyMap
	p.Src_ = append(p.Src_, 38)
	p.Fixed64KeyMap = pb.Fixed64KeyMap
	p.Src_ = append(p.Src_, 39)
	p.Sfixed32KeyMap = pb.Sfixed32KeyMap
	p.Src_ = append(p.Src_, 40)
	p.Sfixed64KeyMap = pb.Sfixed64KeyMap
	p.Src_ = append(p.Src_, 41)
	p.BoolKeyMap = pb.BoolKeyMap
	p.Src_ = append(p.Src_, 42)
	p.DoubleMap = pb.DoubleMap
	p.Src_ = append(p.Src_, 43)
	p.BytesMap = pb.BytesMap
	p.Src_ = append(p.Src_, 44)
	p.BoolMap = pb.BoolMap
	p.Src_ = append(p.Src_, 45)
	p.FloatMap = pb.FloatMap
	p.Src_ = append(p.Src_, 46)
	p.Status = pb.Status
	p.Src_ = append(p.Src_, 47)
	p.StatusList = pb.StatusList
	p.Src_ = append(p.Src_, 48)
	p.StatusMap = pb.StatusMap
	p.Src_ = append(p.Src_, 49)
	if pb.OptionalStatus != nil {
		p.OptionalStatus = *pb.OptionalStatus
		p.Src_ = append(p.Src_, 50)
	}
	p.NestedEnum = pb.NestedEnum
	p.Src_ = append(p.Src_, 51)
	p.NestedEnumList = pb.NestedEnumList
	p.Src_ = append(p.Src_, 52)
	p.NestedConfig = pb.NestedConfig
	p.Src_ = append(p.Src_, 53)
	p.NestedConfigList = pb.NestedConfigList
	p.Src_ = append(p.Src_, 54)
	p.NestedConfigMap = pb.NestedConfigMap
	p.Src_ = append(p.Src_, 55)
	if pb.Parent != nil {
		p.Parent = pb.Parent.IntoPlain()
		p.Src_ = append(p.Src_, 56)
	}
	if len(pb.Children) > 0 {
		p.Children = make([]ConfigPlain, len(pb.Children))
		for i, v := range pb.Children {
			if v != nil {
				p.Children[i] = *v.IntoPlain()
			}
		}
		p.Src_ = append(p.Src_, 57)
	}
	return p
}

// IntoPb converts plain struct to protobuf message
func (p *ConfigPlain) IntoPb() *Config {
	if p == nil {
		return nil
	}
	pb := &Config{}

	pb.DoubleVal = p.DoubleVal
	pb.FloatVal = p.FloatVal
	pb.Int32Val = p.Int32Val
	pb.Int64Val = p.Int64Val
	pb.Uint32Val = p.Uint32Val
	pb.Uint64Val = p.Uint64Val
	pb.Sint32Val = p.Sint32Val
	pb.Sint64Val = p.Sint64Val
	pb.Fixed32Val = p.Fixed32Val
	pb.Fixed64Val = p.Fixed64Val
	pb.Sfixed32Val = p.Sfixed32Val
	pb.Sfixed64Val = p.Sfixed64Val
	pb.BoolVal = p.BoolVal
	pb.StringVal = p.StringVal
	pb.BytesVal = p.BytesVal
	if p.OptionalString != "" {
		pb.OptionalString = &p.OptionalString
	}
	pb.OptionalInt = &p.OptionalInt
	pb.OptionalBool = &p.OptionalBool
	pb.OptionalDouble = &p.OptionalDouble
	pb.OptionalBytes = p.OptionalBytes
	pb.StringList = p.StringList
	pb.IntList = p.IntList
	pb.DoubleList = p.DoubleList
	pb.BytesList = p.BytesList
	pb.BoolList = p.BoolList
	pb.FloatList = p.FloatList
	pb.Int64List = p.Int64List
	pb.Uint32List = p.Uint32List
	pb.Uint64List = p.Uint64List
	pb.StringMap = p.StringMap
	pb.IntMap = p.IntMap
	pb.IntKeyMap = p.IntKeyMap
	if len(p.NestedMap) > 0 {
		pb.NestedMap = make(map[string]*Config, len(p.NestedMap))
		for k, v := range p.NestedMap {
			if v != nil {
				pb.NestedMap[k] = v.IntoPb()
			}
		}
	}
	pb.Int64KeyMap = p.Int64KeyMap
	pb.Uint32KeyMap = p.Uint32KeyMap
	pb.Uint64KeyMap = p.Uint64KeyMap
	pb.Sint32KeyMap = p.Sint32KeyMap
	pb.Sint64KeyMap = p.Sint64KeyMap
	pb.Fixed32KeyMap = p.Fixed32KeyMap
	pb.Fixed64KeyMap = p.Fixed64KeyMap
	pb.Sfixed32KeyMap = p.Sfixed32KeyMap
	pb.Sfixed64KeyMap = p.Sfixed64KeyMap
	pb.BoolKeyMap = p.BoolKeyMap
	pb.DoubleMap = p.DoubleMap
	pb.BytesMap = p.BytesMap
	pb.BoolMap = p.BoolMap
	pb.FloatMap = p.FloatMap
	pb.Status = p.Status
	pb.StatusList = p.StatusList
	pb.StatusMap = p.StatusMap
	pb.OptionalStatus = &p.OptionalStatus
	pb.NestedEnum = p.NestedEnum
	pb.NestedEnumList = p.NestedEnumList
	pb.NestedConfig = p.NestedConfig
	pb.NestedConfigList = p.NestedConfigList
	pb.NestedConfigMap = p.NestedConfigMap
	if p.Parent != nil {
		pb.Parent = p.Parent.IntoPb()
	}
	if len(p.Children) > 0 {
		pb.Children = make([]*Config, len(p.Children))
		for i := range p.Children {
			pb.Children[i] = (&p.Children[i]).IntoPb()
		}
	}
	return pb
}

// IntoPlainReuse converts protobuf message to existing plain struct (for pool usage)
func (pb *Config) IntoPlainReuse(p *ConfigPlain) {
	if pb == nil || p == nil {
		return
	}
	// Reset before filling
	p.Reset()

	p.DoubleVal = pb.DoubleVal
	p.Src_ = append(p.Src_, 0)
	p.FloatVal = pb.FloatVal
	p.Src_ = append(p.Src_, 1)
	p.Int32Val = pb.Int32Val
	p.Src_ = append(p.Src_, 2)
	p.Int64Val = pb.Int64Val
	p.Src_ = append(p.Src_, 3)
	p.Uint32Val = pb.Uint32Val
	p.Src_ = append(p.Src_, 4)
	p.Uint64Val = pb.Uint64Val
	p.Src_ = append(p.Src_, 5)
	p.Sint32Val = pb.Sint32Val
	p.Src_ = append(p.Src_, 6)
	p.Sint64Val = pb.Sint64Val
	p.Src_ = append(p.Src_, 7)
	p.Fixed32Val = pb.Fixed32Val
	p.Src_ = append(p.Src_, 8)
	p.Fixed64Val = pb.Fixed64Val
	p.Src_ = append(p.Src_, 9)
	p.Sfixed32Val = pb.Sfixed32Val
	p.Src_ = append(p.Src_, 10)
	p.Sfixed64Val = pb.Sfixed64Val
	p.Src_ = append(p.Src_, 11)
	p.BoolVal = pb.BoolVal
	p.Src_ = append(p.Src_, 12)
	p.StringVal = pb.StringVal
	p.Src_ = append(p.Src_, 13)
	p.BytesVal = pb.BytesVal
	p.Src_ = append(p.Src_, 14)
	if pb.OptionalString != nil {
		p.OptionalString = *pb.OptionalString
		p.Src_ = append(p.Src_, 15)
	}
	if pb.OptionalInt != nil {
		p.OptionalInt = *pb.OptionalInt
		p.Src_ = append(p.Src_, 16)
	}
	if pb.OptionalBool != nil {
		p.OptionalBool = *pb.OptionalBool
		p.Src_ = append(p.Src_, 17)
	}
	if pb.OptionalDouble != nil {
		p.OptionalDouble = *pb.OptionalDouble
		p.Src_ = append(p.Src_, 18)
	}
	p.OptionalBytes = pb.OptionalBytes
	p.Src_ = append(p.Src_, 19)
	p.StringList = pb.StringList
	p.Src_ = append(p.Src_, 20)
	p.IntList = pb.IntList
	p.Src_ = append(p.Src_, 21)
	p.DoubleList = pb.DoubleList
	p.Src_ = append(p.Src_, 22)
	p.BytesList = pb.BytesList
	p.Src_ = append(p.Src_, 23)
	p.BoolList = pb.BoolList
	p.Src_ = append(p.Src_, 24)
	p.FloatList = pb.FloatList
	p.Src_ = append(p.Src_, 25)
	p.Int64List = pb.Int64List
	p.Src_ = append(p.Src_, 26)
	p.Uint32List = pb.Uint32List
	p.Src_ = append(p.Src_, 27)
	p.Uint64List = pb.Uint64List
	p.Src_ = append(p.Src_, 28)
	p.StringMap = pb.StringMap
	p.Src_ = append(p.Src_, 29)
	p.IntMap = pb.IntMap
	p.Src_ = append(p.Src_, 30)
	p.IntKeyMap = pb.IntKeyMap
	p.Src_ = append(p.Src_, 31)
	if len(pb.NestedMap) > 0 {
		p.NestedMap = make(map[string]*ConfigPlain, len(pb.NestedMap))
		for k, v := range pb.NestedMap {
			if v != nil {
				p.NestedMap[k] = v.IntoPlain()
			}
		}
		p.Src_ = append(p.Src_, 32)
	}
	p.Int64KeyMap = pb.Int64KeyMap
	p.Src_ = append(p.Src_, 33)
	p.Uint32KeyMap = pb.Uint32KeyMap
	p.Src_ = append(p.Src_, 34)
	p.Uint64KeyMap = pb.Uint64KeyMap
	p.Src_ = append(p.Src_, 35)
	p.Sint32KeyMap = pb.Sint32KeyMap
	p.Src_ = append(p.Src_, 36)
	p.Sint64KeyMap = pb.Sint64KeyMap
	p.Src_ = append(p.Src_, 37)
	p.Fixed32KeyMap = pb.Fixed32KeyMap
	p.Src_ = append(p.Src_, 38)
	p.Fixed64KeyMap = pb.Fixed64KeyMap
	p.Src_ = append(p.Src_, 39)
	p.Sfixed32KeyMap = pb.Sfixed32KeyMap
	p.Src_ = append(p.Src_, 40)
	p.Sfixed64KeyMap = pb.Sfixed64KeyMap
	p.Src_ = append(p.Src_, 41)
	p.BoolKeyMap = pb.BoolKeyMap
	p.Src_ = append(p.Src_, 42)
	p.DoubleMap = pb.DoubleMap
	p.Src_ = append(p.Src_, 43)
	p.BytesMap = pb.BytesMap
	p.Src_ = append(p.Src_, 44)
	p.BoolMap = pb.BoolMap
	p.Src_ = append(p.Src_, 45)
	p.FloatMap = pb.FloatMap
	p.Src_ = append(p.Src_, 46)
	p.Status = pb.Status
	p.Src_ = append(p.Src_, 47)
	p.StatusList = pb.StatusList
	p.Src_ = append(p.Src_, 48)
	p.StatusMap = pb.StatusMap
	p.Src_ = append(p.Src_, 49)
	if pb.OptionalStatus != nil {
		p.OptionalStatus = *pb.OptionalStatus
		p.Src_ = append(p.Src_, 50)
	}
	p.NestedEnum = pb.NestedEnum
	p.Src_ = append(p.Src_, 51)
	p.NestedEnumList = pb.NestedEnumList
	p.Src_ = append(p.Src_, 52)
	p.NestedConfig = pb.NestedConfig
	p.Src_ = append(p.Src_, 53)
	p.NestedConfigList = pb.NestedConfigList
	p.Src_ = append(p.Src_, 54)
	p.NestedConfigMap = pb.NestedConfigMap
	p.Src_ = append(p.Src_, 55)
	if pb.Parent != nil {
		p.Parent = pb.Parent.IntoPlain()
		p.Src_ = append(p.Src_, 56)
	}
	if len(pb.Children) > 0 {
		p.Children = make([]ConfigPlain, len(pb.Children))
		for i, v := range pb.Children {
			if v != nil {
				p.Children[i] = *v.IntoPlain()
			}
		}
		p.Src_ = append(p.Src_, 57)
	}
}

// MarshalJX encodes ConfigPlain to JSON using jx.Encoder
func (p *ConfigPlain) MarshalJX(e *jx.Encoder) {
	if p == nil {
		e.Null()
		return
	}

	e.ObjStart()

	if p.DoubleVal != 0 {
		e.FieldStart("doubleVal")
		e.Float64(p.DoubleVal)
	}
	if p.FloatVal != 0 {
		e.FieldStart("floatVal")
		e.Float32(p.FloatVal)
	}
	if p.Int32Val != 0 {
		e.FieldStart("int32Val")
		e.Int32(p.Int32Val)
	}
	if p.Int64Val != 0 {
		e.FieldStart("int64Val")
		e.Int64(p.Int64Val)
	}
	if p.Uint32Val != 0 {
		e.FieldStart("uint32Val")
		e.UInt32(p.Uint32Val)
	}
	if p.Uint64Val != 0 {
		e.FieldStart("uint64Val")
		e.UInt64(p.Uint64Val)
	}
	if p.Sint32Val != 0 {
		e.FieldStart("sint32Val")
		e.Int32(p.Sint32Val)
	}
	if p.Sint64Val != 0 {
		e.FieldStart("sint64Val")
		e.Int64(p.Sint64Val)
	}
	if p.Fixed32Val != 0 {
		e.FieldStart("fixed32Val")
		e.UInt32(p.Fixed32Val)
	}
	if p.Fixed64Val != 0 {
		e.FieldStart("fixed64Val")
		e.UInt64(p.Fixed64Val)
	}
	if p.Sfixed32Val != 0 {
		e.FieldStart("sfixed32Val")
		e.Int32(p.Sfixed32Val)
	}
	if p.Sfixed64Val != 0 {
		e.FieldStart("sfixed64Val")
		e.Int64(p.Sfixed64Val)
	}
	if p.BoolVal {
		e.FieldStart("boolVal")
		e.Bool(p.BoolVal)
	}
	if p.StringVal != "" {
		e.FieldStart("stringVal")
		e.Str(p.StringVal)
	}
	if len(p.BytesVal) > 0 {
		e.FieldStart("bytesVal")
		e.Base64(p.BytesVal)
	}
	if p.OptionalString != "" {
		e.FieldStart("optionalString")
		e.Str(p.OptionalString)
	}
	if p.OptionalInt != 0 {
		e.FieldStart("optionalInt")
		e.Int32(p.OptionalInt)
	}
	if p.OptionalBool {
		e.FieldStart("optionalBool")
		e.Bool(p.OptionalBool)
	}
	if p.OptionalDouble != 0 {
		e.FieldStart("optionalDouble")
		e.Float64(p.OptionalDouble)
	}
	if len(p.OptionalBytes) > 0 {
		e.FieldStart("optionalBytes")
		e.Base64(p.OptionalBytes)
	}
	if len(p.StringList) > 0 {
		e.FieldStart("stringList")
		e.ArrStart()
		for _, v := range p.StringList {
			e.Str(v)
		}
		e.ArrEnd()
	}
	if len(p.IntList) > 0 {
		e.FieldStart("intList")
		e.ArrStart()
		for _, v := range p.IntList {
			e.Int32(v)
		}
		e.ArrEnd()
	}
	if len(p.DoubleList) > 0 {
		e.FieldStart("doubleList")
		e.ArrStart()
		for _, v := range p.DoubleList {
			e.Float64(v)
		}
		e.ArrEnd()
	}
	if len(p.BytesList) > 0 {
		e.FieldStart("bytesList")
		e.ArrStart()
		for _, v := range p.BytesList {
			e.Base64(v)
		}
		e.ArrEnd()
	}
	if len(p.BoolList) > 0 {
		e.FieldStart("boolList")
		e.ArrStart()
		for _, v := range p.BoolList {
			e.Bool(v)
		}
		e.ArrEnd()
	}
	if len(p.FloatList) > 0 {
		e.FieldStart("floatList")
		e.ArrStart()
		for _, v := range p.FloatList {
			e.Float32(v)
		}
		e.ArrEnd()
	}
	if len(p.Int64List) > 0 {
		e.FieldStart("int64List")
		e.ArrStart()
		for _, v := range p.Int64List {
			e.Int64(v)
		}
		e.ArrEnd()
	}
	if len(p.Uint32List) > 0 {
		e.FieldStart("uint32List")
		e.ArrStart()
		for _, v := range p.Uint32List {
			e.UInt32(v)
		}
		e.ArrEnd()
	}
	if len(p.Uint64List) > 0 {
		e.FieldStart("uint64List")
		e.ArrStart()
		for _, v := range p.Uint64List {
			e.UInt64(v)
		}
		e.ArrEnd()
	}
	e.FieldStart("stringMap")
	e.ObjStart()
	for k, v := range p.StringMap {
		e.FieldStart(k)
		e.Str(v)
	}
	e.ObjEnd()
	e.FieldStart("intMap")
	e.ObjStart()
	for k, v := range p.IntMap {
		e.FieldStart(k)
		e.Int32(v)
	}
	e.ObjEnd()
	e.FieldStart("intKeyMap")
	e.ObjStart()
	for k, v := range p.IntKeyMap {
		e.FieldStart(fmt.Sprint(k))
		e.Str(v)
	}
	e.ObjEnd()
	e.FieldStart("nestedMap")
	e.ObjStart()
	for k, v := range p.NestedMap {
		e.FieldStart(k)
		v.MarshalJX(e)
	}
	e.ObjEnd()
	e.FieldStart("int64KeyMap")
	e.ObjStart()
	for k, v := range p.Int64KeyMap {
		e.FieldStart(fmt.Sprint(k))
		e.Str(v)
	}
	e.ObjEnd()
	e.FieldStart("uint32KeyMap")
	e.ObjStart()
	for k, v := range p.Uint32KeyMap {
		e.FieldStart(fmt.Sprint(k))
		e.Str(v)
	}
	e.ObjEnd()
	e.FieldStart("uint64KeyMap")
	e.ObjStart()
	for k, v := range p.Uint64KeyMap {
		e.FieldStart(fmt.Sprint(k))
		e.Str(v)
	}
	e.ObjEnd()
	e.FieldStart("sint32KeyMap")
	e.ObjStart()
	for k, v := range p.Sint32KeyMap {
		e.FieldStart(fmt.Sprint(k))
		e.Str(v)
	}
	e.ObjEnd()
	e.FieldStart("sint64KeyMap")
	e.ObjStart()
	for k, v := range p.Sint64KeyMap {
		e.FieldStart(fmt.Sprint(k))
		e.Str(v)
	}
	e.ObjEnd()
	e.FieldStart("fixed32KeyMap")
	e.ObjStart()
	for k, v := range p.Fixed32KeyMap {
		e.FieldStart(fmt.Sprint(k))
		e.Str(v)
	}
	e.ObjEnd()
	e.FieldStart("fixed64KeyMap")
	e.ObjStart()
	for k, v := range p.Fixed64KeyMap {
		e.FieldStart(fmt.Sprint(k))
		e.Str(v)
	}
	e.ObjEnd()
	e.FieldStart("sfixed32KeyMap")
	e.ObjStart()
	for k, v := range p.Sfixed32KeyMap {
		e.FieldStart(fmt.Sprint(k))
		e.Str(v)
	}
	e.ObjEnd()
	e.FieldStart("sfixed64KeyMap")
	e.ObjStart()
	for k, v := range p.Sfixed64KeyMap {
		e.FieldStart(fmt.Sprint(k))
		e.Str(v)
	}
	e.ObjEnd()
	e.FieldStart("boolKeyMap")
	e.ObjStart()
	for k, v := range p.BoolKeyMap {
		e.FieldStart(fmt.Sprint(k))
		e.Str(v)
	}
	e.ObjEnd()
	e.FieldStart("doubleMap")
	e.ObjStart()
	for k, v := range p.DoubleMap {
		e.FieldStart(k)
		e.Float64(v)
	}
	e.ObjEnd()
	e.FieldStart("bytesMap")
	e.ObjStart()
	for k, v := range p.BytesMap {
		e.FieldStart(k)
		e.Base64(v)
	}
	e.ObjEnd()
	e.FieldStart("boolMap")
	e.ObjStart()
	for k, v := range p.BoolMap {
		e.FieldStart(k)
		e.Bool(v)
	}
	e.ObjEnd()
	e.FieldStart("floatMap")
	e.ObjStart()
	for k, v := range p.FloatMap {
		e.FieldStart(k)
		e.Float32(v)
	}
	e.ObjEnd()
	e.FieldStart("status")
	e.Int32(int32(p.Status))
	if len(p.StatusList) > 0 {
		e.FieldStart("statusList")
		e.ArrStart()
		for _, v := range p.StatusList {
			e.Int32(int32(v))
		}
		e.ArrEnd()
	}
	e.FieldStart("statusMap")
	e.ObjStart()
	for k, v := range p.StatusMap {
		e.FieldStart(k)
		e.Int32(int32(v))
	}
	e.ObjEnd()
	e.FieldStart("optionalStatus")
	e.Int32(int32(p.OptionalStatus))
	e.FieldStart("nestedEnum")
	e.Int32(int32(p.NestedEnum))
	if len(p.NestedEnumList) > 0 {
		e.FieldStart("nestedEnumList")
		e.ArrStart()
		for _, v := range p.NestedEnumList {
			e.Int32(int32(v))
		}
		e.ArrEnd()
	}
	if p.NestedConfig != nil {
		e.FieldStart("nestedConfig")
		if data, err := protojson.Marshal(p.NestedConfig); err == nil {
			e.Raw(data)
		} else {
			e.Null()
		}
	}
	if p.NestedConfigList != nil {
		e.FieldStart("nestedConfigList")
		e.ArrStart()
		for _, v := range p.NestedConfigList {
			if data, err := protojson.Marshal(v); err == nil {
				e.Raw(data)
			} else {
				e.Null()
			}
		}
		e.ArrEnd()
	}
	e.FieldStart("nestedConfigMap")
	e.ObjStart()
	for k, v := range p.NestedConfigMap {
		e.FieldStart(k)
		if data, err := protojson.Marshal(v); err == nil {
			e.Raw(data)
		} else {
			e.Null()
		}
	}
	e.ObjEnd()
	if p.Parent != nil {
		e.FieldStart("parent")
		p.Parent.MarshalJX(e)
	}
	if len(p.Children) > 0 {
		e.FieldStart("children")
		e.ArrStart()
		for _, v := range p.Children {
			(&v).MarshalJX(e)
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

// MarshalJSON implements json.Marshaler using jx
func (p *ConfigPlain) MarshalJSON() ([]byte, error) {
	e := jx.GetEncoder()
	defer jx.PutEncoder(e)
	p.MarshalJX(e)
	return e.Bytes(), nil
}

// UnmarshalJX decodes ConfigPlain from JSON using jx.Decoder
// Populates Src_ with indices of decoded fields
func (p *ConfigPlain) UnmarshalJX(d *jx.Decoder) error {
	if p == nil {
		return nil
	}

	return d.Obj(func(d *jx.Decoder, key string) error {
		switch key {
		case "_src":
			return d.Arr(func(d *jx.Decoder) error {
				v, err := d.UInt16()
				if err != nil {
					return err
				}
				p.Src_ = append(p.Src_, v)
				return nil
			})
		case "doubleVal":
			v, err := d.Float64()
			if err != nil {
				return err
			}
			p.DoubleVal = v
			p.Src_ = append(p.Src_, 0)
		case "floatVal":
			v, err := d.Float32()
			if err != nil {
				return err
			}
			p.FloatVal = v
			p.Src_ = append(p.Src_, 1)
		case "int32Val":
			v, err := d.Int32()
			if err != nil {
				return err
			}
			p.Int32Val = v
			p.Src_ = append(p.Src_, 2)
		case "int64Val":
			v, err := d.Int64()
			if err != nil {
				return err
			}
			p.Int64Val = v
			p.Src_ = append(p.Src_, 3)
		case "uint32Val":
			v, err := d.UInt32()
			if err != nil {
				return err
			}
			p.Uint32Val = v
			p.Src_ = append(p.Src_, 4)
		case "uint64Val":
			v, err := d.UInt64()
			if err != nil {
				return err
			}
			p.Uint64Val = v
			p.Src_ = append(p.Src_, 5)
		case "sint32Val":
			v, err := d.Int32()
			if err != nil {
				return err
			}
			p.Sint32Val = v
			p.Src_ = append(p.Src_, 6)
		case "sint64Val":
			v, err := d.Int64()
			if err != nil {
				return err
			}
			p.Sint64Val = v
			p.Src_ = append(p.Src_, 7)
		case "fixed32Val":
			v, err := d.UInt32()
			if err != nil {
				return err
			}
			p.Fixed32Val = v
			p.Src_ = append(p.Src_, 8)
		case "fixed64Val":
			v, err := d.UInt64()
			if err != nil {
				return err
			}
			p.Fixed64Val = v
			p.Src_ = append(p.Src_, 9)
		case "sfixed32Val":
			v, err := d.Int32()
			if err != nil {
				return err
			}
			p.Sfixed32Val = v
			p.Src_ = append(p.Src_, 10)
		case "sfixed64Val":
			v, err := d.Int64()
			if err != nil {
				return err
			}
			p.Sfixed64Val = v
			p.Src_ = append(p.Src_, 11)
		case "boolVal":
			v, err := d.Bool()
			if err != nil {
				return err
			}
			p.BoolVal = v
			p.Src_ = append(p.Src_, 12)
		case "stringVal":
			v, err := d.Str()
			if err != nil {
				return err
			}
			p.StringVal = v
			p.Src_ = append(p.Src_, 13)
		case "bytesVal":
			v, err := d.Base64()
			if err != nil {
				return err
			}
			p.BytesVal = v
			p.Src_ = append(p.Src_, 14)
		case "optionalString":
			v, err := d.Str()
			if err != nil {
				return err
			}
			p.OptionalString = v
			p.Src_ = append(p.Src_, 15)
		case "optionalInt":
			v, err := d.Int32()
			if err != nil {
				return err
			}
			p.OptionalInt = v
			p.Src_ = append(p.Src_, 16)
		case "optionalBool":
			v, err := d.Bool()
			if err != nil {
				return err
			}
			p.OptionalBool = v
			p.Src_ = append(p.Src_, 17)
		case "optionalDouble":
			v, err := d.Float64()
			if err != nil {
				return err
			}
			p.OptionalDouble = v
			p.Src_ = append(p.Src_, 18)
		case "optionalBytes":
			v, err := d.Base64()
			if err != nil {
				return err
			}
			p.OptionalBytes = v
			p.Src_ = append(p.Src_, 19)
		case "stringList":
			if err := d.Arr(func(d *jx.Decoder) error {
				v, err := d.Str()
				if err != nil {
					return err
				}
				p.StringList = append(p.StringList, v)
				return nil
			}); err != nil {
				return err
			}
			p.Src_ = append(p.Src_, 20)
		case "intList":
			if err := d.Arr(func(d *jx.Decoder) error {
				v, err := d.Int32()
				if err != nil {
					return err
				}
				p.IntList = append(p.IntList, v)
				return nil
			}); err != nil {
				return err
			}
			p.Src_ = append(p.Src_, 21)
		case "doubleList":
			if err := d.Arr(func(d *jx.Decoder) error {
				v, err := d.Float64()
				if err != nil {
					return err
				}
				p.DoubleList = append(p.DoubleList, v)
				return nil
			}); err != nil {
				return err
			}
			p.Src_ = append(p.Src_, 22)
		case "bytesList":
			if err := d.Arr(func(d *jx.Decoder) error {
				v, err := d.Base64()
				if err != nil {
					return err
				}
				p.BytesList = append(p.BytesList, v)
				return nil
			}); err != nil {
				return err
			}
			p.Src_ = append(p.Src_, 23)
		case "boolList":
			if err := d.Arr(func(d *jx.Decoder) error {
				v, err := d.Bool()
				if err != nil {
					return err
				}
				p.BoolList = append(p.BoolList, v)
				return nil
			}); err != nil {
				return err
			}
			p.Src_ = append(p.Src_, 24)
		case "floatList":
			if err := d.Arr(func(d *jx.Decoder) error {
				v, err := d.Float32()
				if err != nil {
					return err
				}
				p.FloatList = append(p.FloatList, v)
				return nil
			}); err != nil {
				return err
			}
			p.Src_ = append(p.Src_, 25)
		case "int64List":
			if err := d.Arr(func(d *jx.Decoder) error {
				v, err := d.Int64()
				if err != nil {
					return err
				}
				p.Int64List = append(p.Int64List, v)
				return nil
			}); err != nil {
				return err
			}
			p.Src_ = append(p.Src_, 26)
		case "uint32List":
			if err := d.Arr(func(d *jx.Decoder) error {
				v, err := d.UInt32()
				if err != nil {
					return err
				}
				p.Uint32List = append(p.Uint32List, v)
				return nil
			}); err != nil {
				return err
			}
			p.Src_ = append(p.Src_, 27)
		case "uint64List":
			if err := d.Arr(func(d *jx.Decoder) error {
				v, err := d.UInt64()
				if err != nil {
					return err
				}
				p.Uint64List = append(p.Uint64List, v)
				return nil
			}); err != nil {
				return err
			}
			p.Src_ = append(p.Src_, 28)
		case "stringMap":
			if p.StringMap == nil {
				p.StringMap = make(map[string]string)
			}
			return d.Obj(func(d *jx.Decoder, key string) error {
				v, err := d.Str()
				if err != nil {
					return err
				}
				p.StringMap[key] = v
				return nil
			})
			p.Src_ = append(p.Src_, 29)
		case "intMap":
			if p.IntMap == nil {
				p.IntMap = make(map[string]int32)
			}
			return d.Obj(func(d *jx.Decoder, key string) error {
				v, err := d.Int32()
				if err != nil {
					return err
				}
				p.IntMap[key] = v
				return nil
			})
			p.Src_ = append(p.Src_, 30)
		case "intKeyMap":
			if p.IntKeyMap == nil {
				p.IntKeyMap = make(map[int32]string)
			}
			return d.Obj(func(d *jx.Decoder, key string) error {
				_k, err := strconv.ParseInt(key, 10, 32)
				if err != nil {
					return err
				}
				_mapKey := int32(_k)
				v, err := d.Str()
				if err != nil {
					return err
				}
				p.IntKeyMap[_mapKey] = v
				return nil
			})
			p.Src_ = append(p.Src_, 31)
		case "nestedMap":
			if p.NestedMap == nil {
				p.NestedMap = make(map[string]*ConfigPlain)
			}
			return d.Obj(func(d *jx.Decoder, key string) error {
				p.NestedMap[key] = &ConfigPlain{}
				if err := p.NestedMap[key].UnmarshalJX(d); err != nil {
					return err
				}
				return nil
			})
			p.Src_ = append(p.Src_, 32)
		case "int64KeyMap":
			if p.Int64KeyMap == nil {
				p.Int64KeyMap = make(map[int64]string)
			}
			return d.Obj(func(d *jx.Decoder, key string) error {
				_mapKey, err := strconv.ParseInt(key, 10, 64)
				if err != nil {
					return err
				}
				v, err := d.Str()
				if err != nil {
					return err
				}
				p.Int64KeyMap[_mapKey] = v
				return nil
			})
			p.Src_ = append(p.Src_, 33)
		case "uint32KeyMap":
			if p.Uint32KeyMap == nil {
				p.Uint32KeyMap = make(map[uint32]string)
			}
			return d.Obj(func(d *jx.Decoder, key string) error {
				_k, err := strconv.ParseUint(key, 10, 32)
				if err != nil {
					return err
				}
				_mapKey := uint32(_k)
				v, err := d.Str()
				if err != nil {
					return err
				}
				p.Uint32KeyMap[_mapKey] = v
				return nil
			})
			p.Src_ = append(p.Src_, 34)
		case "uint64KeyMap":
			if p.Uint64KeyMap == nil {
				p.Uint64KeyMap = make(map[uint64]string)
			}
			return d.Obj(func(d *jx.Decoder, key string) error {
				_mapKey, err := strconv.ParseUint(key, 10, 64)
				if err != nil {
					return err
				}
				v, err := d.Str()
				if err != nil {
					return err
				}
				p.Uint64KeyMap[_mapKey] = v
				return nil
			})
			p.Src_ = append(p.Src_, 35)
		case "sint32KeyMap":
			if p.Sint32KeyMap == nil {
				p.Sint32KeyMap = make(map[int32]string)
			}
			return d.Obj(func(d *jx.Decoder, key string) error {
				_k, err := strconv.ParseInt(key, 10, 32)
				if err != nil {
					return err
				}
				_mapKey := int32(_k)
				v, err := d.Str()
				if err != nil {
					return err
				}
				p.Sint32KeyMap[_mapKey] = v
				return nil
			})
			p.Src_ = append(p.Src_, 36)
		case "sint64KeyMap":
			if p.Sint64KeyMap == nil {
				p.Sint64KeyMap = make(map[int64]string)
			}
			return d.Obj(func(d *jx.Decoder, key string) error {
				_mapKey, err := strconv.ParseInt(key, 10, 64)
				if err != nil {
					return err
				}
				v, err := d.Str()
				if err != nil {
					return err
				}
				p.Sint64KeyMap[_mapKey] = v
				return nil
			})
			p.Src_ = append(p.Src_, 37)
		case "fixed32KeyMap":
			if p.Fixed32KeyMap == nil {
				p.Fixed32KeyMap = make(map[uint32]string)
			}
			return d.Obj(func(d *jx.Decoder, key string) error {
				_k, err := strconv.ParseUint(key, 10, 32)
				if err != nil {
					return err
				}
				_mapKey := uint32(_k)
				v, err := d.Str()
				if err != nil {
					return err
				}
				p.Fixed32KeyMap[_mapKey] = v
				return nil
			})
			p.Src_ = append(p.Src_, 38)
		case "fixed64KeyMap":
			if p.Fixed64KeyMap == nil {
				p.Fixed64KeyMap = make(map[uint64]string)
			}
			return d.Obj(func(d *jx.Decoder, key string) error {
				_mapKey, err := strconv.ParseUint(key, 10, 64)
				if err != nil {
					return err
				}
				v, err := d.Str()
				if err != nil {
					return err
				}
				p.Fixed64KeyMap[_mapKey] = v
				return nil
			})
			p.Src_ = append(p.Src_, 39)
		case "sfixed32KeyMap":
			if p.Sfixed32KeyMap == nil {
				p.Sfixed32KeyMap = make(map[int32]string)
			}
			return d.Obj(func(d *jx.Decoder, key string) error {
				_k, err := strconv.ParseInt(key, 10, 32)
				if err != nil {
					return err
				}
				_mapKey := int32(_k)
				v, err := d.Str()
				if err != nil {
					return err
				}
				p.Sfixed32KeyMap[_mapKey] = v
				return nil
			})
			p.Src_ = append(p.Src_, 40)
		case "sfixed64KeyMap":
			if p.Sfixed64KeyMap == nil {
				p.Sfixed64KeyMap = make(map[int64]string)
			}
			return d.Obj(func(d *jx.Decoder, key string) error {
				_mapKey, err := strconv.ParseInt(key, 10, 64)
				if err != nil {
					return err
				}
				v, err := d.Str()
				if err != nil {
					return err
				}
				p.Sfixed64KeyMap[_mapKey] = v
				return nil
			})
			p.Src_ = append(p.Src_, 41)
		case "boolKeyMap":
			if p.BoolKeyMap == nil {
				p.BoolKeyMap = make(map[bool]string)
			}
			return d.Obj(func(d *jx.Decoder, key string) error {
				_mapKey, err := strconv.ParseBool(key)
				if err != nil {
					return err
				}
				v, err := d.Str()
				if err != nil {
					return err
				}
				p.BoolKeyMap[_mapKey] = v
				return nil
			})
			p.Src_ = append(p.Src_, 42)
		case "doubleMap":
			if p.DoubleMap == nil {
				p.DoubleMap = make(map[string]float64)
			}
			return d.Obj(func(d *jx.Decoder, key string) error {
				v, err := d.Float64()
				if err != nil {
					return err
				}
				p.DoubleMap[key] = v
				return nil
			})
			p.Src_ = append(p.Src_, 43)
		case "bytesMap":
			if p.BytesMap == nil {
				p.BytesMap = make(map[string][]byte)
			}
			return d.Obj(func(d *jx.Decoder, key string) error {
				v, err := d.Base64()
				if err != nil {
					return err
				}
				p.BytesMap[key] = v
				return nil
			})
			p.Src_ = append(p.Src_, 44)
		case "boolMap":
			if p.BoolMap == nil {
				p.BoolMap = make(map[string]bool)
			}
			return d.Obj(func(d *jx.Decoder, key string) error {
				v, err := d.Bool()
				if err != nil {
					return err
				}
				p.BoolMap[key] = v
				return nil
			})
			p.Src_ = append(p.Src_, 45)
		case "floatMap":
			if p.FloatMap == nil {
				p.FloatMap = make(map[string]float32)
			}
			return d.Obj(func(d *jx.Decoder, key string) error {
				v, err := d.Float32()
				if err != nil {
					return err
				}
				p.FloatMap[key] = v
				return nil
			})
			p.Src_ = append(p.Src_, 46)
		case "status":
			v, err := d.Int32()
			if err != nil {
				return err
			}
			p.Status = Status(v)
			p.Src_ = append(p.Src_, 47)
		case "statusList":
			if err := d.Arr(func(d *jx.Decoder) error {
				v, err := d.Int32()
				if err != nil {
					return err
				}
				p.StatusList = append(p.StatusList, Status(v))
				return nil
			}); err != nil {
				return err
			}
			p.Src_ = append(p.Src_, 48)
		case "statusMap":
			if p.StatusMap == nil {
				p.StatusMap = make(map[string]Status)
			}
			return d.Obj(func(d *jx.Decoder, key string) error {
				v, err := d.Int32()
				if err != nil {
					return err
				}
				p.StatusMap[key] = Status(v)
				return nil
			})
			p.Src_ = append(p.Src_, 49)
		case "optionalStatus":
			v, err := d.Int32()
			if err != nil {
				return err
			}
			p.OptionalStatus = Status(v)
			p.Src_ = append(p.Src_, 50)
		case "nestedEnum":
			v, err := d.Int32()
			if err != nil {
				return err
			}
			p.NestedEnum = Config_NestedEnum(v)
			p.Src_ = append(p.Src_, 51)
		case "nestedEnumList":
			if err := d.Arr(func(d *jx.Decoder) error {
				v, err := d.Int32()
				if err != nil {
					return err
				}
				p.NestedEnumList = append(p.NestedEnumList, Config_NestedEnum(v))
				return nil
			}); err != nil {
				return err
			}
			p.Src_ = append(p.Src_, 52)
		case "nestedConfig":
			raw, err := d.Raw()
			if err != nil {
				return err
			}
			p.NestedConfig = &Config_NestedConfig{}
			if err := protojson.Unmarshal(raw, p.NestedConfig); err != nil {
				return err
			}
			p.Src_ = append(p.Src_, 53)
		case "nestedConfigList":
			if err := d.Arr(func(d *jx.Decoder) error {
				raw, err := d.Raw()
				if err != nil {
					return err
				}
				var v Config_NestedConfig
				if err := protojson.Unmarshal(raw, &v); err != nil {
					return err
				}
				p.NestedConfigList = append(p.NestedConfigList, &v)
				return nil
			}); err != nil {
				return err
			}
			p.Src_ = append(p.Src_, 54)
		case "nestedConfigMap":
			if p.NestedConfigMap == nil {
				p.NestedConfigMap = make(map[string]*Config_NestedConfig)
			}
			return d.Obj(func(d *jx.Decoder, key string) error {
				raw, err := d.Raw()
				if err != nil {
					return err
				}
				p.NestedConfigMap[key] = &Config_NestedConfig{}
				if err := protojson.Unmarshal(raw, p.NestedConfigMap[key]); err != nil {
					return err
				}
				return nil
			})
			p.Src_ = append(p.Src_, 55)
		case "parent":
			p.Parent = &ConfigPlain{}
			if err := p.Parent.UnmarshalJX(d); err != nil {
				return err
			}
			p.Src_ = append(p.Src_, 56)
		case "children":
			if err := d.Arr(func(d *jx.Decoder) error {
				var v ConfigPlain
				if err := v.UnmarshalJX(d); err != nil {
					return err
				}
				p.Children = append(p.Children, v)
				return nil
			}); err != nil {
				return err
			}
			p.Src_ = append(p.Src_, 57)
		default:
			return d.Skip()
		}
		return nil
	})
}

// UnmarshalJSON implements json.Unmarshaler using jx
func (p *ConfigPlain) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return p.UnmarshalJX(d)
}

// configPlainPool is a sync.Pool for ConfigPlain objects
var configPlainPool = sync.Pool{
	New: func() interface{} {
		return &ConfigPlain{
			Src_: make([]uint16, 0, 32),
		}
	},
}

// GetConfigPlain returns a ConfigPlain from the pool
func GetConfigPlain() *ConfigPlain {
	return configPlainPool.Get().(*ConfigPlain)
}

// PutConfigPlain returns a ConfigPlain to the pool after resetting it
func PutConfigPlain(p *ConfigPlain) {
	if p == nil {
		return
	}
	p.Reset()
	configPlainPool.Put(p)
}

// Reset clears all fields in ConfigPlain for reuse
func (p *ConfigPlain) Reset() {
	if p == nil {
		return
	}

	p.Src_ = p.Src_[:0]

	p.DoubleVal = 0
	p.FloatVal = 0
	p.Int32Val = 0
	p.Int64Val = 0
	p.Uint32Val = 0
	p.Uint64Val = 0
	p.Sint32Val = 0
	p.Sint64Val = 0
	p.Fixed32Val = 0
	p.Fixed64Val = 0
	p.Sfixed32Val = 0
	p.Sfixed64Val = 0
	p.BoolVal = false
	p.StringVal = ""
	p.BytesVal = nil
	p.OptionalString = ""
	p.OptionalInt = 0
	p.OptionalBool = false
	p.OptionalDouble = 0
	p.OptionalBytes = nil
	p.StringList = p.StringList[:0]
	p.IntList = p.IntList[:0]
	p.DoubleList = p.DoubleList[:0]
	p.BytesList = p.BytesList[:0]
	p.BoolList = p.BoolList[:0]
	p.FloatList = p.FloatList[:0]
	p.Int64List = p.Int64List[:0]
	p.Uint32List = p.Uint32List[:0]
	p.Uint64List = p.Uint64List[:0]
	for k := range p.StringMap {
		delete(p.StringMap, k)
	}
	for k := range p.IntMap {
		delete(p.IntMap, k)
	}
	for k := range p.IntKeyMap {
		delete(p.IntKeyMap, k)
	}
	for k := range p.NestedMap {
		delete(p.NestedMap, k)
	}
	for k := range p.Int64KeyMap {
		delete(p.Int64KeyMap, k)
	}
	for k := range p.Uint32KeyMap {
		delete(p.Uint32KeyMap, k)
	}
	for k := range p.Uint64KeyMap {
		delete(p.Uint64KeyMap, k)
	}
	for k := range p.Sint32KeyMap {
		delete(p.Sint32KeyMap, k)
	}
	for k := range p.Sint64KeyMap {
		delete(p.Sint64KeyMap, k)
	}
	for k := range p.Fixed32KeyMap {
		delete(p.Fixed32KeyMap, k)
	}
	for k := range p.Fixed64KeyMap {
		delete(p.Fixed64KeyMap, k)
	}
	for k := range p.Sfixed32KeyMap {
		delete(p.Sfixed32KeyMap, k)
	}
	for k := range p.Sfixed64KeyMap {
		delete(p.Sfixed64KeyMap, k)
	}
	for k := range p.BoolKeyMap {
		delete(p.BoolKeyMap, k)
	}
	for k := range p.DoubleMap {
		delete(p.DoubleMap, k)
	}
	for k := range p.BytesMap {
		delete(p.BytesMap, k)
	}
	for k := range p.BoolMap {
		delete(p.BoolMap, k)
	}
	for k := range p.FloatMap {
		delete(p.FloatMap, k)
	}
	p.Status = 0
	p.StatusList = p.StatusList[:0]
	for k := range p.StatusMap {
		delete(p.StatusMap, k)
	}
	p.OptionalStatus = 0
	p.NestedEnum = 0
	p.NestedEnumList = p.NestedEnumList[:0]
	p.NestedConfig = nil
	p.NestedConfigList = nil
	for k := range p.NestedConfigMap {
		delete(p.NestedConfigMap, k)
	}
	p.Parent = nil
	p.Children = p.Children[:0]
}

type WellKnownTypesPlain struct {
	CreatedAt      *timestamppb.Timestamp    `json:"createdAt"`
	Ttl            *durationpb.Duration      `json:"ttl"`
	UpdatedAt      *timestamppb.Timestamp    `json:"updatedAt"`
	Latency        *durationpb.Duration      `json:"latency"`
	NullableString *wrapperspb.StringValue   `json:"nullableString"`
	NullableInt32  *wrapperspb.Int32Value    `json:"nullableInt32"`
	NullableInt64  *wrapperspb.Int64Value    `json:"nullableInt64"`
	NullableUint32 *wrapperspb.UInt32Value   `json:"nullableUint32"`
	NullableUint64 *wrapperspb.UInt64Value   `json:"nullableUint64"`
	NullableFloat  *wrapperspb.FloatValue    `json:"nullableFloat"`
	NullableDouble *wrapperspb.DoubleValue   `json:"nullableDouble"`
	NullableBool   *wrapperspb.BoolValue     `json:"nullableBool"`
	NullableBytes  *wrapperspb.BytesValue    `json:"nullableBytes"`
	Metadata       *structpb.Struct          `json:"metadata"`
	DynamicValue   *structpb.Value           `json:"dynamicValue"`
	ListValue      *structpb.ListValue       `json:"listValue"`
	Payload        *anypb.Any                `json:"payload"`
	Payloads       []*anypb.Any              `json:"payloads"`
	Empty          *emptypb.Empty            `json:"empty"`
	Timestamps     []*timestamppb.Timestamp  `json:"timestamps"`
	Durations      []*durationpb.Duration    `json:"durations"`
	Strings        []*wrapperspb.StringValue `json:"strings"`
	// Src_ contains indices of populated fields for sparse serialization
	Src_ []uint16 `json:"_src,omitempty"`
}

// IntoPlain converts protobuf message to plain struct
func (pb *WellKnownTypes) IntoPlain() *WellKnownTypesPlain {
	if pb == nil {
		return nil
	}
	p := &WellKnownTypesPlain{}

	p.CreatedAt = pb.CreatedAt
	p.Src_ = append(p.Src_, 0)
	p.Ttl = pb.Ttl
	p.Src_ = append(p.Src_, 1)
	p.UpdatedAt = pb.UpdatedAt
	p.Src_ = append(p.Src_, 2)
	p.Latency = pb.Latency
	p.Src_ = append(p.Src_, 3)
	p.NullableString = pb.NullableString
	p.Src_ = append(p.Src_, 4)
	p.NullableInt32 = pb.NullableInt32
	p.Src_ = append(p.Src_, 5)
	p.NullableInt64 = pb.NullableInt64
	p.Src_ = append(p.Src_, 6)
	p.NullableUint32 = pb.NullableUint32
	p.Src_ = append(p.Src_, 7)
	p.NullableUint64 = pb.NullableUint64
	p.Src_ = append(p.Src_, 8)
	p.NullableFloat = pb.NullableFloat
	p.Src_ = append(p.Src_, 9)
	p.NullableDouble = pb.NullableDouble
	p.Src_ = append(p.Src_, 10)
	p.NullableBool = pb.NullableBool
	p.Src_ = append(p.Src_, 11)
	p.NullableBytes = pb.NullableBytes
	p.Src_ = append(p.Src_, 12)
	p.Metadata = pb.Metadata
	p.Src_ = append(p.Src_, 13)
	p.DynamicValue = pb.DynamicValue
	p.Src_ = append(p.Src_, 14)
	p.ListValue = pb.ListValue
	p.Src_ = append(p.Src_, 15)
	p.Payload = pb.Payload
	p.Src_ = append(p.Src_, 16)
	p.Payloads = pb.Payloads
	p.Src_ = append(p.Src_, 17)
	p.Empty = pb.Empty
	p.Src_ = append(p.Src_, 18)
	p.Timestamps = pb.Timestamps
	p.Src_ = append(p.Src_, 19)
	p.Durations = pb.Durations
	p.Src_ = append(p.Src_, 20)
	p.Strings = pb.Strings
	p.Src_ = append(p.Src_, 21)
	return p
}

// IntoPb converts plain struct to protobuf message
func (p *WellKnownTypesPlain) IntoPb() *WellKnownTypes {
	if p == nil {
		return nil
	}
	pb := &WellKnownTypes{}

	pb.CreatedAt = p.CreatedAt
	pb.Ttl = p.Ttl
	pb.UpdatedAt = p.UpdatedAt
	pb.Latency = p.Latency
	pb.NullableString = p.NullableString
	pb.NullableInt32 = p.NullableInt32
	pb.NullableInt64 = p.NullableInt64
	pb.NullableUint32 = p.NullableUint32
	pb.NullableUint64 = p.NullableUint64
	pb.NullableFloat = p.NullableFloat
	pb.NullableDouble = p.NullableDouble
	pb.NullableBool = p.NullableBool
	pb.NullableBytes = p.NullableBytes
	pb.Metadata = p.Metadata
	pb.DynamicValue = p.DynamicValue
	pb.ListValue = p.ListValue
	pb.Payload = p.Payload
	pb.Payloads = p.Payloads
	pb.Empty = p.Empty
	pb.Timestamps = p.Timestamps
	pb.Durations = p.Durations
	pb.Strings = p.Strings
	return pb
}

// IntoPlainReuse converts protobuf message to existing plain struct (for pool usage)
func (pb *WellKnownTypes) IntoPlainReuse(p *WellKnownTypesPlain) {
	if pb == nil || p == nil {
		return
	}
	// Reset before filling
	p.Reset()

	p.CreatedAt = pb.CreatedAt
	p.Src_ = append(p.Src_, 0)
	p.Ttl = pb.Ttl
	p.Src_ = append(p.Src_, 1)
	p.UpdatedAt = pb.UpdatedAt
	p.Src_ = append(p.Src_, 2)
	p.Latency = pb.Latency
	p.Src_ = append(p.Src_, 3)
	p.NullableString = pb.NullableString
	p.Src_ = append(p.Src_, 4)
	p.NullableInt32 = pb.NullableInt32
	p.Src_ = append(p.Src_, 5)
	p.NullableInt64 = pb.NullableInt64
	p.Src_ = append(p.Src_, 6)
	p.NullableUint32 = pb.NullableUint32
	p.Src_ = append(p.Src_, 7)
	p.NullableUint64 = pb.NullableUint64
	p.Src_ = append(p.Src_, 8)
	p.NullableFloat = pb.NullableFloat
	p.Src_ = append(p.Src_, 9)
	p.NullableDouble = pb.NullableDouble
	p.Src_ = append(p.Src_, 10)
	p.NullableBool = pb.NullableBool
	p.Src_ = append(p.Src_, 11)
	p.NullableBytes = pb.NullableBytes
	p.Src_ = append(p.Src_, 12)
	p.Metadata = pb.Metadata
	p.Src_ = append(p.Src_, 13)
	p.DynamicValue = pb.DynamicValue
	p.Src_ = append(p.Src_, 14)
	p.ListValue = pb.ListValue
	p.Src_ = append(p.Src_, 15)
	p.Payload = pb.Payload
	p.Src_ = append(p.Src_, 16)
	p.Payloads = pb.Payloads
	p.Src_ = append(p.Src_, 17)
	p.Empty = pb.Empty
	p.Src_ = append(p.Src_, 18)
	p.Timestamps = pb.Timestamps
	p.Src_ = append(p.Src_, 19)
	p.Durations = pb.Durations
	p.Src_ = append(p.Src_, 20)
	p.Strings = pb.Strings
	p.Src_ = append(p.Src_, 21)
}

// MarshalJX encodes WellKnownTypesPlain to JSON using jx.Encoder
func (p *WellKnownTypesPlain) MarshalJX(e *jx.Encoder) {
	if p == nil {
		e.Null()
		return
	}

	e.ObjStart()

	if p.CreatedAt != nil {
		e.FieldStart("createdAt")
		if data, err := protojson.Marshal(p.CreatedAt); err == nil {
			e.Raw(data)
		} else {
			e.Null()
		}
	}
	if p.Ttl != nil {
		e.FieldStart("ttl")
		if data, err := protojson.Marshal(p.Ttl); err == nil {
			e.Raw(data)
		} else {
			e.Null()
		}
	}
	if p.UpdatedAt != nil {
		e.FieldStart("updatedAt")
		if data, err := protojson.Marshal(p.UpdatedAt); err == nil {
			e.Raw(data)
		} else {
			e.Null()
		}
	}
	if p.Latency != nil {
		e.FieldStart("latency")
		if data, err := protojson.Marshal(p.Latency); err == nil {
			e.Raw(data)
		} else {
			e.Null()
		}
	}
	if p.NullableString != nil {
		e.FieldStart("nullableString")
		if data, err := protojson.Marshal(p.NullableString); err == nil {
			e.Raw(data)
		} else {
			e.Null()
		}
	}
	if p.NullableInt32 != nil {
		e.FieldStart("nullableInt32")
		if data, err := protojson.Marshal(p.NullableInt32); err == nil {
			e.Raw(data)
		} else {
			e.Null()
		}
	}
	if p.NullableInt64 != nil {
		e.FieldStart("nullableInt64")
		if data, err := protojson.Marshal(p.NullableInt64); err == nil {
			e.Raw(data)
		} else {
			e.Null()
		}
	}
	if p.NullableUint32 != nil {
		e.FieldStart("nullableUint32")
		if data, err := protojson.Marshal(p.NullableUint32); err == nil {
			e.Raw(data)
		} else {
			e.Null()
		}
	}
	if p.NullableUint64 != nil {
		e.FieldStart("nullableUint64")
		if data, err := protojson.Marshal(p.NullableUint64); err == nil {
			e.Raw(data)
		} else {
			e.Null()
		}
	}
	if p.NullableFloat != nil {
		e.FieldStart("nullableFloat")
		if data, err := protojson.Marshal(p.NullableFloat); err == nil {
			e.Raw(data)
		} else {
			e.Null()
		}
	}
	if p.NullableDouble != nil {
		e.FieldStart("nullableDouble")
		if data, err := protojson.Marshal(p.NullableDouble); err == nil {
			e.Raw(data)
		} else {
			e.Null()
		}
	}
	if p.NullableBool != nil {
		e.FieldStart("nullableBool")
		if data, err := protojson.Marshal(p.NullableBool); err == nil {
			e.Raw(data)
		} else {
			e.Null()
		}
	}
	if p.NullableBytes != nil {
		e.FieldStart("nullableBytes")
		if data, err := protojson.Marshal(p.NullableBytes); err == nil {
			e.Raw(data)
		} else {
			e.Null()
		}
	}
	if p.Metadata != nil {
		e.FieldStart("metadata")
		if data, err := protojson.Marshal(p.Metadata); err == nil {
			e.Raw(data)
		} else {
			e.Null()
		}
	}
	if p.DynamicValue != nil {
		e.FieldStart("dynamicValue")
		if data, err := protojson.Marshal(p.DynamicValue); err == nil {
			e.Raw(data)
		} else {
			e.Null()
		}
	}
	if p.ListValue != nil {
		e.FieldStart("listValue")
		if data, err := protojson.Marshal(p.ListValue); err == nil {
			e.Raw(data)
		} else {
			e.Null()
		}
	}
	if p.Payload != nil {
		e.FieldStart("payload")
		if data, err := protojson.Marshal(p.Payload); err == nil {
			e.Raw(data)
		} else {
			e.Null()
		}
	}
	if p.Payloads != nil {
		e.FieldStart("payloads")
		e.ArrStart()
		for _, v := range p.Payloads {
			if data, err := protojson.Marshal(v); err == nil {
				e.Raw(data)
			} else {
				e.Null()
			}
		}
		e.ArrEnd()
	}
	if p.Empty != nil {
		e.FieldStart("empty")
		if data, err := protojson.Marshal(p.Empty); err == nil {
			e.Raw(data)
		} else {
			e.Null()
		}
	}
	if p.Timestamps != nil {
		e.FieldStart("timestamps")
		e.ArrStart()
		for _, v := range p.Timestamps {
			if data, err := protojson.Marshal(v); err == nil {
				e.Raw(data)
			} else {
				e.Null()
			}
		}
		e.ArrEnd()
	}
	if p.Durations != nil {
		e.FieldStart("durations")
		e.ArrStart()
		for _, v := range p.Durations {
			if data, err := protojson.Marshal(v); err == nil {
				e.Raw(data)
			} else {
				e.Null()
			}
		}
		e.ArrEnd()
	}
	if p.Strings != nil {
		e.FieldStart("strings")
		e.ArrStart()
		for _, v := range p.Strings {
			if data, err := protojson.Marshal(v); err == nil {
				e.Raw(data)
			} else {
				e.Null()
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

// MarshalJSON implements json.Marshaler using jx
func (p *WellKnownTypesPlain) MarshalJSON() ([]byte, error) {
	e := jx.GetEncoder()
	defer jx.PutEncoder(e)
	p.MarshalJX(e)
	return e.Bytes(), nil
}

// UnmarshalJX decodes WellKnownTypesPlain from JSON using jx.Decoder
// Populates Src_ with indices of decoded fields
func (p *WellKnownTypesPlain) UnmarshalJX(d *jx.Decoder) error {
	if p == nil {
		return nil
	}

	return d.Obj(func(d *jx.Decoder, key string) error {
		switch key {
		case "_src":
			return d.Arr(func(d *jx.Decoder) error {
				v, err := d.UInt16()
				if err != nil {
					return err
				}
				p.Src_ = append(p.Src_, v)
				return nil
			})
		case "createdAt":
			raw, err := d.Raw()
			if err != nil {
				return err
			}
			p.CreatedAt = &timestamppb.Timestamp{}
			if err := protojson.Unmarshal(raw, p.CreatedAt); err != nil {
				return err
			}
			p.Src_ = append(p.Src_, 0)
		case "ttl":
			raw, err := d.Raw()
			if err != nil {
				return err
			}
			p.Ttl = &durationpb.Duration{}
			if err := protojson.Unmarshal(raw, p.Ttl); err != nil {
				return err
			}
			p.Src_ = append(p.Src_, 1)
		case "updatedAt":
			raw, err := d.Raw()
			if err != nil {
				return err
			}
			p.UpdatedAt = &timestamppb.Timestamp{}
			if err := protojson.Unmarshal(raw, p.UpdatedAt); err != nil {
				return err
			}
			p.Src_ = append(p.Src_, 2)
		case "latency":
			raw, err := d.Raw()
			if err != nil {
				return err
			}
			p.Latency = &durationpb.Duration{}
			if err := protojson.Unmarshal(raw, p.Latency); err != nil {
				return err
			}
			p.Src_ = append(p.Src_, 3)
		case "nullableString":
			raw, err := d.Raw()
			if err != nil {
				return err
			}
			p.NullableString = &wrapperspb.StringValue{}
			if err := protojson.Unmarshal(raw, p.NullableString); err != nil {
				return err
			}
			p.Src_ = append(p.Src_, 4)
		case "nullableInt32":
			raw, err := d.Raw()
			if err != nil {
				return err
			}
			p.NullableInt32 = &wrapperspb.Int32Value{}
			if err := protojson.Unmarshal(raw, p.NullableInt32); err != nil {
				return err
			}
			p.Src_ = append(p.Src_, 5)
		case "nullableInt64":
			raw, err := d.Raw()
			if err != nil {
				return err
			}
			p.NullableInt64 = &wrapperspb.Int64Value{}
			if err := protojson.Unmarshal(raw, p.NullableInt64); err != nil {
				return err
			}
			p.Src_ = append(p.Src_, 6)
		case "nullableUint32":
			raw, err := d.Raw()
			if err != nil {
				return err
			}
			p.NullableUint32 = &wrapperspb.UInt32Value{}
			if err := protojson.Unmarshal(raw, p.NullableUint32); err != nil {
				return err
			}
			p.Src_ = append(p.Src_, 7)
		case "nullableUint64":
			raw, err := d.Raw()
			if err != nil {
				return err
			}
			p.NullableUint64 = &wrapperspb.UInt64Value{}
			if err := protojson.Unmarshal(raw, p.NullableUint64); err != nil {
				return err
			}
			p.Src_ = append(p.Src_, 8)
		case "nullableFloat":
			raw, err := d.Raw()
			if err != nil {
				return err
			}
			p.NullableFloat = &wrapperspb.FloatValue{}
			if err := protojson.Unmarshal(raw, p.NullableFloat); err != nil {
				return err
			}
			p.Src_ = append(p.Src_, 9)
		case "nullableDouble":
			raw, err := d.Raw()
			if err != nil {
				return err
			}
			p.NullableDouble = &wrapperspb.DoubleValue{}
			if err := protojson.Unmarshal(raw, p.NullableDouble); err != nil {
				return err
			}
			p.Src_ = append(p.Src_, 10)
		case "nullableBool":
			raw, err := d.Raw()
			if err != nil {
				return err
			}
			p.NullableBool = &wrapperspb.BoolValue{}
			if err := protojson.Unmarshal(raw, p.NullableBool); err != nil {
				return err
			}
			p.Src_ = append(p.Src_, 11)
		case "nullableBytes":
			raw, err := d.Raw()
			if err != nil {
				return err
			}
			p.NullableBytes = &wrapperspb.BytesValue{}
			if err := protojson.Unmarshal(raw, p.NullableBytes); err != nil {
				return err
			}
			p.Src_ = append(p.Src_, 12)
		case "metadata":
			raw, err := d.Raw()
			if err != nil {
				return err
			}
			p.Metadata = &structpb.Struct{}
			if err := protojson.Unmarshal(raw, p.Metadata); err != nil {
				return err
			}
			p.Src_ = append(p.Src_, 13)
		case "dynamicValue":
			raw, err := d.Raw()
			if err != nil {
				return err
			}
			p.DynamicValue = &structpb.Value{}
			if err := protojson.Unmarshal(raw, p.DynamicValue); err != nil {
				return err
			}
			p.Src_ = append(p.Src_, 14)
		case "listValue":
			raw, err := d.Raw()
			if err != nil {
				return err
			}
			p.ListValue = &structpb.ListValue{}
			if err := protojson.Unmarshal(raw, p.ListValue); err != nil {
				return err
			}
			p.Src_ = append(p.Src_, 15)
		case "payload":
			raw, err := d.Raw()
			if err != nil {
				return err
			}
			p.Payload = &anypb.Any{}
			if err := protojson.Unmarshal(raw, p.Payload); err != nil {
				return err
			}
			p.Src_ = append(p.Src_, 16)
		case "payloads":
			if err := d.Arr(func(d *jx.Decoder) error {
				raw, err := d.Raw()
				if err != nil {
					return err
				}
				var v anypb.Any
				if err := protojson.Unmarshal(raw, &v); err != nil {
					return err
				}
				p.Payloads = append(p.Payloads, &v)
				return nil
			}); err != nil {
				return err
			}
			p.Src_ = append(p.Src_, 17)
		case "empty":
			raw, err := d.Raw()
			if err != nil {
				return err
			}
			p.Empty = &emptypb.Empty{}
			if err := protojson.Unmarshal(raw, p.Empty); err != nil {
				return err
			}
			p.Src_ = append(p.Src_, 18)
		case "timestamps":
			if err := d.Arr(func(d *jx.Decoder) error {
				raw, err := d.Raw()
				if err != nil {
					return err
				}
				var v timestamppb.Timestamp
				if err := protojson.Unmarshal(raw, &v); err != nil {
					return err
				}
				p.Timestamps = append(p.Timestamps, &v)
				return nil
			}); err != nil {
				return err
			}
			p.Src_ = append(p.Src_, 19)
		case "durations":
			if err := d.Arr(func(d *jx.Decoder) error {
				raw, err := d.Raw()
				if err != nil {
					return err
				}
				var v durationpb.Duration
				if err := protojson.Unmarshal(raw, &v); err != nil {
					return err
				}
				p.Durations = append(p.Durations, &v)
				return nil
			}); err != nil {
				return err
			}
			p.Src_ = append(p.Src_, 20)
		case "strings":
			if err := d.Arr(func(d *jx.Decoder) error {
				raw, err := d.Raw()
				if err != nil {
					return err
				}
				var v wrapperspb.StringValue
				if err := protojson.Unmarshal(raw, &v); err != nil {
					return err
				}
				p.Strings = append(p.Strings, &v)
				return nil
			}); err != nil {
				return err
			}
			p.Src_ = append(p.Src_, 21)
		default:
			return d.Skip()
		}
		return nil
	})
}

// UnmarshalJSON implements json.Unmarshaler using jx
func (p *WellKnownTypesPlain) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return p.UnmarshalJX(d)
}

// wellKnownTypesPlainPool is a sync.Pool for WellKnownTypesPlain objects
var wellKnownTypesPlainPool = sync.Pool{
	New: func() interface{} {
		return &WellKnownTypesPlain{
			Src_: make([]uint16, 0, 32),
		}
	},
}

// GetWellKnownTypesPlain returns a WellKnownTypesPlain from the pool
func GetWellKnownTypesPlain() *WellKnownTypesPlain {
	return wellKnownTypesPlainPool.Get().(*WellKnownTypesPlain)
}

// PutWellKnownTypesPlain returns a WellKnownTypesPlain to the pool after resetting it
func PutWellKnownTypesPlain(p *WellKnownTypesPlain) {
	if p == nil {
		return
	}
	p.Reset()
	wellKnownTypesPlainPool.Put(p)
}

// Reset clears all fields in WellKnownTypesPlain for reuse
func (p *WellKnownTypesPlain) Reset() {
	if p == nil {
		return
	}

	p.Src_ = p.Src_[:0]

	p.CreatedAt = nil
	p.Ttl = nil
	p.UpdatedAt = nil
	p.Latency = nil
	p.NullableString = nil
	p.NullableInt32 = nil
	p.NullableInt64 = nil
	p.NullableUint32 = nil
	p.NullableUint64 = nil
	p.NullableFloat = nil
	p.NullableDouble = nil
	p.NullableBool = nil
	p.NullableBytes = nil
	p.Metadata = nil
	p.DynamicValue = nil
	p.ListValue = nil
	p.Payload = nil
	p.Payloads = nil
	p.Empty = nil
	p.Timestamps = nil
	p.Durations = nil
	p.Strings = nil
}

type MapShowcasePlain struct {
	StrStr       map[string]string       `json:"strStr"`
	StrInt32     map[string]int32        `json:"strInt32"`
	StrInt64     map[string]int64        `json:"strInt64"`
	StrUint32    map[string]uint32       `json:"strUint32"`
	StrUint64    map[string]uint64       `json:"strUint64"`
	StrFloat     map[string]float32      `json:"strFloat"`
	StrDouble    map[string]float64      `json:"strDouble"`
	StrBool      map[string]bool         `json:"strBool"`
	StrBytes     map[string][]byte       `json:"strBytes"`
	Int32Str     map[int32]string        `json:"int32Str"`
	Int64Str     map[int64]string        `json:"int64Str"`
	Uint32Str    map[uint32]string       `json:"uint32Str"`
	Uint64Str    map[uint64]string       `json:"uint64Str"`
	Sint32Str    map[int32]string        `json:"sint32Str"`
	Sint64Str    map[int64]string        `json:"sint64Str"`
	Fixed32Str   map[uint32]string       `json:"fixed32Str"`
	Fixed64Str   map[uint64]string       `json:"fixed64Str"`
	Sfixed32Str  map[int32]string        `json:"sfixed32Str"`
	Sfixed64Str  map[int64]string        `json:"sfixed64Str"`
	BoolStr      map[bool]string         `json:"boolStr"`
	StrMessage   map[string]*Address     `json:"strMessage"`
	Int32Message map[int32]*Address      `json:"int32Message"`
	Int64Message map[int64]*Metadata     `json:"int64Message"`
	StrEnum      map[string]Status       `json:"strEnum"`
	Int32Enum    map[int32]Priority      `json:"int32Enum"`
	Nested       map[string]*ConfigPlain `json:"nested"`
	// Src_ contains indices of populated fields for sparse serialization
	Src_ []uint16 `json:"_src,omitempty"`
}

// IntoPlain converts protobuf message to plain struct
func (pb *MapShowcase) IntoPlain() *MapShowcasePlain {
	if pb == nil {
		return nil
	}
	p := &MapShowcasePlain{}

	p.StrStr = pb.StrStr
	p.Src_ = append(p.Src_, 0)
	p.StrInt32 = pb.StrInt32
	p.Src_ = append(p.Src_, 1)
	p.StrInt64 = pb.StrInt64
	p.Src_ = append(p.Src_, 2)
	p.StrUint32 = pb.StrUint32
	p.Src_ = append(p.Src_, 3)
	p.StrUint64 = pb.StrUint64
	p.Src_ = append(p.Src_, 4)
	p.StrFloat = pb.StrFloat
	p.Src_ = append(p.Src_, 5)
	p.StrDouble = pb.StrDouble
	p.Src_ = append(p.Src_, 6)
	p.StrBool = pb.StrBool
	p.Src_ = append(p.Src_, 7)
	p.StrBytes = pb.StrBytes
	p.Src_ = append(p.Src_, 8)
	p.Int32Str = pb.Int32Str
	p.Src_ = append(p.Src_, 9)
	p.Int64Str = pb.Int64Str
	p.Src_ = append(p.Src_, 10)
	p.Uint32Str = pb.Uint32Str
	p.Src_ = append(p.Src_, 11)
	p.Uint64Str = pb.Uint64Str
	p.Src_ = append(p.Src_, 12)
	p.Sint32Str = pb.Sint32Str
	p.Src_ = append(p.Src_, 13)
	p.Sint64Str = pb.Sint64Str
	p.Src_ = append(p.Src_, 14)
	p.Fixed32Str = pb.Fixed32Str
	p.Src_ = append(p.Src_, 15)
	p.Fixed64Str = pb.Fixed64Str
	p.Src_ = append(p.Src_, 16)
	p.Sfixed32Str = pb.Sfixed32Str
	p.Src_ = append(p.Src_, 17)
	p.Sfixed64Str = pb.Sfixed64Str
	p.Src_ = append(p.Src_, 18)
	p.BoolStr = pb.BoolStr
	p.Src_ = append(p.Src_, 19)
	p.StrMessage = pb.StrMessage
	p.Src_ = append(p.Src_, 20)
	p.Int32Message = pb.Int32Message
	p.Src_ = append(p.Src_, 21)
	p.Int64Message = pb.Int64Message
	p.Src_ = append(p.Src_, 22)
	p.StrEnum = pb.StrEnum
	p.Src_ = append(p.Src_, 23)
	p.Int32Enum = pb.Int32Enum
	p.Src_ = append(p.Src_, 24)
	if len(pb.Nested) > 0 {
		p.Nested = make(map[string]*ConfigPlain, len(pb.Nested))
		for k, v := range pb.Nested {
			if v != nil {
				p.Nested[k] = v.IntoPlain()
			}
		}
		p.Src_ = append(p.Src_, 25)
	}
	return p
}

// IntoPb converts plain struct to protobuf message
func (p *MapShowcasePlain) IntoPb() *MapShowcase {
	if p == nil {
		return nil
	}
	pb := &MapShowcase{}

	pb.StrStr = p.StrStr
	pb.StrInt32 = p.StrInt32
	pb.StrInt64 = p.StrInt64
	pb.StrUint32 = p.StrUint32
	pb.StrUint64 = p.StrUint64
	pb.StrFloat = p.StrFloat
	pb.StrDouble = p.StrDouble
	pb.StrBool = p.StrBool
	pb.StrBytes = p.StrBytes
	pb.Int32Str = p.Int32Str
	pb.Int64Str = p.Int64Str
	pb.Uint32Str = p.Uint32Str
	pb.Uint64Str = p.Uint64Str
	pb.Sint32Str = p.Sint32Str
	pb.Sint64Str = p.Sint64Str
	pb.Fixed32Str = p.Fixed32Str
	pb.Fixed64Str = p.Fixed64Str
	pb.Sfixed32Str = p.Sfixed32Str
	pb.Sfixed64Str = p.Sfixed64Str
	pb.BoolStr = p.BoolStr
	pb.StrMessage = p.StrMessage
	pb.Int32Message = p.Int32Message
	pb.Int64Message = p.Int64Message
	pb.StrEnum = p.StrEnum
	pb.Int32Enum = p.Int32Enum
	if len(p.Nested) > 0 {
		pb.Nested = make(map[string]*Config, len(p.Nested))
		for k, v := range p.Nested {
			if v != nil {
				pb.Nested[k] = v.IntoPb()
			}
		}
	}
	return pb
}

// IntoPlainReuse converts protobuf message to existing plain struct (for pool usage)
func (pb *MapShowcase) IntoPlainReuse(p *MapShowcasePlain) {
	if pb == nil || p == nil {
		return
	}
	// Reset before filling
	p.Reset()

	p.StrStr = pb.StrStr
	p.Src_ = append(p.Src_, 0)
	p.StrInt32 = pb.StrInt32
	p.Src_ = append(p.Src_, 1)
	p.StrInt64 = pb.StrInt64
	p.Src_ = append(p.Src_, 2)
	p.StrUint32 = pb.StrUint32
	p.Src_ = append(p.Src_, 3)
	p.StrUint64 = pb.StrUint64
	p.Src_ = append(p.Src_, 4)
	p.StrFloat = pb.StrFloat
	p.Src_ = append(p.Src_, 5)
	p.StrDouble = pb.StrDouble
	p.Src_ = append(p.Src_, 6)
	p.StrBool = pb.StrBool
	p.Src_ = append(p.Src_, 7)
	p.StrBytes = pb.StrBytes
	p.Src_ = append(p.Src_, 8)
	p.Int32Str = pb.Int32Str
	p.Src_ = append(p.Src_, 9)
	p.Int64Str = pb.Int64Str
	p.Src_ = append(p.Src_, 10)
	p.Uint32Str = pb.Uint32Str
	p.Src_ = append(p.Src_, 11)
	p.Uint64Str = pb.Uint64Str
	p.Src_ = append(p.Src_, 12)
	p.Sint32Str = pb.Sint32Str
	p.Src_ = append(p.Src_, 13)
	p.Sint64Str = pb.Sint64Str
	p.Src_ = append(p.Src_, 14)
	p.Fixed32Str = pb.Fixed32Str
	p.Src_ = append(p.Src_, 15)
	p.Fixed64Str = pb.Fixed64Str
	p.Src_ = append(p.Src_, 16)
	p.Sfixed32Str = pb.Sfixed32Str
	p.Src_ = append(p.Src_, 17)
	p.Sfixed64Str = pb.Sfixed64Str
	p.Src_ = append(p.Src_, 18)
	p.BoolStr = pb.BoolStr
	p.Src_ = append(p.Src_, 19)
	p.StrMessage = pb.StrMessage
	p.Src_ = append(p.Src_, 20)
	p.Int32Message = pb.Int32Message
	p.Src_ = append(p.Src_, 21)
	p.Int64Message = pb.Int64Message
	p.Src_ = append(p.Src_, 22)
	p.StrEnum = pb.StrEnum
	p.Src_ = append(p.Src_, 23)
	p.Int32Enum = pb.Int32Enum
	p.Src_ = append(p.Src_, 24)
	if len(pb.Nested) > 0 {
		p.Nested = make(map[string]*ConfigPlain, len(pb.Nested))
		for k, v := range pb.Nested {
			if v != nil {
				p.Nested[k] = v.IntoPlain()
			}
		}
		p.Src_ = append(p.Src_, 25)
	}
}

// MarshalJX encodes MapShowcasePlain to JSON using jx.Encoder
func (p *MapShowcasePlain) MarshalJX(e *jx.Encoder) {
	if p == nil {
		e.Null()
		return
	}

	e.ObjStart()

	e.FieldStart("strStr")
	e.ObjStart()
	for k, v := range p.StrStr {
		e.FieldStart(k)
		e.Str(v)
	}
	e.ObjEnd()
	e.FieldStart("strInt32")
	e.ObjStart()
	for k, v := range p.StrInt32 {
		e.FieldStart(k)
		e.Int32(v)
	}
	e.ObjEnd()
	e.FieldStart("strInt64")
	e.ObjStart()
	for k, v := range p.StrInt64 {
		e.FieldStart(k)
		e.Int64(v)
	}
	e.ObjEnd()
	e.FieldStart("strUint32")
	e.ObjStart()
	for k, v := range p.StrUint32 {
		e.FieldStart(k)
		e.UInt32(v)
	}
	e.ObjEnd()
	e.FieldStart("strUint64")
	e.ObjStart()
	for k, v := range p.StrUint64 {
		e.FieldStart(k)
		e.UInt64(v)
	}
	e.ObjEnd()
	e.FieldStart("strFloat")
	e.ObjStart()
	for k, v := range p.StrFloat {
		e.FieldStart(k)
		e.Float32(v)
	}
	e.ObjEnd()
	e.FieldStart("strDouble")
	e.ObjStart()
	for k, v := range p.StrDouble {
		e.FieldStart(k)
		e.Float64(v)
	}
	e.ObjEnd()
	e.FieldStart("strBool")
	e.ObjStart()
	for k, v := range p.StrBool {
		e.FieldStart(k)
		e.Bool(v)
	}
	e.ObjEnd()
	e.FieldStart("strBytes")
	e.ObjStart()
	for k, v := range p.StrBytes {
		e.FieldStart(k)
		e.Base64(v)
	}
	e.ObjEnd()
	e.FieldStart("int32Str")
	e.ObjStart()
	for k, v := range p.Int32Str {
		e.FieldStart(fmt.Sprint(k))
		e.Str(v)
	}
	e.ObjEnd()
	e.FieldStart("int64Str")
	e.ObjStart()
	for k, v := range p.Int64Str {
		e.FieldStart(fmt.Sprint(k))
		e.Str(v)
	}
	e.ObjEnd()
	e.FieldStart("uint32Str")
	e.ObjStart()
	for k, v := range p.Uint32Str {
		e.FieldStart(fmt.Sprint(k))
		e.Str(v)
	}
	e.ObjEnd()
	e.FieldStart("uint64Str")
	e.ObjStart()
	for k, v := range p.Uint64Str {
		e.FieldStart(fmt.Sprint(k))
		e.Str(v)
	}
	e.ObjEnd()
	e.FieldStart("sint32Str")
	e.ObjStart()
	for k, v := range p.Sint32Str {
		e.FieldStart(fmt.Sprint(k))
		e.Str(v)
	}
	e.ObjEnd()
	e.FieldStart("sint64Str")
	e.ObjStart()
	for k, v := range p.Sint64Str {
		e.FieldStart(fmt.Sprint(k))
		e.Str(v)
	}
	e.ObjEnd()
	e.FieldStart("fixed32Str")
	e.ObjStart()
	for k, v := range p.Fixed32Str {
		e.FieldStart(fmt.Sprint(k))
		e.Str(v)
	}
	e.ObjEnd()
	e.FieldStart("fixed64Str")
	e.ObjStart()
	for k, v := range p.Fixed64Str {
		e.FieldStart(fmt.Sprint(k))
		e.Str(v)
	}
	e.ObjEnd()
	e.FieldStart("sfixed32Str")
	e.ObjStart()
	for k, v := range p.Sfixed32Str {
		e.FieldStart(fmt.Sprint(k))
		e.Str(v)
	}
	e.ObjEnd()
	e.FieldStart("sfixed64Str")
	e.ObjStart()
	for k, v := range p.Sfixed64Str {
		e.FieldStart(fmt.Sprint(k))
		e.Str(v)
	}
	e.ObjEnd()
	e.FieldStart("boolStr")
	e.ObjStart()
	for k, v := range p.BoolStr {
		e.FieldStart(fmt.Sprint(k))
		e.Str(v)
	}
	e.ObjEnd()
	e.FieldStart("strMessage")
	e.ObjStart()
	for k, v := range p.StrMessage {
		e.FieldStart(k)
		if data, err := protojson.Marshal(v); err == nil {
			e.Raw(data)
		} else {
			e.Null()
		}
	}
	e.ObjEnd()
	e.FieldStart("int32Message")
	e.ObjStart()
	for k, v := range p.Int32Message {
		e.FieldStart(fmt.Sprint(k))
		if data, err := protojson.Marshal(v); err == nil {
			e.Raw(data)
		} else {
			e.Null()
		}
	}
	e.ObjEnd()
	e.FieldStart("int64Message")
	e.ObjStart()
	for k, v := range p.Int64Message {
		e.FieldStart(fmt.Sprint(k))
		if data, err := protojson.Marshal(v); err == nil {
			e.Raw(data)
		} else {
			e.Null()
		}
	}
	e.ObjEnd()
	e.FieldStart("strEnum")
	e.ObjStart()
	for k, v := range p.StrEnum {
		e.FieldStart(k)
		e.Int32(int32(v))
	}
	e.ObjEnd()
	e.FieldStart("int32Enum")
	e.ObjStart()
	for k, v := range p.Int32Enum {
		e.FieldStart(fmt.Sprint(k))
		e.Int32(int32(v))
	}
	e.ObjEnd()
	e.FieldStart("nested")
	e.ObjStart()
	for k, v := range p.Nested {
		e.FieldStart(k)
		v.MarshalJX(e)
	}
	e.ObjEnd()
	e.ObjEnd()
}

// MarshalJSON implements json.Marshaler using jx
func (p *MapShowcasePlain) MarshalJSON() ([]byte, error) {
	e := jx.GetEncoder()
	defer jx.PutEncoder(e)
	p.MarshalJX(e)
	return e.Bytes(), nil
}

// UnmarshalJX decodes MapShowcasePlain from JSON using jx.Decoder
// Populates Src_ with indices of decoded fields
func (p *MapShowcasePlain) UnmarshalJX(d *jx.Decoder) error {
	if p == nil {
		return nil
	}

	return d.Obj(func(d *jx.Decoder, key string) error {
		switch key {
		case "_src":
			return d.Arr(func(d *jx.Decoder) error {
				v, err := d.UInt16()
				if err != nil {
					return err
				}
				p.Src_ = append(p.Src_, v)
				return nil
			})
		case "strStr":
			if p.StrStr == nil {
				p.StrStr = make(map[string]string)
			}
			return d.Obj(func(d *jx.Decoder, key string) error {
				v, err := d.Str()
				if err != nil {
					return err
				}
				p.StrStr[key] = v
				return nil
			})
			p.Src_ = append(p.Src_, 0)
		case "strInt32":
			if p.StrInt32 == nil {
				p.StrInt32 = make(map[string]int32)
			}
			return d.Obj(func(d *jx.Decoder, key string) error {
				v, err := d.Int32()
				if err != nil {
					return err
				}
				p.StrInt32[key] = v
				return nil
			})
			p.Src_ = append(p.Src_, 1)
		case "strInt64":
			if p.StrInt64 == nil {
				p.StrInt64 = make(map[string]int64)
			}
			return d.Obj(func(d *jx.Decoder, key string) error {
				v, err := d.Int64()
				if err != nil {
					return err
				}
				p.StrInt64[key] = v
				return nil
			})
			p.Src_ = append(p.Src_, 2)
		case "strUint32":
			if p.StrUint32 == nil {
				p.StrUint32 = make(map[string]uint32)
			}
			return d.Obj(func(d *jx.Decoder, key string) error {
				v, err := d.UInt32()
				if err != nil {
					return err
				}
				p.StrUint32[key] = v
				return nil
			})
			p.Src_ = append(p.Src_, 3)
		case "strUint64":
			if p.StrUint64 == nil {
				p.StrUint64 = make(map[string]uint64)
			}
			return d.Obj(func(d *jx.Decoder, key string) error {
				v, err := d.UInt64()
				if err != nil {
					return err
				}
				p.StrUint64[key] = v
				return nil
			})
			p.Src_ = append(p.Src_, 4)
		case "strFloat":
			if p.StrFloat == nil {
				p.StrFloat = make(map[string]float32)
			}
			return d.Obj(func(d *jx.Decoder, key string) error {
				v, err := d.Float32()
				if err != nil {
					return err
				}
				p.StrFloat[key] = v
				return nil
			})
			p.Src_ = append(p.Src_, 5)
		case "strDouble":
			if p.StrDouble == nil {
				p.StrDouble = make(map[string]float64)
			}
			return d.Obj(func(d *jx.Decoder, key string) error {
				v, err := d.Float64()
				if err != nil {
					return err
				}
				p.StrDouble[key] = v
				return nil
			})
			p.Src_ = append(p.Src_, 6)
		case "strBool":
			if p.StrBool == nil {
				p.StrBool = make(map[string]bool)
			}
			return d.Obj(func(d *jx.Decoder, key string) error {
				v, err := d.Bool()
				if err != nil {
					return err
				}
				p.StrBool[key] = v
				return nil
			})
			p.Src_ = append(p.Src_, 7)
		case "strBytes":
			if p.StrBytes == nil {
				p.StrBytes = make(map[string][]byte)
			}
			return d.Obj(func(d *jx.Decoder, key string) error {
				v, err := d.Base64()
				if err != nil {
					return err
				}
				p.StrBytes[key] = v
				return nil
			})
			p.Src_ = append(p.Src_, 8)
		case "int32Str":
			if p.Int32Str == nil {
				p.Int32Str = make(map[int32]string)
			}
			return d.Obj(func(d *jx.Decoder, key string) error {
				_k, err := strconv.ParseInt(key, 10, 32)
				if err != nil {
					return err
				}
				_mapKey := int32(_k)
				v, err := d.Str()
				if err != nil {
					return err
				}
				p.Int32Str[_mapKey] = v
				return nil
			})
			p.Src_ = append(p.Src_, 9)
		case "int64Str":
			if p.Int64Str == nil {
				p.Int64Str = make(map[int64]string)
			}
			return d.Obj(func(d *jx.Decoder, key string) error {
				_mapKey, err := strconv.ParseInt(key, 10, 64)
				if err != nil {
					return err
				}
				v, err := d.Str()
				if err != nil {
					return err
				}
				p.Int64Str[_mapKey] = v
				return nil
			})
			p.Src_ = append(p.Src_, 10)
		case "uint32Str":
			if p.Uint32Str == nil {
				p.Uint32Str = make(map[uint32]string)
			}
			return d.Obj(func(d *jx.Decoder, key string) error {
				_k, err := strconv.ParseUint(key, 10, 32)
				if err != nil {
					return err
				}
				_mapKey := uint32(_k)
				v, err := d.Str()
				if err != nil {
					return err
				}
				p.Uint32Str[_mapKey] = v
				return nil
			})
			p.Src_ = append(p.Src_, 11)
		case "uint64Str":
			if p.Uint64Str == nil {
				p.Uint64Str = make(map[uint64]string)
			}
			return d.Obj(func(d *jx.Decoder, key string) error {
				_mapKey, err := strconv.ParseUint(key, 10, 64)
				if err != nil {
					return err
				}
				v, err := d.Str()
				if err != nil {
					return err
				}
				p.Uint64Str[_mapKey] = v
				return nil
			})
			p.Src_ = append(p.Src_, 12)
		case "sint32Str":
			if p.Sint32Str == nil {
				p.Sint32Str = make(map[int32]string)
			}
			return d.Obj(func(d *jx.Decoder, key string) error {
				_k, err := strconv.ParseInt(key, 10, 32)
				if err != nil {
					return err
				}
				_mapKey := int32(_k)
				v, err := d.Str()
				if err != nil {
					return err
				}
				p.Sint32Str[_mapKey] = v
				return nil
			})
			p.Src_ = append(p.Src_, 13)
		case "sint64Str":
			if p.Sint64Str == nil {
				p.Sint64Str = make(map[int64]string)
			}
			return d.Obj(func(d *jx.Decoder, key string) error {
				_mapKey, err := strconv.ParseInt(key, 10, 64)
				if err != nil {
					return err
				}
				v, err := d.Str()
				if err != nil {
					return err
				}
				p.Sint64Str[_mapKey] = v
				return nil
			})
			p.Src_ = append(p.Src_, 14)
		case "fixed32Str":
			if p.Fixed32Str == nil {
				p.Fixed32Str = make(map[uint32]string)
			}
			return d.Obj(func(d *jx.Decoder, key string) error {
				_k, err := strconv.ParseUint(key, 10, 32)
				if err != nil {
					return err
				}
				_mapKey := uint32(_k)
				v, err := d.Str()
				if err != nil {
					return err
				}
				p.Fixed32Str[_mapKey] = v
				return nil
			})
			p.Src_ = append(p.Src_, 15)
		case "fixed64Str":
			if p.Fixed64Str == nil {
				p.Fixed64Str = make(map[uint64]string)
			}
			return d.Obj(func(d *jx.Decoder, key string) error {
				_mapKey, err := strconv.ParseUint(key, 10, 64)
				if err != nil {
					return err
				}
				v, err := d.Str()
				if err != nil {
					return err
				}
				p.Fixed64Str[_mapKey] = v
				return nil
			})
			p.Src_ = append(p.Src_, 16)
		case "sfixed32Str":
			if p.Sfixed32Str == nil {
				p.Sfixed32Str = make(map[int32]string)
			}
			return d.Obj(func(d *jx.Decoder, key string) error {
				_k, err := strconv.ParseInt(key, 10, 32)
				if err != nil {
					return err
				}
				_mapKey := int32(_k)
				v, err := d.Str()
				if err != nil {
					return err
				}
				p.Sfixed32Str[_mapKey] = v
				return nil
			})
			p.Src_ = append(p.Src_, 17)
		case "sfixed64Str":
			if p.Sfixed64Str == nil {
				p.Sfixed64Str = make(map[int64]string)
			}
			return d.Obj(func(d *jx.Decoder, key string) error {
				_mapKey, err := strconv.ParseInt(key, 10, 64)
				if err != nil {
					return err
				}
				v, err := d.Str()
				if err != nil {
					return err
				}
				p.Sfixed64Str[_mapKey] = v
				return nil
			})
			p.Src_ = append(p.Src_, 18)
		case "boolStr":
			if p.BoolStr == nil {
				p.BoolStr = make(map[bool]string)
			}
			return d.Obj(func(d *jx.Decoder, key string) error {
				_mapKey, err := strconv.ParseBool(key)
				if err != nil {
					return err
				}
				v, err := d.Str()
				if err != nil {
					return err
				}
				p.BoolStr[_mapKey] = v
				return nil
			})
			p.Src_ = append(p.Src_, 19)
		case "strMessage":
			if p.StrMessage == nil {
				p.StrMessage = make(map[string]*Address)
			}
			return d.Obj(func(d *jx.Decoder, key string) error {
				raw, err := d.Raw()
				if err != nil {
					return err
				}
				p.StrMessage[key] = &Address{}
				if err := protojson.Unmarshal(raw, p.StrMessage[key]); err != nil {
					return err
				}
				return nil
			})
			p.Src_ = append(p.Src_, 20)
		case "int32Message":
			if p.Int32Message == nil {
				p.Int32Message = make(map[int32]*Address)
			}
			return d.Obj(func(d *jx.Decoder, key string) error {
				_k, err := strconv.ParseInt(key, 10, 32)
				if err != nil {
					return err
				}
				_mapKey := int32(_k)
				raw, err := d.Raw()
				if err != nil {
					return err
				}
				p.Int32Message[_mapKey] = &Address{}
				if err := protojson.Unmarshal(raw, p.Int32Message[_mapKey]); err != nil {
					return err
				}
				return nil
			})
			p.Src_ = append(p.Src_, 21)
		case "int64Message":
			if p.Int64Message == nil {
				p.Int64Message = make(map[int64]*Metadata)
			}
			return d.Obj(func(d *jx.Decoder, key string) error {
				_mapKey, err := strconv.ParseInt(key, 10, 64)
				if err != nil {
					return err
				}
				raw, err := d.Raw()
				if err != nil {
					return err
				}
				p.Int64Message[_mapKey] = &Metadata{}
				if err := protojson.Unmarshal(raw, p.Int64Message[_mapKey]); err != nil {
					return err
				}
				return nil
			})
			p.Src_ = append(p.Src_, 22)
		case "strEnum":
			if p.StrEnum == nil {
				p.StrEnum = make(map[string]Status)
			}
			return d.Obj(func(d *jx.Decoder, key string) error {
				v, err := d.Int32()
				if err != nil {
					return err
				}
				p.StrEnum[key] = Status(v)
				return nil
			})
			p.Src_ = append(p.Src_, 23)
		case "int32Enum":
			if p.Int32Enum == nil {
				p.Int32Enum = make(map[int32]Priority)
			}
			return d.Obj(func(d *jx.Decoder, key string) error {
				_k, err := strconv.ParseInt(key, 10, 32)
				if err != nil {
					return err
				}
				_mapKey := int32(_k)
				v, err := d.Int32()
				if err != nil {
					return err
				}
				p.Int32Enum[_mapKey] = Priority(v)
				return nil
			})
			p.Src_ = append(p.Src_, 24)
		case "nested":
			if p.Nested == nil {
				p.Nested = make(map[string]*ConfigPlain)
			}
			return d.Obj(func(d *jx.Decoder, key string) error {
				p.Nested[key] = &ConfigPlain{}
				if err := p.Nested[key].UnmarshalJX(d); err != nil {
					return err
				}
				return nil
			})
			p.Src_ = append(p.Src_, 25)
		default:
			return d.Skip()
		}
		return nil
	})
}

// UnmarshalJSON implements json.Unmarshaler using jx
func (p *MapShowcasePlain) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return p.UnmarshalJX(d)
}

// mapShowcasePlainPool is a sync.Pool for MapShowcasePlain objects
var mapShowcasePlainPool = sync.Pool{
	New: func() interface{} {
		return &MapShowcasePlain{
			Src_: make([]uint16, 0, 32),
		}
	},
}

// GetMapShowcasePlain returns a MapShowcasePlain from the pool
func GetMapShowcasePlain() *MapShowcasePlain {
	return mapShowcasePlainPool.Get().(*MapShowcasePlain)
}

// PutMapShowcasePlain returns a MapShowcasePlain to the pool after resetting it
func PutMapShowcasePlain(p *MapShowcasePlain) {
	if p == nil {
		return
	}
	p.Reset()
	mapShowcasePlainPool.Put(p)
}

// Reset clears all fields in MapShowcasePlain for reuse
func (p *MapShowcasePlain) Reset() {
	if p == nil {
		return
	}

	p.Src_ = p.Src_[:0]

	for k := range p.StrStr {
		delete(p.StrStr, k)
	}
	for k := range p.StrInt32 {
		delete(p.StrInt32, k)
	}
	for k := range p.StrInt64 {
		delete(p.StrInt64, k)
	}
	for k := range p.StrUint32 {
		delete(p.StrUint32, k)
	}
	for k := range p.StrUint64 {
		delete(p.StrUint64, k)
	}
	for k := range p.StrFloat {
		delete(p.StrFloat, k)
	}
	for k := range p.StrDouble {
		delete(p.StrDouble, k)
	}
	for k := range p.StrBool {
		delete(p.StrBool, k)
	}
	for k := range p.StrBytes {
		delete(p.StrBytes, k)
	}
	for k := range p.Int32Str {
		delete(p.Int32Str, k)
	}
	for k := range p.Int64Str {
		delete(p.Int64Str, k)
	}
	for k := range p.Uint32Str {
		delete(p.Uint32Str, k)
	}
	for k := range p.Uint64Str {
		delete(p.Uint64Str, k)
	}
	for k := range p.Sint32Str {
		delete(p.Sint32Str, k)
	}
	for k := range p.Sint64Str {
		delete(p.Sint64Str, k)
	}
	for k := range p.Fixed32Str {
		delete(p.Fixed32Str, k)
	}
	for k := range p.Fixed64Str {
		delete(p.Fixed64Str, k)
	}
	for k := range p.Sfixed32Str {
		delete(p.Sfixed32Str, k)
	}
	for k := range p.Sfixed64Str {
		delete(p.Sfixed64Str, k)
	}
	for k := range p.BoolStr {
		delete(p.BoolStr, k)
	}
	for k := range p.StrMessage {
		delete(p.StrMessage, k)
	}
	for k := range p.Int32Message {
		delete(p.Int32Message, k)
	}
	for k := range p.Int64Message {
		delete(p.Int64Message, k)
	}
	for k := range p.StrEnum {
		delete(p.StrEnum, k)
	}
	for k := range p.Int32Enum {
		delete(p.Int32Enum, k)
	}
	for k := range p.Nested {
		delete(p.Nested, k)
	}
}

type OptionalShowcasePlain struct {
	OptDouble     float64  `json:"optDouble,omitempty"`
	OptFloat      float32  `json:"optFloat,omitempty"`
	OptInt32      int32    `json:"optInt32,omitempty"`
	OptInt64      int64    `json:"optInt64,omitempty"`
	OptUint32     uint32   `json:"optUint32,omitempty"`
	OptUint64     uint64   `json:"optUint64,omitempty"`
	OptSint32     int32    `json:"optSint32,omitempty"`
	OptSint64     int64    `json:"optSint64,omitempty"`
	OptFixed32    uint32   `json:"optFixed32,omitempty"`
	OptFixed64    uint64   `json:"optFixed64,omitempty"`
	OptSfixed32   int32    `json:"optSfixed32,omitempty"`
	OptSfixed64   int64    `json:"optSfixed64,omitempty"`
	OptBool       bool     `json:"optBool,omitempty"`
	OptString     string   `json:"optString,omitempty"`
	OptBytes      []byte   `json:"optBytes,omitempty"`
	OptStatus     Status   `json:"optStatus,omitempty"`
	OptPriority   Priority `json:"optPriority,omitempty"`
	RegularDouble float64  `json:"regularDouble"`
	RegularString string   `json:"regularString"`
	RegularBool   bool     `json:"regularBool"`
	// Src_ contains indices of populated fields for sparse serialization
	Src_ []uint16 `json:"_src,omitempty"`
}

// IntoPlain converts protobuf message to plain struct
func (pb *OptionalShowcase) IntoPlain() *OptionalShowcasePlain {
	if pb == nil {
		return nil
	}
	p := &OptionalShowcasePlain{}

	if pb.OptDouble != nil {
		p.OptDouble = *pb.OptDouble
		p.Src_ = append(p.Src_, 0)
	}
	if pb.OptFloat != nil {
		p.OptFloat = *pb.OptFloat
		p.Src_ = append(p.Src_, 1)
	}
	if pb.OptInt32 != nil {
		p.OptInt32 = *pb.OptInt32
		p.Src_ = append(p.Src_, 2)
	}
	if pb.OptInt64 != nil {
		p.OptInt64 = *pb.OptInt64
		p.Src_ = append(p.Src_, 3)
	}
	if pb.OptUint32 != nil {
		p.OptUint32 = *pb.OptUint32
		p.Src_ = append(p.Src_, 4)
	}
	if pb.OptUint64 != nil {
		p.OptUint64 = *pb.OptUint64
		p.Src_ = append(p.Src_, 5)
	}
	if pb.OptSint32 != nil {
		p.OptSint32 = *pb.OptSint32
		p.Src_ = append(p.Src_, 6)
	}
	if pb.OptSint64 != nil {
		p.OptSint64 = *pb.OptSint64
		p.Src_ = append(p.Src_, 7)
	}
	if pb.OptFixed32 != nil {
		p.OptFixed32 = *pb.OptFixed32
		p.Src_ = append(p.Src_, 8)
	}
	if pb.OptFixed64 != nil {
		p.OptFixed64 = *pb.OptFixed64
		p.Src_ = append(p.Src_, 9)
	}
	if pb.OptSfixed32 != nil {
		p.OptSfixed32 = *pb.OptSfixed32
		p.Src_ = append(p.Src_, 10)
	}
	if pb.OptSfixed64 != nil {
		p.OptSfixed64 = *pb.OptSfixed64
		p.Src_ = append(p.Src_, 11)
	}
	if pb.OptBool != nil {
		p.OptBool = *pb.OptBool
		p.Src_ = append(p.Src_, 12)
	}
	if pb.OptString != nil {
		p.OptString = *pb.OptString
		p.Src_ = append(p.Src_, 13)
	}
	p.OptBytes = pb.OptBytes
	p.Src_ = append(p.Src_, 14)
	if pb.OptStatus != nil {
		p.OptStatus = *pb.OptStatus
		p.Src_ = append(p.Src_, 15)
	}
	if pb.OptPriority != nil {
		p.OptPriority = *pb.OptPriority
		p.Src_ = append(p.Src_, 16)
	}
	p.RegularDouble = pb.RegularDouble
	p.Src_ = append(p.Src_, 17)
	p.RegularString = pb.RegularString
	p.Src_ = append(p.Src_, 18)
	p.RegularBool = pb.RegularBool
	p.Src_ = append(p.Src_, 19)
	return p
}

// IntoPb converts plain struct to protobuf message
func (p *OptionalShowcasePlain) IntoPb() *OptionalShowcase {
	if p == nil {
		return nil
	}
	pb := &OptionalShowcase{}

	pb.OptDouble = &p.OptDouble
	pb.OptFloat = &p.OptFloat
	pb.OptInt32 = &p.OptInt32
	pb.OptInt64 = &p.OptInt64
	pb.OptUint32 = &p.OptUint32
	pb.OptUint64 = &p.OptUint64
	pb.OptSint32 = &p.OptSint32
	pb.OptSint64 = &p.OptSint64
	pb.OptFixed32 = &p.OptFixed32
	pb.OptFixed64 = &p.OptFixed64
	pb.OptSfixed32 = &p.OptSfixed32
	pb.OptSfixed64 = &p.OptSfixed64
	pb.OptBool = &p.OptBool
	if p.OptString != "" {
		pb.OptString = &p.OptString
	}
	pb.OptBytes = p.OptBytes
	pb.OptStatus = &p.OptStatus
	pb.OptPriority = &p.OptPriority
	pb.RegularDouble = p.RegularDouble
	pb.RegularString = p.RegularString
	pb.RegularBool = p.RegularBool
	return pb
}

// IntoPlainReuse converts protobuf message to existing plain struct (for pool usage)
func (pb *OptionalShowcase) IntoPlainReuse(p *OptionalShowcasePlain) {
	if pb == nil || p == nil {
		return
	}
	// Reset before filling
	p.Reset()

	if pb.OptDouble != nil {
		p.OptDouble = *pb.OptDouble
		p.Src_ = append(p.Src_, 0)
	}
	if pb.OptFloat != nil {
		p.OptFloat = *pb.OptFloat
		p.Src_ = append(p.Src_, 1)
	}
	if pb.OptInt32 != nil {
		p.OptInt32 = *pb.OptInt32
		p.Src_ = append(p.Src_, 2)
	}
	if pb.OptInt64 != nil {
		p.OptInt64 = *pb.OptInt64
		p.Src_ = append(p.Src_, 3)
	}
	if pb.OptUint32 != nil {
		p.OptUint32 = *pb.OptUint32
		p.Src_ = append(p.Src_, 4)
	}
	if pb.OptUint64 != nil {
		p.OptUint64 = *pb.OptUint64
		p.Src_ = append(p.Src_, 5)
	}
	if pb.OptSint32 != nil {
		p.OptSint32 = *pb.OptSint32
		p.Src_ = append(p.Src_, 6)
	}
	if pb.OptSint64 != nil {
		p.OptSint64 = *pb.OptSint64
		p.Src_ = append(p.Src_, 7)
	}
	if pb.OptFixed32 != nil {
		p.OptFixed32 = *pb.OptFixed32
		p.Src_ = append(p.Src_, 8)
	}
	if pb.OptFixed64 != nil {
		p.OptFixed64 = *pb.OptFixed64
		p.Src_ = append(p.Src_, 9)
	}
	if pb.OptSfixed32 != nil {
		p.OptSfixed32 = *pb.OptSfixed32
		p.Src_ = append(p.Src_, 10)
	}
	if pb.OptSfixed64 != nil {
		p.OptSfixed64 = *pb.OptSfixed64
		p.Src_ = append(p.Src_, 11)
	}
	if pb.OptBool != nil {
		p.OptBool = *pb.OptBool
		p.Src_ = append(p.Src_, 12)
	}
	if pb.OptString != nil {
		p.OptString = *pb.OptString
		p.Src_ = append(p.Src_, 13)
	}
	p.OptBytes = pb.OptBytes
	p.Src_ = append(p.Src_, 14)
	if pb.OptStatus != nil {
		p.OptStatus = *pb.OptStatus
		p.Src_ = append(p.Src_, 15)
	}
	if pb.OptPriority != nil {
		p.OptPriority = *pb.OptPriority
		p.Src_ = append(p.Src_, 16)
	}
	p.RegularDouble = pb.RegularDouble
	p.Src_ = append(p.Src_, 17)
	p.RegularString = pb.RegularString
	p.Src_ = append(p.Src_, 18)
	p.RegularBool = pb.RegularBool
	p.Src_ = append(p.Src_, 19)
}

// MarshalJX encodes OptionalShowcasePlain to JSON using jx.Encoder
func (p *OptionalShowcasePlain) MarshalJX(e *jx.Encoder) {
	if p == nil {
		e.Null()
		return
	}

	e.ObjStart()

	if p.OptDouble != 0 {
		e.FieldStart("optDouble")
		e.Float64(p.OptDouble)
	}
	if p.OptFloat != 0 {
		e.FieldStart("optFloat")
		e.Float32(p.OptFloat)
	}
	if p.OptInt32 != 0 {
		e.FieldStart("optInt32")
		e.Int32(p.OptInt32)
	}
	if p.OptInt64 != 0 {
		e.FieldStart("optInt64")
		e.Int64(p.OptInt64)
	}
	if p.OptUint32 != 0 {
		e.FieldStart("optUint32")
		e.UInt32(p.OptUint32)
	}
	if p.OptUint64 != 0 {
		e.FieldStart("optUint64")
		e.UInt64(p.OptUint64)
	}
	if p.OptSint32 != 0 {
		e.FieldStart("optSint32")
		e.Int32(p.OptSint32)
	}
	if p.OptSint64 != 0 {
		e.FieldStart("optSint64")
		e.Int64(p.OptSint64)
	}
	if p.OptFixed32 != 0 {
		e.FieldStart("optFixed32")
		e.UInt32(p.OptFixed32)
	}
	if p.OptFixed64 != 0 {
		e.FieldStart("optFixed64")
		e.UInt64(p.OptFixed64)
	}
	if p.OptSfixed32 != 0 {
		e.FieldStart("optSfixed32")
		e.Int32(p.OptSfixed32)
	}
	if p.OptSfixed64 != 0 {
		e.FieldStart("optSfixed64")
		e.Int64(p.OptSfixed64)
	}
	if p.OptBool {
		e.FieldStart("optBool")
		e.Bool(p.OptBool)
	}
	if p.OptString != "" {
		e.FieldStart("optString")
		e.Str(p.OptString)
	}
	if len(p.OptBytes) > 0 {
		e.FieldStart("optBytes")
		e.Base64(p.OptBytes)
	}
	e.FieldStart("optStatus")
	e.Int32(int32(p.OptStatus))
	e.FieldStart("optPriority")
	e.Int32(int32(p.OptPriority))
	if p.RegularDouble != 0 {
		e.FieldStart("regularDouble")
		e.Float64(p.RegularDouble)
	}
	if p.RegularString != "" {
		e.FieldStart("regularString")
		e.Str(p.RegularString)
	}
	if p.RegularBool {
		e.FieldStart("regularBool")
		e.Bool(p.RegularBool)
	}
	e.ObjEnd()
}

// MarshalJSON implements json.Marshaler using jx
func (p *OptionalShowcasePlain) MarshalJSON() ([]byte, error) {
	e := jx.GetEncoder()
	defer jx.PutEncoder(e)
	p.MarshalJX(e)
	return e.Bytes(), nil
}

// UnmarshalJX decodes OptionalShowcasePlain from JSON using jx.Decoder
// Populates Src_ with indices of decoded fields
func (p *OptionalShowcasePlain) UnmarshalJX(d *jx.Decoder) error {
	if p == nil {
		return nil
	}

	return d.Obj(func(d *jx.Decoder, key string) error {
		switch key {
		case "_src":
			return d.Arr(func(d *jx.Decoder) error {
				v, err := d.UInt16()
				if err != nil {
					return err
				}
				p.Src_ = append(p.Src_, v)
				return nil
			})
		case "optDouble":
			v, err := d.Float64()
			if err != nil {
				return err
			}
			p.OptDouble = v
			p.Src_ = append(p.Src_, 0)
		case "optFloat":
			v, err := d.Float32()
			if err != nil {
				return err
			}
			p.OptFloat = v
			p.Src_ = append(p.Src_, 1)
		case "optInt32":
			v, err := d.Int32()
			if err != nil {
				return err
			}
			p.OptInt32 = v
			p.Src_ = append(p.Src_, 2)
		case "optInt64":
			v, err := d.Int64()
			if err != nil {
				return err
			}
			p.OptInt64 = v
			p.Src_ = append(p.Src_, 3)
		case "optUint32":
			v, err := d.UInt32()
			if err != nil {
				return err
			}
			p.OptUint32 = v
			p.Src_ = append(p.Src_, 4)
		case "optUint64":
			v, err := d.UInt64()
			if err != nil {
				return err
			}
			p.OptUint64 = v
			p.Src_ = append(p.Src_, 5)
		case "optSint32":
			v, err := d.Int32()
			if err != nil {
				return err
			}
			p.OptSint32 = v
			p.Src_ = append(p.Src_, 6)
		case "optSint64":
			v, err := d.Int64()
			if err != nil {
				return err
			}
			p.OptSint64 = v
			p.Src_ = append(p.Src_, 7)
		case "optFixed32":
			v, err := d.UInt32()
			if err != nil {
				return err
			}
			p.OptFixed32 = v
			p.Src_ = append(p.Src_, 8)
		case "optFixed64":
			v, err := d.UInt64()
			if err != nil {
				return err
			}
			p.OptFixed64 = v
			p.Src_ = append(p.Src_, 9)
		case "optSfixed32":
			v, err := d.Int32()
			if err != nil {
				return err
			}
			p.OptSfixed32 = v
			p.Src_ = append(p.Src_, 10)
		case "optSfixed64":
			v, err := d.Int64()
			if err != nil {
				return err
			}
			p.OptSfixed64 = v
			p.Src_ = append(p.Src_, 11)
		case "optBool":
			v, err := d.Bool()
			if err != nil {
				return err
			}
			p.OptBool = v
			p.Src_ = append(p.Src_, 12)
		case "optString":
			v, err := d.Str()
			if err != nil {
				return err
			}
			p.OptString = v
			p.Src_ = append(p.Src_, 13)
		case "optBytes":
			v, err := d.Base64()
			if err != nil {
				return err
			}
			p.OptBytes = v
			p.Src_ = append(p.Src_, 14)
		case "optStatus":
			v, err := d.Int32()
			if err != nil {
				return err
			}
			p.OptStatus = Status(v)
			p.Src_ = append(p.Src_, 15)
		case "optPriority":
			v, err := d.Int32()
			if err != nil {
				return err
			}
			p.OptPriority = Priority(v)
			p.Src_ = append(p.Src_, 16)
		case "regularDouble":
			v, err := d.Float64()
			if err != nil {
				return err
			}
			p.RegularDouble = v
			p.Src_ = append(p.Src_, 17)
		case "regularString":
			v, err := d.Str()
			if err != nil {
				return err
			}
			p.RegularString = v
			p.Src_ = append(p.Src_, 18)
		case "regularBool":
			v, err := d.Bool()
			if err != nil {
				return err
			}
			p.RegularBool = v
			p.Src_ = append(p.Src_, 19)
		default:
			return d.Skip()
		}
		return nil
	})
}

// UnmarshalJSON implements json.Unmarshaler using jx
func (p *OptionalShowcasePlain) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return p.UnmarshalJX(d)
}

// optionalShowcasePlainPool is a sync.Pool for OptionalShowcasePlain objects
var optionalShowcasePlainPool = sync.Pool{
	New: func() interface{} {
		return &OptionalShowcasePlain{
			Src_: make([]uint16, 0, 32),
		}
	},
}

// GetOptionalShowcasePlain returns a OptionalShowcasePlain from the pool
func GetOptionalShowcasePlain() *OptionalShowcasePlain {
	return optionalShowcasePlainPool.Get().(*OptionalShowcasePlain)
}

// PutOptionalShowcasePlain returns a OptionalShowcasePlain to the pool after resetting it
func PutOptionalShowcasePlain(p *OptionalShowcasePlain) {
	if p == nil {
		return
	}
	p.Reset()
	optionalShowcasePlainPool.Put(p)
}

// Reset clears all fields in OptionalShowcasePlain for reuse
func (p *OptionalShowcasePlain) Reset() {
	if p == nil {
		return
	}

	p.Src_ = p.Src_[:0]

	p.OptDouble = 0
	p.OptFloat = 0
	p.OptInt32 = 0
	p.OptInt64 = 0
	p.OptUint32 = 0
	p.OptUint64 = 0
	p.OptSint32 = 0
	p.OptSint64 = 0
	p.OptFixed32 = 0
	p.OptFixed64 = 0
	p.OptSfixed32 = 0
	p.OptSfixed64 = 0
	p.OptBool = false
	p.OptString = ""
	p.OptBytes = nil
	p.OptStatus = 0
	p.OptPriority = 0
	p.RegularDouble = 0
	p.RegularString = ""
	p.RegularBool = false
}

type OneofShowcasePlain struct {
	Id                string        `json:"id"`
	ContentTextText   *TextContent  `json:"contentTextText"`   // origin: oneof_embed, empath: content_text.text
	ContentImageImage *ImageContent `json:"contentImageImage"` // origin: oneof_embed, empath: content_image.image
	ContentCodeCode   *CodeContent  `json:"contentCodeCode"`   // origin: oneof_embed, empath: content_code.code
	// ContentCase indicates which variant of content oneof is set
	ContentCase string `json:"content_case,omitempty"`
	// Src_ contains indices of populated fields for sparse serialization
	Src_ []uint16 `json:"_src,omitempty"`
}

// IntoPlain converts protobuf message to plain struct
func (pb *OneofShowcase) IntoPlain() *OneofShowcasePlain {
	if pb == nil {
		return nil
	}
	p := &OneofShowcasePlain{}

	// Detect content oneof case
	switch pb.Content.(type) {
	case *OneofShowcase_Text:
		p.ContentCase = "text"
	case *OneofShowcase_Image:
		p.ContentCase = "image"
	case *OneofShowcase_Code:
		p.ContentCase = "code"
	}

	p.Id = pb.Id
	p.Src_ = append(p.Src_, 0)
	// ContentTextText from content_text.text
	if pb.GetText() != nil {
		p.ContentTextText = pb.GetText()
		p.Src_ = append(p.Src_, 1)
	}
	// ContentImageImage from content_image.image
	if pb.GetImage() != nil {
		p.ContentImageImage = pb.GetImage()
		p.Src_ = append(p.Src_, 2)
	}
	// ContentCodeCode from content_code.code
	if pb.GetCode() != nil {
		p.ContentCodeCode = pb.GetCode()
		p.Src_ = append(p.Src_, 3)
	}
	return p
}

// IntoPb converts plain struct to protobuf message
func (p *OneofShowcasePlain) IntoPb() *OneofShowcase {
	if p == nil {
		return nil
	}
	pb := &OneofShowcase{}

	pb.Id = p.Id
	// ContentTextText -> content_text.text
	if p.ContentTextText != nil && p.ContentCase == "text" {
		pb.Content = &OneofShowcase_Text{Text: p.ContentTextText}
	}
	// ContentImageImage -> content_image.image
	if p.ContentImageImage != nil && p.ContentCase == "image" {
		pb.Content = &OneofShowcase_Image{Image: p.ContentImageImage}
	}
	// ContentCodeCode -> content_code.code
	if p.ContentCodeCode != nil && p.ContentCase == "code" {
		pb.Content = &OneofShowcase_Code{Code: p.ContentCodeCode}
	}
	return pb
}

// IntoPlainReuse converts protobuf message to existing plain struct (for pool usage)
func (pb *OneofShowcase) IntoPlainReuse(p *OneofShowcasePlain) {
	if pb == nil || p == nil {
		return
	}
	// Reset before filling
	p.Reset()

	// Detect content oneof case
	switch pb.Content.(type) {
	case *OneofShowcase_Text:
		p.ContentCase = "text"
	case *OneofShowcase_Image:
		p.ContentCase = "image"
	case *OneofShowcase_Code:
		p.ContentCase = "code"
	}

	p.Id = pb.Id
	p.Src_ = append(p.Src_, 0)
	// ContentTextText from content_text.text
	if pb.GetText() != nil {
		p.ContentTextText = pb.GetText()
		p.Src_ = append(p.Src_, 1)
	}
	// ContentImageImage from content_image.image
	if pb.GetImage() != nil {
		p.ContentImageImage = pb.GetImage()
		p.Src_ = append(p.Src_, 2)
	}
	// ContentCodeCode from content_code.code
	if pb.GetCode() != nil {
		p.ContentCodeCode = pb.GetCode()
		p.Src_ = append(p.Src_, 3)
	}
}

// MarshalJX encodes OneofShowcasePlain to JSON using jx.Encoder
func (p *OneofShowcasePlain) MarshalJX(e *jx.Encoder) {
	if p == nil {
		e.Null()
		return
	}

	e.ObjStart()

	if p.ContentCase != "" {
		e.FieldStart("content_case")
		e.Str(p.ContentCase)
	}
	if p.Id != "" {
		e.FieldStart("id")
		e.Str(p.Id)
	}
	if p.ContentTextText != nil {
		e.FieldStart("contentTextText")
		if data, err := protojson.Marshal(p.ContentTextText); err == nil {
			e.Raw(data)
		} else {
			e.Null()
		}
	}
	if p.ContentImageImage != nil {
		e.FieldStart("contentImageImage")
		if data, err := protojson.Marshal(p.ContentImageImage); err == nil {
			e.Raw(data)
		} else {
			e.Null()
		}
	}
	if p.ContentCodeCode != nil {
		e.FieldStart("contentCodeCode")
		if data, err := protojson.Marshal(p.ContentCodeCode); err == nil {
			e.Raw(data)
		} else {
			e.Null()
		}
	}
	e.ObjEnd()
}

// MarshalJSON implements json.Marshaler using jx
func (p *OneofShowcasePlain) MarshalJSON() ([]byte, error) {
	e := jx.GetEncoder()
	defer jx.PutEncoder(e)
	p.MarshalJX(e)
	return e.Bytes(), nil
}

// UnmarshalJX decodes OneofShowcasePlain from JSON using jx.Decoder
// Populates Src_ with indices of decoded fields
func (p *OneofShowcasePlain) UnmarshalJX(d *jx.Decoder) error {
	if p == nil {
		return nil
	}

	return d.Obj(func(d *jx.Decoder, key string) error {
		switch key {
		case "_src":
			return d.Arr(func(d *jx.Decoder) error {
				v, err := d.UInt16()
				if err != nil {
					return err
				}
				p.Src_ = append(p.Src_, v)
				return nil
			})
		case "content_case":
			v, err := d.Str()
			if err != nil {
				return err
			}
			p.ContentCase = v
		case "id":
			v, err := d.Str()
			if err != nil {
				return err
			}
			p.Id = v
			p.Src_ = append(p.Src_, 0)
		case "contentTextText":
			raw, err := d.Raw()
			if err != nil {
				return err
			}
			p.ContentTextText = &TextContent{}
			if err := protojson.Unmarshal(raw, p.ContentTextText); err != nil {
				return err
			}
			p.Src_ = append(p.Src_, 1)
		case "contentImageImage":
			raw, err := d.Raw()
			if err != nil {
				return err
			}
			p.ContentImageImage = &ImageContent{}
			if err := protojson.Unmarshal(raw, p.ContentImageImage); err != nil {
				return err
			}
			p.Src_ = append(p.Src_, 2)
		case "contentCodeCode":
			raw, err := d.Raw()
			if err != nil {
				return err
			}
			p.ContentCodeCode = &CodeContent{}
			if err := protojson.Unmarshal(raw, p.ContentCodeCode); err != nil {
				return err
			}
			p.Src_ = append(p.Src_, 3)
		default:
			return d.Skip()
		}
		return nil
	})
}

// UnmarshalJSON implements json.Unmarshaler using jx
func (p *OneofShowcasePlain) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return p.UnmarshalJX(d)
}

// oneofShowcasePlainPool is a sync.Pool for OneofShowcasePlain objects
var oneofShowcasePlainPool = sync.Pool{
	New: func() interface{} {
		return &OneofShowcasePlain{
			Src_: make([]uint16, 0, 32),
		}
	},
}

// GetOneofShowcasePlain returns a OneofShowcasePlain from the pool
func GetOneofShowcasePlain() *OneofShowcasePlain {
	return oneofShowcasePlainPool.Get().(*OneofShowcasePlain)
}

// PutOneofShowcasePlain returns a OneofShowcasePlain to the pool after resetting it
func PutOneofShowcasePlain(p *OneofShowcasePlain) {
	if p == nil {
		return
	}
	p.Reset()
	oneofShowcasePlainPool.Put(p)
}

// Reset clears all fields in OneofShowcasePlain for reuse
func (p *OneofShowcasePlain) Reset() {
	if p == nil {
		return
	}

	p.Src_ = p.Src_[:0]

	p.ContentCase = ""
	p.Id = ""
	p.ContentTextText = nil
	p.ContentImageImage = nil
	p.ContentCodeCode = nil
}

// This demonstrates oneof with embed=true where variants also have embed=true
//
//	Result: all fields from Heartbeat/ProcessStarted/ProcessExited/NetworkEvent
//	are flattened directly into PlatformEventPlain
type PlatformEventPlain struct {
	EventId                                string            `json:"eventId"`
	EventTime                              int64             `json:"eventTime"`
	Source                                 string            `json:"source"`
	Labels                                 map[string]string `json:"labels"`
	PlatformEventHeartbeatTimestamp        int64             `json:"platformEventHeartbeatTimestamp"`        // origin: oneof_embed, empath: platform_event_heartbeat.timestamp
	PlatformEventHeartbeatNodeId           string            `json:"platformEventHeartbeatNodeId"`           // origin: oneof_embed, empath: platform_event_heartbeat.node_id
	PlatformEventHeartbeatCpuPercent       int32             `json:"platformEventHeartbeatCpuPercent"`       // origin: oneof_embed, empath: platform_event_heartbeat.cpu_percent
	PlatformEventHeartbeatMemoryBytes      int64             `json:"platformEventHeartbeatMemoryBytes"`      // origin: oneof_embed, empath: platform_event_heartbeat.memory_bytes
	PlatformEventProcessStartedProcessId   string            `json:"platformEventProcessStartedProcessId"`   // origin: oneof_embed, empath: platform_event_process_started.process_id
	PlatformEventProcessStartedCommand     string            `json:"platformEventProcessStartedCommand"`     // origin: oneof_embed, empath: platform_event_process_started.command
	PlatformEventProcessStartedArgs        []string          `json:"platformEventProcessStartedArgs"`        // origin: oneof_embed, empath: platform_event_process_started.args
	PlatformEventProcessStartedStartTime   int64             `json:"platformEventProcessStartedStartTime"`   // origin: oneof_embed, empath: platform_event_process_started.start_time
	PlatformEventProcessExitedProcessId    string            `json:"platformEventProcessExitedProcessId"`    // origin: oneof_embed, empath: platform_event_process_exited.process_id
	PlatformEventProcessExitedExitCode     int32             `json:"platformEventProcessExitedExitCode"`     // origin: oneof_embed, empath: platform_event_process_exited.exit_code
	PlatformEventProcessExitedExitTime     int64             `json:"platformEventProcessExitedExitTime"`     // origin: oneof_embed, empath: platform_event_process_exited.exit_time
	PlatformEventProcessExitedSignal       string            `json:"platformEventProcessExitedSignal"`       // origin: oneof_embed, empath: platform_event_process_exited.signal
	PlatformEventNetworkEventInterfaceName string            `json:"platformEventNetworkEventInterfaceName"` // origin: oneof_embed, empath: platform_event_network_event.interface_name
	PlatformEventNetworkEventRemoteAddr    string            `json:"platformEventNetworkEventRemoteAddr"`    // origin: oneof_embed, empath: platform_event_network_event.remote_addr
	PlatformEventNetworkEventRemotePort    int32             `json:"platformEventNetworkEventRemotePort"`    // origin: oneof_embed, empath: platform_event_network_event.remote_port
	PlatformEventNetworkEventProtocol      string            `json:"platformEventNetworkEventProtocol"`      // origin: oneof_embed, empath: platform_event_network_event.protocol
	PlatformEventNetworkEventBytesSent     int64             `json:"platformEventNetworkEventBytesSent"`     // origin: oneof_embed, empath: platform_event_network_event.bytes_sent
	PlatformEventNetworkEventBytesReceived int64             `json:"platformEventNetworkEventBytesReceived"` // origin: oneof_embed, empath: platform_event_network_event.bytes_received
	// PlatformEventCase indicates which variant of platform_event oneof is set
	PlatformEventCase string `json:"platform_event_case,omitempty"`
	// Src_ contains indices of populated fields for sparse serialization
	Src_ []uint16 `json:"_src,omitempty"`
}

// IntoPlain converts protobuf message to plain struct
func (pb *PlatformEvent) IntoPlain() *PlatformEventPlain {
	if pb == nil {
		return nil
	}
	p := &PlatformEventPlain{}

	// Detect platform_event oneof case
	switch pb.PlatformEvent.(type) {
	case *PlatformEvent_Heartbeat:
		p.PlatformEventCase = "heartbeat"
	case *PlatformEvent_ProcessStarted:
		p.PlatformEventCase = "process_started"
	case *PlatformEvent_ProcessExited:
		p.PlatformEventCase = "process_exited"
	case *PlatformEvent_NetworkEvent:
		p.PlatformEventCase = "network_event"
	}

	p.EventId = pb.EventId
	p.Src_ = append(p.Src_, 0)
	p.EventTime = pb.EventTime
	p.Src_ = append(p.Src_, 1)
	p.Source = pb.Source
	p.Src_ = append(p.Src_, 2)
	p.Labels = pb.Labels
	p.Src_ = append(p.Src_, 3)
	// PlatformEventHeartbeatTimestamp from platform_event_heartbeat.timestamp
	if pb.GetHeartbeat() != nil {
		p.PlatformEventHeartbeatTimestamp = pb.GetHeartbeat().GetTimestamp()
		p.Src_ = append(p.Src_, 4)
	}
	// PlatformEventHeartbeatNodeId from platform_event_heartbeat.node_id
	if pb.GetHeartbeat() != nil {
		p.PlatformEventHeartbeatNodeId = pb.GetHeartbeat().GetNodeId()
		p.Src_ = append(p.Src_, 5)
	}
	// PlatformEventHeartbeatCpuPercent from platform_event_heartbeat.cpu_percent
	if pb.GetHeartbeat() != nil {
		p.PlatformEventHeartbeatCpuPercent = pb.GetHeartbeat().GetCpuPercent()
		p.Src_ = append(p.Src_, 6)
	}
	// PlatformEventHeartbeatMemoryBytes from platform_event_heartbeat.memory_bytes
	if pb.GetHeartbeat() != nil {
		p.PlatformEventHeartbeatMemoryBytes = pb.GetHeartbeat().GetMemoryBytes()
		p.Src_ = append(p.Src_, 7)
	}
	// PlatformEventProcessStartedProcessId from platform_event_process_started.process_id
	if pb.GetProcessStarted() != nil {
		p.PlatformEventProcessStartedProcessId = pb.GetProcessStarted().GetProcessId()
		p.Src_ = append(p.Src_, 8)
	}
	// PlatformEventProcessStartedCommand from platform_event_process_started.command
	if pb.GetProcessStarted() != nil {
		p.PlatformEventProcessStartedCommand = pb.GetProcessStarted().GetCommand()
		p.Src_ = append(p.Src_, 9)
	}
	// PlatformEventProcessStartedArgs from platform_event_process_started.args
	if pb.GetProcessStarted() != nil {
		p.PlatformEventProcessStartedArgs = pb.GetProcessStarted().GetArgs()
		p.Src_ = append(p.Src_, 10)
	}
	// PlatformEventProcessStartedStartTime from platform_event_process_started.start_time
	if pb.GetProcessStarted() != nil {
		p.PlatformEventProcessStartedStartTime = pb.GetProcessStarted().GetStartTime()
		p.Src_ = append(p.Src_, 11)
	}
	// PlatformEventProcessExitedProcessId from platform_event_process_exited.process_id
	if pb.GetProcessExited() != nil {
		p.PlatformEventProcessExitedProcessId = pb.GetProcessExited().GetProcessId()
		p.Src_ = append(p.Src_, 12)
	}
	// PlatformEventProcessExitedExitCode from platform_event_process_exited.exit_code
	if pb.GetProcessExited() != nil {
		p.PlatformEventProcessExitedExitCode = pb.GetProcessExited().GetExitCode()
		p.Src_ = append(p.Src_, 13)
	}
	// PlatformEventProcessExitedExitTime from platform_event_process_exited.exit_time
	if pb.GetProcessExited() != nil {
		p.PlatformEventProcessExitedExitTime = pb.GetProcessExited().GetExitTime()
		p.Src_ = append(p.Src_, 14)
	}
	// PlatformEventProcessExitedSignal from platform_event_process_exited.signal
	if pb.GetProcessExited() != nil {
		p.PlatformEventProcessExitedSignal = pb.GetProcessExited().GetSignal()
		p.Src_ = append(p.Src_, 15)
	}
	// PlatformEventNetworkEventInterfaceName from platform_event_network_event.interface_name
	if pb.GetNetworkEvent() != nil {
		p.PlatformEventNetworkEventInterfaceName = pb.GetNetworkEvent().GetInterfaceName()
		p.Src_ = append(p.Src_, 16)
	}
	// PlatformEventNetworkEventRemoteAddr from platform_event_network_event.remote_addr
	if pb.GetNetworkEvent() != nil {
		p.PlatformEventNetworkEventRemoteAddr = pb.GetNetworkEvent().GetRemoteAddr()
		p.Src_ = append(p.Src_, 17)
	}
	// PlatformEventNetworkEventRemotePort from platform_event_network_event.remote_port
	if pb.GetNetworkEvent() != nil {
		p.PlatformEventNetworkEventRemotePort = pb.GetNetworkEvent().GetRemotePort()
		p.Src_ = append(p.Src_, 18)
	}
	// PlatformEventNetworkEventProtocol from platform_event_network_event.protocol
	if pb.GetNetworkEvent() != nil {
		p.PlatformEventNetworkEventProtocol = pb.GetNetworkEvent().GetProtocol()
		p.Src_ = append(p.Src_, 19)
	}
	// PlatformEventNetworkEventBytesSent from platform_event_network_event.bytes_sent
	if pb.GetNetworkEvent() != nil {
		p.PlatformEventNetworkEventBytesSent = pb.GetNetworkEvent().GetBytesSent()
		p.Src_ = append(p.Src_, 20)
	}
	// PlatformEventNetworkEventBytesReceived from platform_event_network_event.bytes_received
	if pb.GetNetworkEvent() != nil {
		p.PlatformEventNetworkEventBytesReceived = pb.GetNetworkEvent().GetBytesReceived()
		p.Src_ = append(p.Src_, 21)
	}
	return p
}

// IntoPb converts plain struct to protobuf message
func (p *PlatformEventPlain) IntoPb() *PlatformEvent {
	if p == nil {
		return nil
	}
	pb := &PlatformEvent{}

	pb.EventId = p.EventId
	pb.EventTime = p.EventTime
	pb.Source = p.Source
	pb.Labels = p.Labels
	// PlatformEventHeartbeatTimestamp -> platform_event_heartbeat.timestamp
	if p.PlatformEventCase == "heartbeat" {
		if _, ok := pb.PlatformEvent.(*PlatformEvent_Heartbeat); !ok || pb.PlatformEvent == nil {
			pb.PlatformEvent = &PlatformEvent_Heartbeat{Heartbeat: &Heartbeat{}}
		}
		pb.PlatformEvent.(*PlatformEvent_Heartbeat).Heartbeat.Timestamp = p.PlatformEventHeartbeatTimestamp
	}
	// PlatformEventHeartbeatNodeId -> platform_event_heartbeat.node_id
	if p.PlatformEventCase == "heartbeat" {
		if _, ok := pb.PlatformEvent.(*PlatformEvent_Heartbeat); !ok || pb.PlatformEvent == nil {
			pb.PlatformEvent = &PlatformEvent_Heartbeat{Heartbeat: &Heartbeat{}}
		}
		pb.PlatformEvent.(*PlatformEvent_Heartbeat).Heartbeat.NodeId = p.PlatformEventHeartbeatNodeId
	}
	// PlatformEventHeartbeatCpuPercent -> platform_event_heartbeat.cpu_percent
	if p.PlatformEventCase == "heartbeat" {
		if _, ok := pb.PlatformEvent.(*PlatformEvent_Heartbeat); !ok || pb.PlatformEvent == nil {
			pb.PlatformEvent = &PlatformEvent_Heartbeat{Heartbeat: &Heartbeat{}}
		}
		pb.PlatformEvent.(*PlatformEvent_Heartbeat).Heartbeat.CpuPercent = p.PlatformEventHeartbeatCpuPercent
	}
	// PlatformEventHeartbeatMemoryBytes -> platform_event_heartbeat.memory_bytes
	if p.PlatformEventCase == "heartbeat" {
		if _, ok := pb.PlatformEvent.(*PlatformEvent_Heartbeat); !ok || pb.PlatformEvent == nil {
			pb.PlatformEvent = &PlatformEvent_Heartbeat{Heartbeat: &Heartbeat{}}
		}
		pb.PlatformEvent.(*PlatformEvent_Heartbeat).Heartbeat.MemoryBytes = p.PlatformEventHeartbeatMemoryBytes
	}
	// PlatformEventProcessStartedProcessId -> platform_event_process_started.process_id
	if p.PlatformEventCase == "process_started" {
		if _, ok := pb.PlatformEvent.(*PlatformEvent_ProcessStarted); !ok || pb.PlatformEvent == nil {
			pb.PlatformEvent = &PlatformEvent_ProcessStarted{ProcessStarted: &ProcessStarted{}}
		}
		pb.PlatformEvent.(*PlatformEvent_ProcessStarted).ProcessStarted.ProcessId = p.PlatformEventProcessStartedProcessId
	}
	// PlatformEventProcessStartedCommand -> platform_event_process_started.command
	if p.PlatformEventCase == "process_started" {
		if _, ok := pb.PlatformEvent.(*PlatformEvent_ProcessStarted); !ok || pb.PlatformEvent == nil {
			pb.PlatformEvent = &PlatformEvent_ProcessStarted{ProcessStarted: &ProcessStarted{}}
		}
		pb.PlatformEvent.(*PlatformEvent_ProcessStarted).ProcessStarted.Command = p.PlatformEventProcessStartedCommand
	}
	// PlatformEventProcessStartedArgs -> platform_event_process_started.args
	if len(p.PlatformEventProcessStartedArgs) > 0 && p.PlatformEventCase == "process_started" {
		if _, ok := pb.PlatformEvent.(*PlatformEvent_ProcessStarted); !ok || pb.PlatformEvent == nil {
			pb.PlatformEvent = &PlatformEvent_ProcessStarted{ProcessStarted: &ProcessStarted{}}
		}
		pb.PlatformEvent.(*PlatformEvent_ProcessStarted).ProcessStarted.Args = p.PlatformEventProcessStartedArgs
	}
	// PlatformEventProcessStartedStartTime -> platform_event_process_started.start_time
	if p.PlatformEventCase == "process_started" {
		if _, ok := pb.PlatformEvent.(*PlatformEvent_ProcessStarted); !ok || pb.PlatformEvent == nil {
			pb.PlatformEvent = &PlatformEvent_ProcessStarted{ProcessStarted: &ProcessStarted{}}
		}
		pb.PlatformEvent.(*PlatformEvent_ProcessStarted).ProcessStarted.StartTime = p.PlatformEventProcessStartedStartTime
	}
	// PlatformEventProcessExitedProcessId -> platform_event_process_exited.process_id
	if p.PlatformEventCase == "process_exited" {
		if _, ok := pb.PlatformEvent.(*PlatformEvent_ProcessExited); !ok || pb.PlatformEvent == nil {
			pb.PlatformEvent = &PlatformEvent_ProcessExited{ProcessExited: &ProcessExited{}}
		}
		pb.PlatformEvent.(*PlatformEvent_ProcessExited).ProcessExited.ProcessId = p.PlatformEventProcessExitedProcessId
	}
	// PlatformEventProcessExitedExitCode -> platform_event_process_exited.exit_code
	if p.PlatformEventCase == "process_exited" {
		if _, ok := pb.PlatformEvent.(*PlatformEvent_ProcessExited); !ok || pb.PlatformEvent == nil {
			pb.PlatformEvent = &PlatformEvent_ProcessExited{ProcessExited: &ProcessExited{}}
		}
		pb.PlatformEvent.(*PlatformEvent_ProcessExited).ProcessExited.ExitCode = p.PlatformEventProcessExitedExitCode
	}
	// PlatformEventProcessExitedExitTime -> platform_event_process_exited.exit_time
	if p.PlatformEventCase == "process_exited" {
		if _, ok := pb.PlatformEvent.(*PlatformEvent_ProcessExited); !ok || pb.PlatformEvent == nil {
			pb.PlatformEvent = &PlatformEvent_ProcessExited{ProcessExited: &ProcessExited{}}
		}
		pb.PlatformEvent.(*PlatformEvent_ProcessExited).ProcessExited.ExitTime = p.PlatformEventProcessExitedExitTime
	}
	// PlatformEventProcessExitedSignal -> platform_event_process_exited.signal
	if p.PlatformEventCase == "process_exited" {
		if _, ok := pb.PlatformEvent.(*PlatformEvent_ProcessExited); !ok || pb.PlatformEvent == nil {
			pb.PlatformEvent = &PlatformEvent_ProcessExited{ProcessExited: &ProcessExited{}}
		}
		pb.PlatformEvent.(*PlatformEvent_ProcessExited).ProcessExited.Signal = p.PlatformEventProcessExitedSignal
	}
	// PlatformEventNetworkEventInterfaceName -> platform_event_network_event.interface_name
	if p.PlatformEventCase == "network_event" {
		if _, ok := pb.PlatformEvent.(*PlatformEvent_NetworkEvent); !ok || pb.PlatformEvent == nil {
			pb.PlatformEvent = &PlatformEvent_NetworkEvent{NetworkEvent: &NetworkEvent{}}
		}
		pb.PlatformEvent.(*PlatformEvent_NetworkEvent).NetworkEvent.InterfaceName = p.PlatformEventNetworkEventInterfaceName
	}
	// PlatformEventNetworkEventRemoteAddr -> platform_event_network_event.remote_addr
	if p.PlatformEventCase == "network_event" {
		if _, ok := pb.PlatformEvent.(*PlatformEvent_NetworkEvent); !ok || pb.PlatformEvent == nil {
			pb.PlatformEvent = &PlatformEvent_NetworkEvent{NetworkEvent: &NetworkEvent{}}
		}
		pb.PlatformEvent.(*PlatformEvent_NetworkEvent).NetworkEvent.RemoteAddr = p.PlatformEventNetworkEventRemoteAddr
	}
	// PlatformEventNetworkEventRemotePort -> platform_event_network_event.remote_port
	if p.PlatformEventCase == "network_event" {
		if _, ok := pb.PlatformEvent.(*PlatformEvent_NetworkEvent); !ok || pb.PlatformEvent == nil {
			pb.PlatformEvent = &PlatformEvent_NetworkEvent{NetworkEvent: &NetworkEvent{}}
		}
		pb.PlatformEvent.(*PlatformEvent_NetworkEvent).NetworkEvent.RemotePort = p.PlatformEventNetworkEventRemotePort
	}
	// PlatformEventNetworkEventProtocol -> platform_event_network_event.protocol
	if p.PlatformEventCase == "network_event" {
		if _, ok := pb.PlatformEvent.(*PlatformEvent_NetworkEvent); !ok || pb.PlatformEvent == nil {
			pb.PlatformEvent = &PlatformEvent_NetworkEvent{NetworkEvent: &NetworkEvent{}}
		}
		pb.PlatformEvent.(*PlatformEvent_NetworkEvent).NetworkEvent.Protocol = p.PlatformEventNetworkEventProtocol
	}
	// PlatformEventNetworkEventBytesSent -> platform_event_network_event.bytes_sent
	if p.PlatformEventCase == "network_event" {
		if _, ok := pb.PlatformEvent.(*PlatformEvent_NetworkEvent); !ok || pb.PlatformEvent == nil {
			pb.PlatformEvent = &PlatformEvent_NetworkEvent{NetworkEvent: &NetworkEvent{}}
		}
		pb.PlatformEvent.(*PlatformEvent_NetworkEvent).NetworkEvent.BytesSent = p.PlatformEventNetworkEventBytesSent
	}
	// PlatformEventNetworkEventBytesReceived -> platform_event_network_event.bytes_received
	if p.PlatformEventCase == "network_event" {
		if _, ok := pb.PlatformEvent.(*PlatformEvent_NetworkEvent); !ok || pb.PlatformEvent == nil {
			pb.PlatformEvent = &PlatformEvent_NetworkEvent{NetworkEvent: &NetworkEvent{}}
		}
		pb.PlatformEvent.(*PlatformEvent_NetworkEvent).NetworkEvent.BytesReceived = p.PlatformEventNetworkEventBytesReceived
	}
	return pb
}

// IntoPlainReuse converts protobuf message to existing plain struct (for pool usage)
func (pb *PlatformEvent) IntoPlainReuse(p *PlatformEventPlain) {
	if pb == nil || p == nil {
		return
	}
	// Reset before filling
	p.Reset()

	// Detect platform_event oneof case
	switch pb.PlatformEvent.(type) {
	case *PlatformEvent_Heartbeat:
		p.PlatformEventCase = "heartbeat"
	case *PlatformEvent_ProcessStarted:
		p.PlatformEventCase = "process_started"
	case *PlatformEvent_ProcessExited:
		p.PlatformEventCase = "process_exited"
	case *PlatformEvent_NetworkEvent:
		p.PlatformEventCase = "network_event"
	}

	p.EventId = pb.EventId
	p.Src_ = append(p.Src_, 0)
	p.EventTime = pb.EventTime
	p.Src_ = append(p.Src_, 1)
	p.Source = pb.Source
	p.Src_ = append(p.Src_, 2)
	p.Labels = pb.Labels
	p.Src_ = append(p.Src_, 3)
	// PlatformEventHeartbeatTimestamp from platform_event_heartbeat.timestamp
	if pb.GetHeartbeat() != nil {
		p.PlatformEventHeartbeatTimestamp = pb.GetHeartbeat().GetTimestamp()
		p.Src_ = append(p.Src_, 4)
	}
	// PlatformEventHeartbeatNodeId from platform_event_heartbeat.node_id
	if pb.GetHeartbeat() != nil {
		p.PlatformEventHeartbeatNodeId = pb.GetHeartbeat().GetNodeId()
		p.Src_ = append(p.Src_, 5)
	}
	// PlatformEventHeartbeatCpuPercent from platform_event_heartbeat.cpu_percent
	if pb.GetHeartbeat() != nil {
		p.PlatformEventHeartbeatCpuPercent = pb.GetHeartbeat().GetCpuPercent()
		p.Src_ = append(p.Src_, 6)
	}
	// PlatformEventHeartbeatMemoryBytes from platform_event_heartbeat.memory_bytes
	if pb.GetHeartbeat() != nil {
		p.PlatformEventHeartbeatMemoryBytes = pb.GetHeartbeat().GetMemoryBytes()
		p.Src_ = append(p.Src_, 7)
	}
	// PlatformEventProcessStartedProcessId from platform_event_process_started.process_id
	if pb.GetProcessStarted() != nil {
		p.PlatformEventProcessStartedProcessId = pb.GetProcessStarted().GetProcessId()
		p.Src_ = append(p.Src_, 8)
	}
	// PlatformEventProcessStartedCommand from platform_event_process_started.command
	if pb.GetProcessStarted() != nil {
		p.PlatformEventProcessStartedCommand = pb.GetProcessStarted().GetCommand()
		p.Src_ = append(p.Src_, 9)
	}
	// PlatformEventProcessStartedArgs from platform_event_process_started.args
	if pb.GetProcessStarted() != nil {
		p.PlatformEventProcessStartedArgs = pb.GetProcessStarted().GetArgs()
		p.Src_ = append(p.Src_, 10)
	}
	// PlatformEventProcessStartedStartTime from platform_event_process_started.start_time
	if pb.GetProcessStarted() != nil {
		p.PlatformEventProcessStartedStartTime = pb.GetProcessStarted().GetStartTime()
		p.Src_ = append(p.Src_, 11)
	}
	// PlatformEventProcessExitedProcessId from platform_event_process_exited.process_id
	if pb.GetProcessExited() != nil {
		p.PlatformEventProcessExitedProcessId = pb.GetProcessExited().GetProcessId()
		p.Src_ = append(p.Src_, 12)
	}
	// PlatformEventProcessExitedExitCode from platform_event_process_exited.exit_code
	if pb.GetProcessExited() != nil {
		p.PlatformEventProcessExitedExitCode = pb.GetProcessExited().GetExitCode()
		p.Src_ = append(p.Src_, 13)
	}
	// PlatformEventProcessExitedExitTime from platform_event_process_exited.exit_time
	if pb.GetProcessExited() != nil {
		p.PlatformEventProcessExitedExitTime = pb.GetProcessExited().GetExitTime()
		p.Src_ = append(p.Src_, 14)
	}
	// PlatformEventProcessExitedSignal from platform_event_process_exited.signal
	if pb.GetProcessExited() != nil {
		p.PlatformEventProcessExitedSignal = pb.GetProcessExited().GetSignal()
		p.Src_ = append(p.Src_, 15)
	}
	// PlatformEventNetworkEventInterfaceName from platform_event_network_event.interface_name
	if pb.GetNetworkEvent() != nil {
		p.PlatformEventNetworkEventInterfaceName = pb.GetNetworkEvent().GetInterfaceName()
		p.Src_ = append(p.Src_, 16)
	}
	// PlatformEventNetworkEventRemoteAddr from platform_event_network_event.remote_addr
	if pb.GetNetworkEvent() != nil {
		p.PlatformEventNetworkEventRemoteAddr = pb.GetNetworkEvent().GetRemoteAddr()
		p.Src_ = append(p.Src_, 17)
	}
	// PlatformEventNetworkEventRemotePort from platform_event_network_event.remote_port
	if pb.GetNetworkEvent() != nil {
		p.PlatformEventNetworkEventRemotePort = pb.GetNetworkEvent().GetRemotePort()
		p.Src_ = append(p.Src_, 18)
	}
	// PlatformEventNetworkEventProtocol from platform_event_network_event.protocol
	if pb.GetNetworkEvent() != nil {
		p.PlatformEventNetworkEventProtocol = pb.GetNetworkEvent().GetProtocol()
		p.Src_ = append(p.Src_, 19)
	}
	// PlatformEventNetworkEventBytesSent from platform_event_network_event.bytes_sent
	if pb.GetNetworkEvent() != nil {
		p.PlatformEventNetworkEventBytesSent = pb.GetNetworkEvent().GetBytesSent()
		p.Src_ = append(p.Src_, 20)
	}
	// PlatformEventNetworkEventBytesReceived from platform_event_network_event.bytes_received
	if pb.GetNetworkEvent() != nil {
		p.PlatformEventNetworkEventBytesReceived = pb.GetNetworkEvent().GetBytesReceived()
		p.Src_ = append(p.Src_, 21)
	}
}

// MarshalJX encodes PlatformEventPlain to JSON using jx.Encoder
func (p *PlatformEventPlain) MarshalJX(e *jx.Encoder) {
	if p == nil {
		e.Null()
		return
	}

	e.ObjStart()

	if p.PlatformEventCase != "" {
		e.FieldStart("platform_event_case")
		e.Str(p.PlatformEventCase)
	}
	if p.EventId != "" {
		e.FieldStart("eventId")
		e.Str(p.EventId)
	}
	if p.EventTime != 0 {
		e.FieldStart("eventTime")
		e.Int64(p.EventTime)
	}
	if p.Source != "" {
		e.FieldStart("source")
		e.Str(p.Source)
	}
	e.FieldStart("labels")
	e.ObjStart()
	for k, v := range p.Labels {
		e.FieldStart(k)
		e.Str(v)
	}
	e.ObjEnd()
	if p.PlatformEventHeartbeatTimestamp != 0 {
		e.FieldStart("platformEventHeartbeatTimestamp")
		e.Int64(p.PlatformEventHeartbeatTimestamp)
	}
	if p.PlatformEventHeartbeatNodeId != "" {
		e.FieldStart("platformEventHeartbeatNodeId")
		e.Str(p.PlatformEventHeartbeatNodeId)
	}
	if p.PlatformEventHeartbeatCpuPercent != 0 {
		e.FieldStart("platformEventHeartbeatCpuPercent")
		e.Int32(p.PlatformEventHeartbeatCpuPercent)
	}
	if p.PlatformEventHeartbeatMemoryBytes != 0 {
		e.FieldStart("platformEventHeartbeatMemoryBytes")
		e.Int64(p.PlatformEventHeartbeatMemoryBytes)
	}
	if p.PlatformEventProcessStartedProcessId != "" {
		e.FieldStart("platformEventProcessStartedProcessId")
		e.Str(p.PlatformEventProcessStartedProcessId)
	}
	if p.PlatformEventProcessStartedCommand != "" {
		e.FieldStart("platformEventProcessStartedCommand")
		e.Str(p.PlatformEventProcessStartedCommand)
	}
	if len(p.PlatformEventProcessStartedArgs) > 0 {
		e.FieldStart("platformEventProcessStartedArgs")
		e.ArrStart()
		for _, v := range p.PlatformEventProcessStartedArgs {
			e.Str(v)
		}
		e.ArrEnd()
	}
	if p.PlatformEventProcessStartedStartTime != 0 {
		e.FieldStart("platformEventProcessStartedStartTime")
		e.Int64(p.PlatformEventProcessStartedStartTime)
	}
	if p.PlatformEventProcessExitedProcessId != "" {
		e.FieldStart("platformEventProcessExitedProcessId")
		e.Str(p.PlatformEventProcessExitedProcessId)
	}
	if p.PlatformEventProcessExitedExitCode != 0 {
		e.FieldStart("platformEventProcessExitedExitCode")
		e.Int32(p.PlatformEventProcessExitedExitCode)
	}
	if p.PlatformEventProcessExitedExitTime != 0 {
		e.FieldStart("platformEventProcessExitedExitTime")
		e.Int64(p.PlatformEventProcessExitedExitTime)
	}
	if p.PlatformEventProcessExitedSignal != "" {
		e.FieldStart("platformEventProcessExitedSignal")
		e.Str(p.PlatformEventProcessExitedSignal)
	}
	if p.PlatformEventNetworkEventInterfaceName != "" {
		e.FieldStart("platformEventNetworkEventInterfaceName")
		e.Str(p.PlatformEventNetworkEventInterfaceName)
	}
	if p.PlatformEventNetworkEventRemoteAddr != "" {
		e.FieldStart("platformEventNetworkEventRemoteAddr")
		e.Str(p.PlatformEventNetworkEventRemoteAddr)
	}
	if p.PlatformEventNetworkEventRemotePort != 0 {
		e.FieldStart("platformEventNetworkEventRemotePort")
		e.Int32(p.PlatformEventNetworkEventRemotePort)
	}
	if p.PlatformEventNetworkEventProtocol != "" {
		e.FieldStart("platformEventNetworkEventProtocol")
		e.Str(p.PlatformEventNetworkEventProtocol)
	}
	if p.PlatformEventNetworkEventBytesSent != 0 {
		e.FieldStart("platformEventNetworkEventBytesSent")
		e.Int64(p.PlatformEventNetworkEventBytesSent)
	}
	if p.PlatformEventNetworkEventBytesReceived != 0 {
		e.FieldStart("platformEventNetworkEventBytesReceived")
		e.Int64(p.PlatformEventNetworkEventBytesReceived)
	}
	e.ObjEnd()
}

// MarshalJSON implements json.Marshaler using jx
func (p *PlatformEventPlain) MarshalJSON() ([]byte, error) {
	e := jx.GetEncoder()
	defer jx.PutEncoder(e)
	p.MarshalJX(e)
	return e.Bytes(), nil
}

// UnmarshalJX decodes PlatformEventPlain from JSON using jx.Decoder
// Populates Src_ with indices of decoded fields
func (p *PlatformEventPlain) UnmarshalJX(d *jx.Decoder) error {
	if p == nil {
		return nil
	}

	return d.Obj(func(d *jx.Decoder, key string) error {
		switch key {
		case "_src":
			return d.Arr(func(d *jx.Decoder) error {
				v, err := d.UInt16()
				if err != nil {
					return err
				}
				p.Src_ = append(p.Src_, v)
				return nil
			})
		case "platform_event_case":
			v, err := d.Str()
			if err != nil {
				return err
			}
			p.PlatformEventCase = v
		case "eventId":
			v, err := d.Str()
			if err != nil {
				return err
			}
			p.EventId = v
			p.Src_ = append(p.Src_, 0)
		case "eventTime":
			v, err := d.Int64()
			if err != nil {
				return err
			}
			p.EventTime = v
			p.Src_ = append(p.Src_, 1)
		case "source":
			v, err := d.Str()
			if err != nil {
				return err
			}
			p.Source = v
			p.Src_ = append(p.Src_, 2)
		case "labels":
			if p.Labels == nil {
				p.Labels = make(map[string]string)
			}
			return d.Obj(func(d *jx.Decoder, key string) error {
				v, err := d.Str()
				if err != nil {
					return err
				}
				p.Labels[key] = v
				return nil
			})
			p.Src_ = append(p.Src_, 3)
		case "platformEventHeartbeatTimestamp":
			v, err := d.Int64()
			if err != nil {
				return err
			}
			p.PlatformEventHeartbeatTimestamp = v
			p.Src_ = append(p.Src_, 4)
		case "platformEventHeartbeatNodeId":
			v, err := d.Str()
			if err != nil {
				return err
			}
			p.PlatformEventHeartbeatNodeId = v
			p.Src_ = append(p.Src_, 5)
		case "platformEventHeartbeatCpuPercent":
			v, err := d.Int32()
			if err != nil {
				return err
			}
			p.PlatformEventHeartbeatCpuPercent = v
			p.Src_ = append(p.Src_, 6)
		case "platformEventHeartbeatMemoryBytes":
			v, err := d.Int64()
			if err != nil {
				return err
			}
			p.PlatformEventHeartbeatMemoryBytes = v
			p.Src_ = append(p.Src_, 7)
		case "platformEventProcessStartedProcessId":
			v, err := d.Str()
			if err != nil {
				return err
			}
			p.PlatformEventProcessStartedProcessId = v
			p.Src_ = append(p.Src_, 8)
		case "platformEventProcessStartedCommand":
			v, err := d.Str()
			if err != nil {
				return err
			}
			p.PlatformEventProcessStartedCommand = v
			p.Src_ = append(p.Src_, 9)
		case "platformEventProcessStartedArgs":
			if err := d.Arr(func(d *jx.Decoder) error {
				v, err := d.Str()
				if err != nil {
					return err
				}
				p.PlatformEventProcessStartedArgs = append(p.PlatformEventProcessStartedArgs, v)
				return nil
			}); err != nil {
				return err
			}
			p.Src_ = append(p.Src_, 10)
		case "platformEventProcessStartedStartTime":
			v, err := d.Int64()
			if err != nil {
				return err
			}
			p.PlatformEventProcessStartedStartTime = v
			p.Src_ = append(p.Src_, 11)
		case "platformEventProcessExitedProcessId":
			v, err := d.Str()
			if err != nil {
				return err
			}
			p.PlatformEventProcessExitedProcessId = v
			p.Src_ = append(p.Src_, 12)
		case "platformEventProcessExitedExitCode":
			v, err := d.Int32()
			if err != nil {
				return err
			}
			p.PlatformEventProcessExitedExitCode = v
			p.Src_ = append(p.Src_, 13)
		case "platformEventProcessExitedExitTime":
			v, err := d.Int64()
			if err != nil {
				return err
			}
			p.PlatformEventProcessExitedExitTime = v
			p.Src_ = append(p.Src_, 14)
		case "platformEventProcessExitedSignal":
			v, err := d.Str()
			if err != nil {
				return err
			}
			p.PlatformEventProcessExitedSignal = v
			p.Src_ = append(p.Src_, 15)
		case "platformEventNetworkEventInterfaceName":
			v, err := d.Str()
			if err != nil {
				return err
			}
			p.PlatformEventNetworkEventInterfaceName = v
			p.Src_ = append(p.Src_, 16)
		case "platformEventNetworkEventRemoteAddr":
			v, err := d.Str()
			if err != nil {
				return err
			}
			p.PlatformEventNetworkEventRemoteAddr = v
			p.Src_ = append(p.Src_, 17)
		case "platformEventNetworkEventRemotePort":
			v, err := d.Int32()
			if err != nil {
				return err
			}
			p.PlatformEventNetworkEventRemotePort = v
			p.Src_ = append(p.Src_, 18)
		case "platformEventNetworkEventProtocol":
			v, err := d.Str()
			if err != nil {
				return err
			}
			p.PlatformEventNetworkEventProtocol = v
			p.Src_ = append(p.Src_, 19)
		case "platformEventNetworkEventBytesSent":
			v, err := d.Int64()
			if err != nil {
				return err
			}
			p.PlatformEventNetworkEventBytesSent = v
			p.Src_ = append(p.Src_, 20)
		case "platformEventNetworkEventBytesReceived":
			v, err := d.Int64()
			if err != nil {
				return err
			}
			p.PlatformEventNetworkEventBytesReceived = v
			p.Src_ = append(p.Src_, 21)
		default:
			return d.Skip()
		}
		return nil
	})
}

// UnmarshalJSON implements json.Unmarshaler using jx
func (p *PlatformEventPlain) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return p.UnmarshalJX(d)
}

// platformEventPlainPool is a sync.Pool for PlatformEventPlain objects
var platformEventPlainPool = sync.Pool{
	New: func() interface{} {
		return &PlatformEventPlain{
			Src_: make([]uint16, 0, 32),
		}
	},
}

// GetPlatformEventPlain returns a PlatformEventPlain from the pool
func GetPlatformEventPlain() *PlatformEventPlain {
	return platformEventPlainPool.Get().(*PlatformEventPlain)
}

// PutPlatformEventPlain returns a PlatformEventPlain to the pool after resetting it
func PutPlatformEventPlain(p *PlatformEventPlain) {
	if p == nil {
		return
	}
	p.Reset()
	platformEventPlainPool.Put(p)
}

// Reset clears all fields in PlatformEventPlain for reuse
func (p *PlatformEventPlain) Reset() {
	if p == nil {
		return
	}

	p.Src_ = p.Src_[:0]

	p.PlatformEventCase = ""
	p.EventId = ""
	p.EventTime = 0
	p.Source = ""
	for k := range p.Labels {
		delete(p.Labels, k)
	}
	p.PlatformEventHeartbeatTimestamp = 0
	p.PlatformEventHeartbeatNodeId = ""
	p.PlatformEventHeartbeatCpuPercent = 0
	p.PlatformEventHeartbeatMemoryBytes = 0
	p.PlatformEventProcessStartedProcessId = ""
	p.PlatformEventProcessStartedCommand = ""
	p.PlatformEventProcessStartedArgs = p.PlatformEventProcessStartedArgs[:0]
	p.PlatformEventProcessStartedStartTime = 0
	p.PlatformEventProcessExitedProcessId = ""
	p.PlatformEventProcessExitedExitCode = 0
	p.PlatformEventProcessExitedExitTime = 0
	p.PlatformEventProcessExitedSignal = ""
	p.PlatformEventNetworkEventInterfaceName = ""
	p.PlatformEventNetworkEventRemoteAddr = ""
	p.PlatformEventNetworkEventRemotePort = 0
	p.PlatformEventNetworkEventProtocol = ""
	p.PlatformEventNetworkEventBytesSent = 0
	p.PlatformEventNetworkEventBytesReceived = 0
}

type DeprecatedShowcasePlain struct {
	Id          string `json:"id"`
	Name        string `json:"name"`
	OldField    string `json:"oldField"`
	LegacyCount int32  `json:"legacyCount"`
	NewField    string `json:"newField"`
	// Src_ contains indices of populated fields for sparse serialization
	Src_ []uint16 `json:"_src,omitempty"`
}

// IntoPlain converts protobuf message to plain struct
func (pb *DeprecatedShowcase) IntoPlain() *DeprecatedShowcasePlain {
	if pb == nil {
		return nil
	}
	p := &DeprecatedShowcasePlain{}

	p.Id = pb.Id
	p.Src_ = append(p.Src_, 0)
	p.Name = pb.Name
	p.Src_ = append(p.Src_, 1)
	p.OldField = pb.OldField
	p.Src_ = append(p.Src_, 2)
	p.LegacyCount = pb.LegacyCount
	p.Src_ = append(p.Src_, 3)
	p.NewField = pb.NewField
	p.Src_ = append(p.Src_, 4)
	return p
}

// IntoPb converts plain struct to protobuf message
func (p *DeprecatedShowcasePlain) IntoPb() *DeprecatedShowcase {
	if p == nil {
		return nil
	}
	pb := &DeprecatedShowcase{}

	pb.Id = p.Id
	pb.Name = p.Name
	pb.OldField = p.OldField
	pb.LegacyCount = p.LegacyCount
	pb.NewField = p.NewField
	return pb
}

// IntoPlainReuse converts protobuf message to existing plain struct (for pool usage)
func (pb *DeprecatedShowcase) IntoPlainReuse(p *DeprecatedShowcasePlain) {
	if pb == nil || p == nil {
		return
	}
	// Reset before filling
	p.Reset()

	p.Id = pb.Id
	p.Src_ = append(p.Src_, 0)
	p.Name = pb.Name
	p.Src_ = append(p.Src_, 1)
	p.OldField = pb.OldField
	p.Src_ = append(p.Src_, 2)
	p.LegacyCount = pb.LegacyCount
	p.Src_ = append(p.Src_, 3)
	p.NewField = pb.NewField
	p.Src_ = append(p.Src_, 4)
}

// MarshalJX encodes DeprecatedShowcasePlain to JSON using jx.Encoder
func (p *DeprecatedShowcasePlain) MarshalJX(e *jx.Encoder) {
	if p == nil {
		e.Null()
		return
	}

	e.ObjStart()

	if p.Id != "" {
		e.FieldStart("id")
		e.Str(p.Id)
	}
	if p.Name != "" {
		e.FieldStart("name")
		e.Str(p.Name)
	}
	if p.OldField != "" {
		e.FieldStart("oldField")
		e.Str(p.OldField)
	}
	if p.LegacyCount != 0 {
		e.FieldStart("legacyCount")
		e.Int32(p.LegacyCount)
	}
	if p.NewField != "" {
		e.FieldStart("newField")
		e.Str(p.NewField)
	}
	e.ObjEnd()
}

// MarshalJSON implements json.Marshaler using jx
func (p *DeprecatedShowcasePlain) MarshalJSON() ([]byte, error) {
	e := jx.GetEncoder()
	defer jx.PutEncoder(e)
	p.MarshalJX(e)
	return e.Bytes(), nil
}

// UnmarshalJX decodes DeprecatedShowcasePlain from JSON using jx.Decoder
// Populates Src_ with indices of decoded fields
func (p *DeprecatedShowcasePlain) UnmarshalJX(d *jx.Decoder) error {
	if p == nil {
		return nil
	}

	return d.Obj(func(d *jx.Decoder, key string) error {
		switch key {
		case "_src":
			return d.Arr(func(d *jx.Decoder) error {
				v, err := d.UInt16()
				if err != nil {
					return err
				}
				p.Src_ = append(p.Src_, v)
				return nil
			})
		case "id":
			v, err := d.Str()
			if err != nil {
				return err
			}
			p.Id = v
			p.Src_ = append(p.Src_, 0)
		case "name":
			v, err := d.Str()
			if err != nil {
				return err
			}
			p.Name = v
			p.Src_ = append(p.Src_, 1)
		case "oldField":
			v, err := d.Str()
			if err != nil {
				return err
			}
			p.OldField = v
			p.Src_ = append(p.Src_, 2)
		case "legacyCount":
			v, err := d.Int32()
			if err != nil {
				return err
			}
			p.LegacyCount = v
			p.Src_ = append(p.Src_, 3)
		case "newField":
			v, err := d.Str()
			if err != nil {
				return err
			}
			p.NewField = v
			p.Src_ = append(p.Src_, 4)
		default:
			return d.Skip()
		}
		return nil
	})
}

// UnmarshalJSON implements json.Unmarshaler using jx
func (p *DeprecatedShowcasePlain) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return p.UnmarshalJX(d)
}

// deprecatedShowcasePlainPool is a sync.Pool for DeprecatedShowcasePlain objects
var deprecatedShowcasePlainPool = sync.Pool{
	New: func() interface{} {
		return &DeprecatedShowcasePlain{
			Src_: make([]uint16, 0, 32),
		}
	},
}

// GetDeprecatedShowcasePlain returns a DeprecatedShowcasePlain from the pool
func GetDeprecatedShowcasePlain() *DeprecatedShowcasePlain {
	return deprecatedShowcasePlainPool.Get().(*DeprecatedShowcasePlain)
}

// PutDeprecatedShowcasePlain returns a DeprecatedShowcasePlain to the pool after resetting it
func PutDeprecatedShowcasePlain(p *DeprecatedShowcasePlain) {
	if p == nil {
		return
	}
	p.Reset()
	deprecatedShowcasePlainPool.Put(p)
}

// Reset clears all fields in DeprecatedShowcasePlain for reuse
func (p *DeprecatedShowcasePlain) Reset() {
	if p == nil {
		return
	}

	p.Src_ = p.Src_[:0]

	p.Id = ""
	p.Name = ""
	p.OldField = ""
	p.LegacyCount = 0
	p.NewField = ""
}

type DefaultsShowcasePlain struct {
	EmptyString  string            `json:"emptyString"`
	ZeroInt      int32             `json:"zeroInt"`
	ZeroLong     int64             `json:"zeroLong"`
	ZeroDouble   float64           `json:"zeroDouble"`
	FalseBool    bool              `json:"falseBool"`
	EmptyBytes   []byte            `json:"emptyBytes"`
	ZeroEnum     Status            `json:"zeroEnum"`
	EmptyList    []string          `json:"emptyList"`
	EmptyIntList []int32           `json:"emptyIntList"`
	EmptyMap     map[string]string `json:"emptyMap"`
	NilMessage   *Address          `json:"nilMessage"`
	// Src_ contains indices of populated fields for sparse serialization
	Src_ []uint16 `json:"_src,omitempty"`
}

// IntoPlain converts protobuf message to plain struct
func (pb *DefaultsShowcase) IntoPlain() *DefaultsShowcasePlain {
	if pb == nil {
		return nil
	}
	p := &DefaultsShowcasePlain{}

	p.EmptyString = pb.EmptyString
	p.Src_ = append(p.Src_, 0)
	p.ZeroInt = pb.ZeroInt
	p.Src_ = append(p.Src_, 1)
	p.ZeroLong = pb.ZeroLong
	p.Src_ = append(p.Src_, 2)
	p.ZeroDouble = pb.ZeroDouble
	p.Src_ = append(p.Src_, 3)
	p.FalseBool = pb.FalseBool
	p.Src_ = append(p.Src_, 4)
	p.EmptyBytes = pb.EmptyBytes
	p.Src_ = append(p.Src_, 5)
	p.ZeroEnum = pb.ZeroEnum
	p.Src_ = append(p.Src_, 6)
	p.EmptyList = pb.EmptyList
	p.Src_ = append(p.Src_, 7)
	p.EmptyIntList = pb.EmptyIntList
	p.Src_ = append(p.Src_, 8)
	p.EmptyMap = pb.EmptyMap
	p.Src_ = append(p.Src_, 9)
	p.NilMessage = pb.NilMessage
	p.Src_ = append(p.Src_, 10)
	return p
}

// IntoPb converts plain struct to protobuf message
func (p *DefaultsShowcasePlain) IntoPb() *DefaultsShowcase {
	if p == nil {
		return nil
	}
	pb := &DefaultsShowcase{}

	pb.EmptyString = p.EmptyString
	pb.ZeroInt = p.ZeroInt
	pb.ZeroLong = p.ZeroLong
	pb.ZeroDouble = p.ZeroDouble
	pb.FalseBool = p.FalseBool
	pb.EmptyBytes = p.EmptyBytes
	pb.ZeroEnum = p.ZeroEnum
	pb.EmptyList = p.EmptyList
	pb.EmptyIntList = p.EmptyIntList
	pb.EmptyMap = p.EmptyMap
	pb.NilMessage = p.NilMessage
	return pb
}

// IntoPlainReuse converts protobuf message to existing plain struct (for pool usage)
func (pb *DefaultsShowcase) IntoPlainReuse(p *DefaultsShowcasePlain) {
	if pb == nil || p == nil {
		return
	}
	// Reset before filling
	p.Reset()

	p.EmptyString = pb.EmptyString
	p.Src_ = append(p.Src_, 0)
	p.ZeroInt = pb.ZeroInt
	p.Src_ = append(p.Src_, 1)
	p.ZeroLong = pb.ZeroLong
	p.Src_ = append(p.Src_, 2)
	p.ZeroDouble = pb.ZeroDouble
	p.Src_ = append(p.Src_, 3)
	p.FalseBool = pb.FalseBool
	p.Src_ = append(p.Src_, 4)
	p.EmptyBytes = pb.EmptyBytes
	p.Src_ = append(p.Src_, 5)
	p.ZeroEnum = pb.ZeroEnum
	p.Src_ = append(p.Src_, 6)
	p.EmptyList = pb.EmptyList
	p.Src_ = append(p.Src_, 7)
	p.EmptyIntList = pb.EmptyIntList
	p.Src_ = append(p.Src_, 8)
	p.EmptyMap = pb.EmptyMap
	p.Src_ = append(p.Src_, 9)
	p.NilMessage = pb.NilMessage
	p.Src_ = append(p.Src_, 10)
}

// MarshalJX encodes DefaultsShowcasePlain to JSON using jx.Encoder
func (p *DefaultsShowcasePlain) MarshalJX(e *jx.Encoder) {
	if p == nil {
		e.Null()
		return
	}

	e.ObjStart()

	if p.EmptyString != "" {
		e.FieldStart("emptyString")
		e.Str(p.EmptyString)
	}
	if p.ZeroInt != 0 {
		e.FieldStart("zeroInt")
		e.Int32(p.ZeroInt)
	}
	if p.ZeroLong != 0 {
		e.FieldStart("zeroLong")
		e.Int64(p.ZeroLong)
	}
	if p.ZeroDouble != 0 {
		e.FieldStart("zeroDouble")
		e.Float64(p.ZeroDouble)
	}
	if p.FalseBool {
		e.FieldStart("falseBool")
		e.Bool(p.FalseBool)
	}
	if len(p.EmptyBytes) > 0 {
		e.FieldStart("emptyBytes")
		e.Base64(p.EmptyBytes)
	}
	e.FieldStart("zeroEnum")
	e.Int32(int32(p.ZeroEnum))
	if len(p.EmptyList) > 0 {
		e.FieldStart("emptyList")
		e.ArrStart()
		for _, v := range p.EmptyList {
			e.Str(v)
		}
		e.ArrEnd()
	}
	if len(p.EmptyIntList) > 0 {
		e.FieldStart("emptyIntList")
		e.ArrStart()
		for _, v := range p.EmptyIntList {
			e.Int32(v)
		}
		e.ArrEnd()
	}
	e.FieldStart("emptyMap")
	e.ObjStart()
	for k, v := range p.EmptyMap {
		e.FieldStart(k)
		e.Str(v)
	}
	e.ObjEnd()
	if p.NilMessage != nil {
		e.FieldStart("nilMessage")
		if data, err := protojson.Marshal(p.NilMessage); err == nil {
			e.Raw(data)
		} else {
			e.Null()
		}
	}
	e.ObjEnd()
}

// MarshalJSON implements json.Marshaler using jx
func (p *DefaultsShowcasePlain) MarshalJSON() ([]byte, error) {
	e := jx.GetEncoder()
	defer jx.PutEncoder(e)
	p.MarshalJX(e)
	return e.Bytes(), nil
}

// UnmarshalJX decodes DefaultsShowcasePlain from JSON using jx.Decoder
// Populates Src_ with indices of decoded fields
func (p *DefaultsShowcasePlain) UnmarshalJX(d *jx.Decoder) error {
	if p == nil {
		return nil
	}

	return d.Obj(func(d *jx.Decoder, key string) error {
		switch key {
		case "_src":
			return d.Arr(func(d *jx.Decoder) error {
				v, err := d.UInt16()
				if err != nil {
					return err
				}
				p.Src_ = append(p.Src_, v)
				return nil
			})
		case "emptyString":
			v, err := d.Str()
			if err != nil {
				return err
			}
			p.EmptyString = v
			p.Src_ = append(p.Src_, 0)
		case "zeroInt":
			v, err := d.Int32()
			if err != nil {
				return err
			}
			p.ZeroInt = v
			p.Src_ = append(p.Src_, 1)
		case "zeroLong":
			v, err := d.Int64()
			if err != nil {
				return err
			}
			p.ZeroLong = v
			p.Src_ = append(p.Src_, 2)
		case "zeroDouble":
			v, err := d.Float64()
			if err != nil {
				return err
			}
			p.ZeroDouble = v
			p.Src_ = append(p.Src_, 3)
		case "falseBool":
			v, err := d.Bool()
			if err != nil {
				return err
			}
			p.FalseBool = v
			p.Src_ = append(p.Src_, 4)
		case "emptyBytes":
			v, err := d.Base64()
			if err != nil {
				return err
			}
			p.EmptyBytes = v
			p.Src_ = append(p.Src_, 5)
		case "zeroEnum":
			v, err := d.Int32()
			if err != nil {
				return err
			}
			p.ZeroEnum = Status(v)
			p.Src_ = append(p.Src_, 6)
		case "emptyList":
			if err := d.Arr(func(d *jx.Decoder) error {
				v, err := d.Str()
				if err != nil {
					return err
				}
				p.EmptyList = append(p.EmptyList, v)
				return nil
			}); err != nil {
				return err
			}
			p.Src_ = append(p.Src_, 7)
		case "emptyIntList":
			if err := d.Arr(func(d *jx.Decoder) error {
				v, err := d.Int32()
				if err != nil {
					return err
				}
				p.EmptyIntList = append(p.EmptyIntList, v)
				return nil
			}); err != nil {
				return err
			}
			p.Src_ = append(p.Src_, 8)
		case "emptyMap":
			if p.EmptyMap == nil {
				p.EmptyMap = make(map[string]string)
			}
			return d.Obj(func(d *jx.Decoder, key string) error {
				v, err := d.Str()
				if err != nil {
					return err
				}
				p.EmptyMap[key] = v
				return nil
			})
			p.Src_ = append(p.Src_, 9)
		case "nilMessage":
			raw, err := d.Raw()
			if err != nil {
				return err
			}
			p.NilMessage = &Address{}
			if err := protojson.Unmarshal(raw, p.NilMessage); err != nil {
				return err
			}
			p.Src_ = append(p.Src_, 10)
		default:
			return d.Skip()
		}
		return nil
	})
}

// UnmarshalJSON implements json.Unmarshaler using jx
func (p *DefaultsShowcasePlain) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return p.UnmarshalJX(d)
}

// defaultsShowcasePlainPool is a sync.Pool for DefaultsShowcasePlain objects
var defaultsShowcasePlainPool = sync.Pool{
	New: func() interface{} {
		return &DefaultsShowcasePlain{
			Src_: make([]uint16, 0, 32),
		}
	},
}

// GetDefaultsShowcasePlain returns a DefaultsShowcasePlain from the pool
func GetDefaultsShowcasePlain() *DefaultsShowcasePlain {
	return defaultsShowcasePlainPool.Get().(*DefaultsShowcasePlain)
}

// PutDefaultsShowcasePlain returns a DefaultsShowcasePlain to the pool after resetting it
func PutDefaultsShowcasePlain(p *DefaultsShowcasePlain) {
	if p == nil {
		return
	}
	p.Reset()
	defaultsShowcasePlainPool.Put(p)
}

// Reset clears all fields in DefaultsShowcasePlain for reuse
func (p *DefaultsShowcasePlain) Reset() {
	if p == nil {
		return
	}

	p.Src_ = p.Src_[:0]

	p.EmptyString = ""
	p.ZeroInt = 0
	p.ZeroLong = 0
	p.ZeroDouble = 0
	p.FalseBool = false
	p.EmptyBytes = nil
	p.ZeroEnum = 0
	p.EmptyList = p.EmptyList[:0]
	p.EmptyIntList = p.EmptyIntList[:0]
	for k := range p.EmptyMap {
		delete(p.EmptyMap, k)
	}
	p.NilMessage = nil
}

type ComplexNestedPlain struct {
	Id            string                          `json:"id"`
	Inner         *ComplexNested_Inner            `json:"inner"`
	InnerList     []*ComplexNested_Inner          `json:"innerList"`
	InnerMap      map[string]*ComplexNested_Inner `json:"innerMap"`
	InnerEnum     ComplexNested_InnerEnum         `json:"innerEnum"`
	InnerEnumList []ComplexNested_InnerEnum       `json:"innerEnumList"`
	// Src_ contains indices of populated fields for sparse serialization
	Src_ []uint16 `json:"_src,omitempty"`
}

// IntoPlain converts protobuf message to plain struct
func (pb *ComplexNested) IntoPlain() *ComplexNestedPlain {
	if pb == nil {
		return nil
	}
	p := &ComplexNestedPlain{}

	p.Id = pb.Id
	p.Src_ = append(p.Src_, 0)
	p.Inner = pb.Inner
	p.Src_ = append(p.Src_, 1)
	p.InnerList = pb.InnerList
	p.Src_ = append(p.Src_, 2)
	p.InnerMap = pb.InnerMap
	p.Src_ = append(p.Src_, 3)
	p.InnerEnum = pb.InnerEnum
	p.Src_ = append(p.Src_, 4)
	p.InnerEnumList = pb.InnerEnumList
	p.Src_ = append(p.Src_, 5)
	return p
}

// IntoPb converts plain struct to protobuf message
func (p *ComplexNestedPlain) IntoPb() *ComplexNested {
	if p == nil {
		return nil
	}
	pb := &ComplexNested{}

	pb.Id = p.Id
	pb.Inner = p.Inner
	pb.InnerList = p.InnerList
	pb.InnerMap = p.InnerMap
	pb.InnerEnum = p.InnerEnum
	pb.InnerEnumList = p.InnerEnumList
	return pb
}

// IntoPlainReuse converts protobuf message to existing plain struct (for pool usage)
func (pb *ComplexNested) IntoPlainReuse(p *ComplexNestedPlain) {
	if pb == nil || p == nil {
		return
	}
	// Reset before filling
	p.Reset()

	p.Id = pb.Id
	p.Src_ = append(p.Src_, 0)
	p.Inner = pb.Inner
	p.Src_ = append(p.Src_, 1)
	p.InnerList = pb.InnerList
	p.Src_ = append(p.Src_, 2)
	p.InnerMap = pb.InnerMap
	p.Src_ = append(p.Src_, 3)
	p.InnerEnum = pb.InnerEnum
	p.Src_ = append(p.Src_, 4)
	p.InnerEnumList = pb.InnerEnumList
	p.Src_ = append(p.Src_, 5)
}

// MarshalJX encodes ComplexNestedPlain to JSON using jx.Encoder
func (p *ComplexNestedPlain) MarshalJX(e *jx.Encoder) {
	if p == nil {
		e.Null()
		return
	}

	e.ObjStart()

	if p.Id != "" {
		e.FieldStart("id")
		e.Str(p.Id)
	}
	if p.Inner != nil {
		e.FieldStart("inner")
		if data, err := protojson.Marshal(p.Inner); err == nil {
			e.Raw(data)
		} else {
			e.Null()
		}
	}
	if p.InnerList != nil {
		e.FieldStart("innerList")
		e.ArrStart()
		for _, v := range p.InnerList {
			if data, err := protojson.Marshal(v); err == nil {
				e.Raw(data)
			} else {
				e.Null()
			}
		}
		e.ArrEnd()
	}
	e.FieldStart("innerMap")
	e.ObjStart()
	for k, v := range p.InnerMap {
		e.FieldStart(k)
		if data, err := protojson.Marshal(v); err == nil {
			e.Raw(data)
		} else {
			e.Null()
		}
	}
	e.ObjEnd()
	e.FieldStart("innerEnum")
	e.Int32(int32(p.InnerEnum))
	if len(p.InnerEnumList) > 0 {
		e.FieldStart("innerEnumList")
		e.ArrStart()
		for _, v := range p.InnerEnumList {
			e.Int32(int32(v))
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

// MarshalJSON implements json.Marshaler using jx
func (p *ComplexNestedPlain) MarshalJSON() ([]byte, error) {
	e := jx.GetEncoder()
	defer jx.PutEncoder(e)
	p.MarshalJX(e)
	return e.Bytes(), nil
}

// UnmarshalJX decodes ComplexNestedPlain from JSON using jx.Decoder
// Populates Src_ with indices of decoded fields
func (p *ComplexNestedPlain) UnmarshalJX(d *jx.Decoder) error {
	if p == nil {
		return nil
	}

	return d.Obj(func(d *jx.Decoder, key string) error {
		switch key {
		case "_src":
			return d.Arr(func(d *jx.Decoder) error {
				v, err := d.UInt16()
				if err != nil {
					return err
				}
				p.Src_ = append(p.Src_, v)
				return nil
			})
		case "id":
			v, err := d.Str()
			if err != nil {
				return err
			}
			p.Id = v
			p.Src_ = append(p.Src_, 0)
		case "inner":
			raw, err := d.Raw()
			if err != nil {
				return err
			}
			p.Inner = &ComplexNested_Inner{}
			if err := protojson.Unmarshal(raw, p.Inner); err != nil {
				return err
			}
			p.Src_ = append(p.Src_, 1)
		case "innerList":
			if err := d.Arr(func(d *jx.Decoder) error {
				raw, err := d.Raw()
				if err != nil {
					return err
				}
				var v ComplexNested_Inner
				if err := protojson.Unmarshal(raw, &v); err != nil {
					return err
				}
				p.InnerList = append(p.InnerList, &v)
				return nil
			}); err != nil {
				return err
			}
			p.Src_ = append(p.Src_, 2)
		case "innerMap":
			if p.InnerMap == nil {
				p.InnerMap = make(map[string]*ComplexNested_Inner)
			}
			return d.Obj(func(d *jx.Decoder, key string) error {
				raw, err := d.Raw()
				if err != nil {
					return err
				}
				p.InnerMap[key] = &ComplexNested_Inner{}
				if err := protojson.Unmarshal(raw, p.InnerMap[key]); err != nil {
					return err
				}
				return nil
			})
			p.Src_ = append(p.Src_, 3)
		case "innerEnum":
			v, err := d.Int32()
			if err != nil {
				return err
			}
			p.InnerEnum = ComplexNested_InnerEnum(v)
			p.Src_ = append(p.Src_, 4)
		case "innerEnumList":
			if err := d.Arr(func(d *jx.Decoder) error {
				v, err := d.Int32()
				if err != nil {
					return err
				}
				p.InnerEnumList = append(p.InnerEnumList, ComplexNested_InnerEnum(v))
				return nil
			}); err != nil {
				return err
			}
			p.Src_ = append(p.Src_, 5)
		default:
			return d.Skip()
		}
		return nil
	})
}

// UnmarshalJSON implements json.Unmarshaler using jx
func (p *ComplexNestedPlain) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return p.UnmarshalJX(d)
}

// complexNestedPlainPool is a sync.Pool for ComplexNestedPlain objects
var complexNestedPlainPool = sync.Pool{
	New: func() interface{} {
		return &ComplexNestedPlain{
			Src_: make([]uint16, 0, 32),
		}
	},
}

// GetComplexNestedPlain returns a ComplexNestedPlain from the pool
func GetComplexNestedPlain() *ComplexNestedPlain {
	return complexNestedPlainPool.Get().(*ComplexNestedPlain)
}

// PutComplexNestedPlain returns a ComplexNestedPlain to the pool after resetting it
func PutComplexNestedPlain(p *ComplexNestedPlain) {
	if p == nil {
		return
	}
	p.Reset()
	complexNestedPlainPool.Put(p)
}

// Reset clears all fields in ComplexNestedPlain for reuse
func (p *ComplexNestedPlain) Reset() {
	if p == nil {
		return
	}

	p.Src_ = p.Src_[:0]

	p.Id = ""
	p.Inner = nil
	p.InnerList = nil
	for k := range p.InnerMap {
		delete(p.InnerMap, k)
	}
	p.InnerEnum = 0
	p.InnerEnumList = p.InnerEnumList[:0]
}
