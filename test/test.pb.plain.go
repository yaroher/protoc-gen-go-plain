// Code generated by protoc-gen-go-plain. DO NOT EDIT.

package test

import (
	uuid "github.com/google/uuid"
	cast "github.com/yaroher/protoc-gen-go-plain/cast"
	anypb "google.golang.org/protobuf/types/known/anypb"
	structpb "google.golang.org/protobuf/types/known/structpb"
	time "time"
)

type VirtualExtra struct {
	Id        string    `json:"id"`
	CreatedAt time.Time `json:"created_at"`
}

type TestMessagePlain struct {
	OidcId                   string                                        `json:"oidc_id"`
	Id                       uuid.UUID                                     `json:"id"`
	EmbedOidcId              string                                        `json:"embed_oidc_id"`
	EmbedId                  uuid.UUID                                     `json:"embed_id"`
	FDouble                  float64                                       `json:"f_double"`
	FFloat                   float32                                       `json:"f_float"`
	FInt32                   int32                                         `json:"f_int_32"`
	FInt64                   int64                                         `json:"f_int_64"`
	FUint32                  uint32                                        `json:"f_uint_32"`
	FUint64                  uint64                                        `json:"f_uint_64"`
	FSint32                  int32                                         `json:"f_sint_32"`
	FSint64                  int64                                         `json:"f_sint_64"`
	FFixed32                 uint32                                        `json:"f_fixed_32"`
	FFixed64                 uint64                                        `json:"f_fixed_64"`
	FSfixed32                int32                                         `json:"f_sfixed_32"`
	FSfixed64                int64                                         `json:"f_sfixed_64"`
	FBool                    bool                                          `json:"f_bool"`
	FString                  string                                        `json:"f_string"`
	FUuid                    uuid.UUID                                     `json:"f_uuid"`
	FBytes                   []byte                                        `json:"f_bytes"`
	FOptInt32                *int32                                        `json:"f_opt_int_32"`
	FOptString               *string                                       `json:"f_opt_string"`
	FOptMessage              *NestedMessage                                `json:"f_opt_message"`
	FOptEnum                 *TestEnum                                     `json:"f_opt_enum"`
	FRepInt32                []int32                                       `json:"f_rep_int_32"`
	FRepString               []string                                      `json:"f_rep_string"`
	FRepMessage              []*NestedMessage                              `json:"f_rep_message"`
	FRepMessageSerialized    [][]byte                                      `json:"f_rep_message_serialized"`
	FRepEnum                 []TestEnum                                    `json:"f_rep_enum"`
	FMapInt32String          map[int32]string                              `json:"f_map_int_32_string"`
	FMapInt64Int32           map[int64]int32                               `json:"f_map_int_64_int_32"`
	FMapUint32Uint64         map[uint32]uint64                             `json:"f_map_uint_32_uint_64"`
	FMapUint64Bool           map[uint64]bool                               `json:"f_map_uint_64_bool"`
	FMapSint32Bytes          map[int32][]byte                              `json:"f_map_sint_32_bytes"`
	FMapSint64Float          map[int64]float32                             `json:"f_map_sint_64_float"`
	FMapFixed32Double        map[uint32]float64                            `json:"f_map_fixed_32_double"`
	FMapFixed64Message       map[uint64]*NestedMessage                     `json:"f_map_fixed_64_message"`
	FMapSfixed32Enum         map[int32]TestEnum                            `json:"f_map_sfixed_32_enum"`
	FMapSfixed64String       map[int64]string                              `json:"f_map_sfixed_64_string"`
	FMapBoolInt32            map[bool]int32                                `json:"f_map_bool_int_32"`
	FMapStringString         map[string]string                             `json:"f_map_string_string"`
	FOneofInt32              *int32                                        `json:"f_oneof_int_32"`
	FOneofString             *string                                       `json:"f_oneof_string"`
	FOneofBytes              *[]byte                                       `json:"f_oneof_bytes"`
	FOneofMessage            *NestedMessage                                `json:"f_oneof_message"`
	FOneofEnum               *TestEnum                                     `json:"f_oneof_enum"`
	FNestedMessage           *NestedMessage                                `json:"f_nested_message"`
	Name                     string                                        `json:"name"`
	Inner                    *NestedMessage_InnerMessage                   `json:"inner"`
	DoubleEmbed              string                                        `json:"double_embed"`
	FNestedMessageSerialized []byte                                        `json:"f_nested_message_serialized"`
	FEnum                    TestEnum                                      `json:"f_enum"`
	FAny                     []byte                                        `json:"f_any"`
	FTimestamp               *time.Time                                    `json:"f_timestamp"`
	FDuration                *time.Duration                                `json:"f_duration"`
	FStruct                  map[string]any                                `json:"f_struct"`
	FValue                   []byte                                        `json:"f_value"`
	FListValue               []byte                                        `json:"f_list_value"`
	FWktDouble               *float64                                      `json:"f_wkt_double"`
	FWktFloat                *float32                                      `json:"f_wkt_float"`
	FWktInt64                *int64                                        `json:"f_wkt_int_64"`
	FWktUint64               *uint64                                       `json:"f_wkt_uint_64"`
	FWktInt32                *int32                                        `json:"f_wkt_int_32"`
	FWktUint32               *uint32                                       `json:"f_wkt_uint_32"`
	FWktBool                 *bool                                         `json:"f_wkt_bool"`
	FWktString               *string                                       `json:"f_wkt_string"`
	FWktBytes                *[]byte                                       `json:"f_wkt_bytes"`
	FDoubleNested            *NestedMessage_InnerMessage_InnerInnerMessage `json:"f_double_nested"`
	Meta                     int64                                         `json:"meta"`
	TraceId                  uuid.UUID                                     `json:"trace_id"`
	Debug                    string                                        `json:"debug"`
}

type TestMessagePlainOption func(*TestMessagePlain)

func WithTestMessageMeta(v int64) TestMessagePlainOption {
	return func(out *TestMessagePlain) { out.Meta = v }
}
func WithTestMessageTraceId(v uuid.UUID) TestMessagePlainOption {
	return func(out *TestMessagePlain) { out.TraceId = v }
}
func WithTestMessageDebug(v string) TestMessagePlainOption {
	return func(out *TestMessagePlain) { out.Debug = v }
}

func (src *TestMessage) IntoPlain(opts ...TestMessagePlainOption) *TestMessagePlain {
	if src == nil {
		return nil
	}
	out := &TestMessagePlain{}
	out.OidcId = func() string {
		if src.OidcId == nil {
			var zero string
			return zero
		}
		val := src.OidcId.Value
		return val
	}()
	out.Id = func() uuid.UUID {
		if src.Id == nil {
			var zero uuid.UUID
			return zero
		}
		val := func(v string) uuid.UUID {
			id, err := uuid.Parse(v)
			if err != nil {
				panic(err)
			}
			return id
		}(src.Id.Value)
		return val
	}()
	if src.Embed != nil {
		out.EmbedOidcId = func() string {
			if src.Embed.EmbedOidcId == nil {
				var zero string
				return zero
			}
			val := src.Embed.EmbedOidcId.Value
			return val
		}()
		out.EmbedId = func() uuid.UUID {
			if src.Embed.EmbedId == nil {
				var zero uuid.UUID
				return zero
			}
			val := func(v string) uuid.UUID {
				id, err := uuid.Parse(v)
				if err != nil {
					panic(err)
				}
				return id
			}(src.Embed.EmbedId.Value)
			return val
		}()
	}
	out.FDouble = src.FDouble
	out.FFloat = src.FFloat
	out.FInt32 = src.FInt32
	out.FInt64 = src.FInt64
	out.FUint32 = src.FUint32
	out.FUint64 = src.FUint64
	out.FSint32 = src.FSint32
	out.FSint64 = src.FSint64
	out.FFixed32 = src.FFixed32
	out.FFixed64 = src.FFixed64
	out.FSfixed32 = src.FSfixed32
	out.FSfixed64 = src.FSfixed64
	out.FBool = src.FBool
	out.FString = src.FString
	out.FUuid = func(v string) uuid.UUID {
		id, err := uuid.Parse(v)
		if err != nil {
			panic(err)
		}
		return id
	}(src.FUuid)
	out.FBytes = src.FBytes
	out.FOptInt32 = src.FOptInt32
	out.FOptString = src.FOptString
	out.FOptMessage = src.FOptMessage
	out.FOptEnum = src.FOptEnum
	out.FRepInt32 = src.FRepInt32
	out.FRepString = src.FRepString
	out.FRepMessage = src.FRepMessage
	if src.FRepMessageSerialized != nil {
		for _, el := range src.FRepMessageSerialized {
			out.FRepMessageSerialized = append(out.FRepMessageSerialized, cast.MessageToSliceByte(el))
		}
	}
	out.FRepEnum = src.FRepEnum
	out.FMapInt32String = src.FMapInt32String
	out.FMapInt64Int32 = src.FMapInt64Int32
	out.FMapUint32Uint64 = src.FMapUint32Uint64
	out.FMapUint64Bool = src.FMapUint64Bool
	out.FMapSint32Bytes = src.FMapSint32Bytes
	out.FMapSint64Float = src.FMapSint64Float
	out.FMapFixed32Double = src.FMapFixed32Double
	out.FMapFixed64Message = src.FMapFixed64Message
	out.FMapSfixed32Enum = src.FMapSfixed32Enum
	out.FMapSfixed64String = src.FMapSfixed64String
	out.FMapBoolInt32 = src.FMapBoolInt32
	out.FMapStringString = src.FMapStringString
	out.FNestedMessage = src.FNestedMessage
	if src.FNestedMessageEmbedded != nil {
		out.Name = src.FNestedMessageEmbedded.Name
		out.Inner = src.FNestedMessageEmbedded.Inner
		if src.FNestedMessageEmbedded.DoubleEmbedded != nil {
			out.DoubleEmbed = src.FNestedMessageEmbedded.DoubleEmbedded.DoubleEmbed
		}
	}
	out.FNestedMessageSerialized = cast.MessageToSliceByte(src.FNestedMessageSerialized)
	out.FEnum = src.FEnum
	out.FAny = cast.MessageToSliceByte(src.FAny)
	out.FTimestamp = cast.TimestampToPtrTime(src.FTimestamp)
	out.FDuration = cast.DurationToPtrTime(src.FDuration)
	out.FStruct = cast.StructToMap(src.FStruct)
	out.FValue = cast.MessageToSliceByte(src.FValue)
	out.FListValue = cast.MessageToSliceByte(src.FListValue)
	out.FWktDouble = cast.DoubleValueToPtrFloat64(src.FWktDouble)
	out.FWktFloat = cast.FloatValueToPtrFloat32(src.FWktFloat)
	out.FWktInt64 = cast.Int64ValueToPtrInt64(src.FWktInt64)
	out.FWktUint64 = cast.UInt64ValueToPtrUint64(src.FWktUint64)
	out.FWktInt32 = cast.Int32ValueToPtrInt32(src.FWktInt32)
	out.FWktUint32 = cast.UInt32ValueToPtrUint32(src.FWktUint32)
	out.FWktBool = cast.BoolValueToPtrBool(src.FWktBool)
	out.FWktString = cast.StringValueToPtrString(src.FWktString)
	out.FWktBytes = cast.BytesValueToPtrBytes(src.FWktBytes)
	out.FDoubleNested = src.FDoubleNested
	switch t := src.FOneof.(type) {
	case *TestMessage_FOneofInt32:
		val := t.FOneofInt32
		out.FOneofInt32 = &val
	case *TestMessage_FOneofString:
		val := t.FOneofString
		out.FOneofString = &val
	case *TestMessage_FOneofBytes:
		val := t.FOneofBytes
		out.FOneofBytes = &val
	case *TestMessage_FOneofMessage:
		out.FOneofMessage = t.FOneofMessage
	case *TestMessage_FOneofEnum:
		val := t.FOneofEnum
		out.FOneofEnum = &val
	}
	for _, opt := range opts {
		if opt != nil {
			opt(out)
		}
	}
	return out
}

func (src *TestMessage) IntoPlainDeep(opts ...TestMessagePlainOption) *TestMessagePlain {
	if src == nil {
		return nil
	}
	out := &TestMessagePlain{}
	out.OidcId = func() string {
		if src.OidcId == nil {
			var zero string
			return zero
		}
		val := src.OidcId.Value
		return val
	}()
	out.Id = func() uuid.UUID {
		if src.Id == nil {
			var zero uuid.UUID
			return zero
		}
		val := func(v string) uuid.UUID {
			id, err := uuid.Parse(v)
			if err != nil {
				panic(err)
			}
			return id
		}(src.Id.Value)
		return val
	}()
	if src.Embed != nil {
		out.EmbedOidcId = func() string {
			if src.Embed.EmbedOidcId == nil {
				var zero string
				return zero
			}
			val := src.Embed.EmbedOidcId.Value
			return val
		}()
		out.EmbedId = func() uuid.UUID {
			if src.Embed.EmbedId == nil {
				var zero uuid.UUID
				return zero
			}
			val := func(v string) uuid.UUID {
				id, err := uuid.Parse(v)
				if err != nil {
					panic(err)
				}
				return id
			}(src.Embed.EmbedId.Value)
			return val
		}()
	}
	out.FDouble = src.FDouble
	out.FFloat = src.FFloat
	out.FInt32 = src.FInt32
	out.FInt64 = src.FInt64
	out.FUint32 = src.FUint32
	out.FUint64 = src.FUint64
	out.FSint32 = src.FSint32
	out.FSint64 = src.FSint64
	out.FFixed32 = src.FFixed32
	out.FFixed64 = src.FFixed64
	out.FSfixed32 = src.FSfixed32
	out.FSfixed64 = src.FSfixed64
	out.FBool = src.FBool
	out.FString = src.FString
	out.FUuid = func(v string) uuid.UUID {
		id, err := uuid.Parse(v)
		if err != nil {
			panic(err)
		}
		return id
	}(src.FUuid)
	out.FBytes = append([]byte(nil), src.FBytes...)
	out.FOptInt32 = src.FOptInt32
	out.FOptString = src.FOptString
	out.FOptMessage = src.FOptMessage
	out.FOptEnum = src.FOptEnum
	if src.FRepInt32 != nil {
		for _, el := range src.FRepInt32 {
			out.FRepInt32 = append(out.FRepInt32, el)
		}
	}
	if src.FRepString != nil {
		for _, el := range src.FRepString {
			out.FRepString = append(out.FRepString, el)
		}
	}
	if src.FRepMessage != nil {
		for _, el := range src.FRepMessage {
			out.FRepMessage = append(out.FRepMessage, el)
		}
	}
	if src.FRepMessageSerialized != nil {
		for _, el := range src.FRepMessageSerialized {
			out.FRepMessageSerialized = append(out.FRepMessageSerialized, cast.MessageToSliceByte(el))
		}
	}
	if src.FRepEnum != nil {
		for _, el := range src.FRepEnum {
			out.FRepEnum = append(out.FRepEnum, el)
		}
	}
	if src.FMapInt32String != nil {
		out.FMapInt32String = make(map[int32]string, len(src.FMapInt32String))
		for k, val := range src.FMapInt32String {
			out.FMapInt32String[k] = val
		}
	}
	if src.FMapInt64Int32 != nil {
		out.FMapInt64Int32 = make(map[int64]int32, len(src.FMapInt64Int32))
		for k, val := range src.FMapInt64Int32 {
			out.FMapInt64Int32[k] = val
		}
	}
	if src.FMapUint32Uint64 != nil {
		out.FMapUint32Uint64 = make(map[uint32]uint64, len(src.FMapUint32Uint64))
		for k, val := range src.FMapUint32Uint64 {
			out.FMapUint32Uint64[k] = val
		}
	}
	if src.FMapUint64Bool != nil {
		out.FMapUint64Bool = make(map[uint64]bool, len(src.FMapUint64Bool))
		for k, val := range src.FMapUint64Bool {
			out.FMapUint64Bool[k] = val
		}
	}
	if src.FMapSint32Bytes != nil {
		out.FMapSint32Bytes = make(map[int32][]byte, len(src.FMapSint32Bytes))
		for k, val := range src.FMapSint32Bytes {
			out.FMapSint32Bytes[k] = append([]byte(nil), val...)
		}
	}
	if src.FMapSint64Float != nil {
		out.FMapSint64Float = make(map[int64]float32, len(src.FMapSint64Float))
		for k, val := range src.FMapSint64Float {
			out.FMapSint64Float[k] = val
		}
	}
	if src.FMapFixed32Double != nil {
		out.FMapFixed32Double = make(map[uint32]float64, len(src.FMapFixed32Double))
		for k, val := range src.FMapFixed32Double {
			out.FMapFixed32Double[k] = val
		}
	}
	if src.FMapFixed64Message != nil {
		out.FMapFixed64Message = make(map[uint64]*NestedMessage, len(src.FMapFixed64Message))
		for k, val := range src.FMapFixed64Message {
			out.FMapFixed64Message[k] = val
		}
	}
	if src.FMapSfixed32Enum != nil {
		out.FMapSfixed32Enum = make(map[int32]TestEnum, len(src.FMapSfixed32Enum))
		for k, val := range src.FMapSfixed32Enum {
			out.FMapSfixed32Enum[k] = val
		}
	}
	if src.FMapSfixed64String != nil {
		out.FMapSfixed64String = make(map[int64]string, len(src.FMapSfixed64String))
		for k, val := range src.FMapSfixed64String {
			out.FMapSfixed64String[k] = val
		}
	}
	if src.FMapBoolInt32 != nil {
		out.FMapBoolInt32 = make(map[bool]int32, len(src.FMapBoolInt32))
		for k, val := range src.FMapBoolInt32 {
			out.FMapBoolInt32[k] = val
		}
	}
	if src.FMapStringString != nil {
		out.FMapStringString = make(map[string]string, len(src.FMapStringString))
		for k, val := range src.FMapStringString {
			out.FMapStringString[k] = val
		}
	}
	out.FNestedMessage = src.FNestedMessage
	if src.FNestedMessageEmbedded != nil {
		out.Name = src.FNestedMessageEmbedded.Name
		out.Inner = src.FNestedMessageEmbedded.Inner
		if src.FNestedMessageEmbedded.DoubleEmbedded != nil {
			out.DoubleEmbed = src.FNestedMessageEmbedded.DoubleEmbedded.DoubleEmbed
		}
	}
	out.FNestedMessageSerialized = cast.MessageToSliceByte(src.FNestedMessageSerialized)
	out.FEnum = src.FEnum
	out.FAny = cast.MessageToSliceByte(src.FAny)
	out.FTimestamp = cast.TimestampToPtrTime(src.FTimestamp)
	out.FDuration = cast.DurationToPtrTime(src.FDuration)
	out.FStruct = cast.StructToMap(src.FStruct)
	out.FValue = cast.MessageToSliceByte(src.FValue)
	out.FListValue = cast.MessageToSliceByte(src.FListValue)
	out.FWktDouble = cast.DoubleValueToPtrFloat64(src.FWktDouble)
	out.FWktFloat = cast.FloatValueToPtrFloat32(src.FWktFloat)
	out.FWktInt64 = cast.Int64ValueToPtrInt64(src.FWktInt64)
	out.FWktUint64 = cast.UInt64ValueToPtrUint64(src.FWktUint64)
	out.FWktInt32 = cast.Int32ValueToPtrInt32(src.FWktInt32)
	out.FWktUint32 = cast.UInt32ValueToPtrUint32(src.FWktUint32)
	out.FWktBool = cast.BoolValueToPtrBool(src.FWktBool)
	out.FWktString = cast.StringValueToPtrString(src.FWktString)
	out.FWktBytes = cast.BytesValueToPtrBytes(src.FWktBytes)
	out.FDoubleNested = src.FDoubleNested
	switch t := src.FOneof.(type) {
	case *TestMessage_FOneofInt32:
		val := t.FOneofInt32
		out.FOneofInt32 = &val
	case *TestMessage_FOneofString:
		val := t.FOneofString
		out.FOneofString = &val
	case *TestMessage_FOneofBytes:
		val := append([]byte(nil), t.FOneofBytes...)
		out.FOneofBytes = &val
	case *TestMessage_FOneofMessage:
		out.FOneofMessage = t.FOneofMessage
	case *TestMessage_FOneofEnum:
		val := t.FOneofEnum
		out.FOneofEnum = &val
	}
	for _, opt := range opts {
		if opt != nil {
			opt(out)
		}
	}
	return out
}

func (src *TestMessagePlain) IntoPb() *TestMessage {
	if src == nil {
		return nil
	}
	out := &TestMessage{}
	out.OidcId = &OidcIdAlias{Value: src.OidcId}
	out.Id = &IdAlias{Value: func(v uuid.UUID) string { return v.String() }(src.Id)}
	out.Embed = &EmbedWithAlias{}
	out.Embed.EmbedOidcId = &OidcIdAlias{Value: src.EmbedOidcId}
	out.Embed.EmbedId = &IdAlias{Value: func(v uuid.UUID) string { return v.String() }(src.EmbedId)}
	out.FDouble = src.FDouble
	out.FFloat = src.FFloat
	out.FInt32 = src.FInt32
	out.FInt64 = src.FInt64
	out.FUint32 = src.FUint32
	out.FUint64 = src.FUint64
	out.FSint32 = src.FSint32
	out.FSint64 = src.FSint64
	out.FFixed32 = src.FFixed32
	out.FFixed64 = src.FFixed64
	out.FSfixed32 = src.FSfixed32
	out.FSfixed64 = src.FSfixed64
	out.FBool = src.FBool
	out.FString = src.FString
	out.FUuid = func(v uuid.UUID) string { return v.String() }(src.FUuid)
	out.FBytes = src.FBytes
	out.FOptInt32 = src.FOptInt32
	out.FOptString = src.FOptString
	out.FOptMessage = src.FOptMessage
	out.FOptEnum = src.FOptEnum
	out.FRepInt32 = src.FRepInt32
	out.FRepString = src.FRepString
	out.FRepMessage = src.FRepMessage
	if src.FRepMessageSerialized != nil {
		for _, el := range src.FRepMessageSerialized {
			out.FRepMessageSerialized = append(out.FRepMessageSerialized, cast.MessageFromSliceByte[*NestedMessage](el))
		}
	}
	out.FRepEnum = src.FRepEnum
	out.FMapInt32String = src.FMapInt32String
	out.FMapInt64Int32 = src.FMapInt64Int32
	out.FMapUint32Uint64 = src.FMapUint32Uint64
	out.FMapUint64Bool = src.FMapUint64Bool
	out.FMapSint32Bytes = src.FMapSint32Bytes
	out.FMapSint64Float = src.FMapSint64Float
	out.FMapFixed32Double = src.FMapFixed32Double
	out.FMapFixed64Message = src.FMapFixed64Message
	out.FMapSfixed32Enum = src.FMapSfixed32Enum
	out.FMapSfixed64String = src.FMapSfixed64String
	out.FMapBoolInt32 = src.FMapBoolInt32
	out.FMapStringString = src.FMapStringString
	out.FNestedMessage = src.FNestedMessage
	out.FNestedMessageEmbedded = &NestedMessage{}
	out.FNestedMessageEmbedded.Name = src.Name
	out.FNestedMessageEmbedded.Inner = src.Inner
	if src.DoubleEmbed != "" {
		if out.FNestedMessageEmbedded.DoubleEmbedded == nil {
			out.FNestedMessageEmbedded.DoubleEmbedded = &DoubleEmbeddedMessage{}
		}
		out.FNestedMessageEmbedded.DoubleEmbedded.DoubleEmbed = src.DoubleEmbed
	}
	out.FNestedMessageSerialized = cast.MessageFromSliceByte[*NestedMessage](src.FNestedMessageSerialized)
	out.FEnum = src.FEnum
	out.FAny = cast.MessageFromSliceByte[*anypb.Any](src.FAny)
	out.FTimestamp = cast.TimestampFromPtrTime(src.FTimestamp)
	out.FDuration = cast.DurationFromPtrTime(src.FDuration)
	out.FStruct = cast.StructFromMap(src.FStruct)
	out.FValue = cast.MessageFromSliceByte[*structpb.Value](src.FValue)
	out.FListValue = cast.MessageFromSliceByte[*structpb.ListValue](src.FListValue)
	out.FWktDouble = cast.DoubleValueFromPtrFloat64(src.FWktDouble)
	out.FWktFloat = cast.FloatValueFromPtrFloat32(src.FWktFloat)
	out.FWktInt64 = cast.Int64ValueFromPtrInt64(src.FWktInt64)
	out.FWktUint64 = cast.UInt64ValueFromPtrUint64(src.FWktUint64)
	out.FWktInt32 = cast.Int32ValueFromPtrInt32(src.FWktInt32)
	out.FWktUint32 = cast.UInt32ValueFromPtrUint32(src.FWktUint32)
	out.FWktBool = cast.BoolValueFromPtrBool(src.FWktBool)
	out.FWktString = cast.StringValueFromPtrString(src.FWktString)
	out.FWktBytes = cast.BytesValueFromPtrBytes(src.FWktBytes)
	out.FDoubleNested = src.FDoubleNested
	if src.FOneofInt32 != nil {
		out.FOneof = &TestMessage_FOneofInt32{FOneofInt32: *src.FOneofInt32}
	} else if src.FOneofString != nil {
		out.FOneof = &TestMessage_FOneofString{FOneofString: *src.FOneofString}
	} else if src.FOneofBytes != nil {
		out.FOneof = &TestMessage_FOneofBytes{FOneofBytes: *src.FOneofBytes}
	} else if src.FOneofMessage != nil {
		out.FOneof = &TestMessage_FOneofMessage{FOneofMessage: src.FOneofMessage}
	} else if src.FOneofEnum != nil {
		out.FOneof = &TestMessage_FOneofEnum{FOneofEnum: *src.FOneofEnum}
	}
	return out
}

func (src *TestMessagePlain) IntoPbDeep() *TestMessage {
	if src == nil {
		return nil
	}
	out := &TestMessage{}
	out.OidcId = &OidcIdAlias{Value: src.OidcId}
	out.Id = &IdAlias{Value: func(v uuid.UUID) string { return v.String() }(src.Id)}
	out.Embed = &EmbedWithAlias{}
	out.Embed.EmbedOidcId = &OidcIdAlias{Value: src.EmbedOidcId}
	out.Embed.EmbedId = &IdAlias{Value: func(v uuid.UUID) string { return v.String() }(src.EmbedId)}
	out.FDouble = src.FDouble
	out.FFloat = src.FFloat
	out.FInt32 = src.FInt32
	out.FInt64 = src.FInt64
	out.FUint32 = src.FUint32
	out.FUint64 = src.FUint64
	out.FSint32 = src.FSint32
	out.FSint64 = src.FSint64
	out.FFixed32 = src.FFixed32
	out.FFixed64 = src.FFixed64
	out.FSfixed32 = src.FSfixed32
	out.FSfixed64 = src.FSfixed64
	out.FBool = src.FBool
	out.FString = src.FString
	out.FUuid = func(v uuid.UUID) string { return v.String() }(src.FUuid)
	out.FBytes = append([]byte(nil), src.FBytes...)
	out.FOptInt32 = src.FOptInt32
	out.FOptString = src.FOptString
	out.FOptMessage = src.FOptMessage
	out.FOptEnum = src.FOptEnum
	if src.FRepInt32 != nil {
		for _, el := range src.FRepInt32 {
			out.FRepInt32 = append(out.FRepInt32, el)
		}
	}
	if src.FRepString != nil {
		for _, el := range src.FRepString {
			out.FRepString = append(out.FRepString, el)
		}
	}
	if src.FRepMessage != nil {
		for _, el := range src.FRepMessage {
			out.FRepMessage = append(out.FRepMessage, el)
		}
	}
	if src.FRepMessageSerialized != nil {
		for _, el := range src.FRepMessageSerialized {
			out.FRepMessageSerialized = append(out.FRepMessageSerialized, cast.MessageFromSliceByte[*NestedMessage](el))
		}
	}
	if src.FRepEnum != nil {
		for _, el := range src.FRepEnum {
			out.FRepEnum = append(out.FRepEnum, el)
		}
	}
	if src.FMapInt32String != nil {
		out.FMapInt32String = make(map[int32]string, len(src.FMapInt32String))
		for k, val := range src.FMapInt32String {
			out.FMapInt32String[k] = val
		}
	}
	if src.FMapInt64Int32 != nil {
		out.FMapInt64Int32 = make(map[int64]int32, len(src.FMapInt64Int32))
		for k, val := range src.FMapInt64Int32 {
			out.FMapInt64Int32[k] = val
		}
	}
	if src.FMapUint32Uint64 != nil {
		out.FMapUint32Uint64 = make(map[uint32]uint64, len(src.FMapUint32Uint64))
		for k, val := range src.FMapUint32Uint64 {
			out.FMapUint32Uint64[k] = val
		}
	}
	if src.FMapUint64Bool != nil {
		out.FMapUint64Bool = make(map[uint64]bool, len(src.FMapUint64Bool))
		for k, val := range src.FMapUint64Bool {
			out.FMapUint64Bool[k] = val
		}
	}
	if src.FMapSint32Bytes != nil {
		out.FMapSint32Bytes = make(map[int32][]byte, len(src.FMapSint32Bytes))
		for k, val := range src.FMapSint32Bytes {
			out.FMapSint32Bytes[k] = append([]byte(nil), val...)
		}
	}
	if src.FMapSint64Float != nil {
		out.FMapSint64Float = make(map[int64]float32, len(src.FMapSint64Float))
		for k, val := range src.FMapSint64Float {
			out.FMapSint64Float[k] = val
		}
	}
	if src.FMapFixed32Double != nil {
		out.FMapFixed32Double = make(map[uint32]float64, len(src.FMapFixed32Double))
		for k, val := range src.FMapFixed32Double {
			out.FMapFixed32Double[k] = val
		}
	}
	if src.FMapFixed64Message != nil {
		out.FMapFixed64Message = make(map[uint64]*NestedMessage, len(src.FMapFixed64Message))
		for k, val := range src.FMapFixed64Message {
			out.FMapFixed64Message[k] = val
		}
	}
	if src.FMapSfixed32Enum != nil {
		out.FMapSfixed32Enum = make(map[int32]TestEnum, len(src.FMapSfixed32Enum))
		for k, val := range src.FMapSfixed32Enum {
			out.FMapSfixed32Enum[k] = val
		}
	}
	if src.FMapSfixed64String != nil {
		out.FMapSfixed64String = make(map[int64]string, len(src.FMapSfixed64String))
		for k, val := range src.FMapSfixed64String {
			out.FMapSfixed64String[k] = val
		}
	}
	if src.FMapBoolInt32 != nil {
		out.FMapBoolInt32 = make(map[bool]int32, len(src.FMapBoolInt32))
		for k, val := range src.FMapBoolInt32 {
			out.FMapBoolInt32[k] = val
		}
	}
	if src.FMapStringString != nil {
		out.FMapStringString = make(map[string]string, len(src.FMapStringString))
		for k, val := range src.FMapStringString {
			out.FMapStringString[k] = val
		}
	}
	out.FNestedMessage = src.FNestedMessage
	out.FNestedMessageEmbedded = &NestedMessage{}
	out.FNestedMessageEmbedded.Name = src.Name
	out.FNestedMessageEmbedded.Inner = src.Inner
	if src.DoubleEmbed != "" {
		if out.FNestedMessageEmbedded.DoubleEmbedded == nil {
			out.FNestedMessageEmbedded.DoubleEmbedded = &DoubleEmbeddedMessage{}
		}
		out.FNestedMessageEmbedded.DoubleEmbedded.DoubleEmbed = src.DoubleEmbed
	}
	out.FNestedMessageSerialized = cast.MessageFromSliceByte[*NestedMessage](src.FNestedMessageSerialized)
	out.FEnum = src.FEnum
	out.FAny = cast.MessageFromSliceByte[*anypb.Any](src.FAny)
	out.FTimestamp = cast.TimestampFromPtrTime(src.FTimestamp)
	out.FDuration = cast.DurationFromPtrTime(src.FDuration)
	out.FStruct = cast.StructFromMap(src.FStruct)
	out.FValue = cast.MessageFromSliceByte[*structpb.Value](src.FValue)
	out.FListValue = cast.MessageFromSliceByte[*structpb.ListValue](src.FListValue)
	out.FWktDouble = cast.DoubleValueFromPtrFloat64(src.FWktDouble)
	out.FWktFloat = cast.FloatValueFromPtrFloat32(src.FWktFloat)
	out.FWktInt64 = cast.Int64ValueFromPtrInt64(src.FWktInt64)
	out.FWktUint64 = cast.UInt64ValueFromPtrUint64(src.FWktUint64)
	out.FWktInt32 = cast.Int32ValueFromPtrInt32(src.FWktInt32)
	out.FWktUint32 = cast.UInt32ValueFromPtrUint32(src.FWktUint32)
	out.FWktBool = cast.BoolValueFromPtrBool(src.FWktBool)
	out.FWktString = cast.StringValueFromPtrString(src.FWktString)
	out.FWktBytes = cast.BytesValueFromPtrBytes(src.FWktBytes)
	out.FDoubleNested = src.FDoubleNested
	if src.FOneofInt32 != nil {
		out.FOneof = &TestMessage_FOneofInt32{FOneofInt32: *src.FOneofInt32}
	} else if src.FOneofString != nil {
		out.FOneof = &TestMessage_FOneofString{FOneofString: *src.FOneofString}
	} else if src.FOneofBytes != nil {
		out.FOneof = &TestMessage_FOneofBytes{FOneofBytes: append([]byte(nil), *src.FOneofBytes...)}
	} else if src.FOneofMessage != nil {
		out.FOneof = &TestMessage_FOneofMessage{FOneofMessage: src.FOneofMessage}
	} else if src.FOneofEnum != nil {
		out.FOneof = &TestMessage_FOneofEnum{FOneofEnum: *src.FOneofEnum}
	}
	return out
}
