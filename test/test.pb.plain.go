// Code generated by protoc-gen-go-plain. DO NOT EDIT.

package test

import (
	uuid "github.com/google/uuid"
	cast "github.com/yaroher/protoc-gen-go-plain/cast"
	anypb "google.golang.org/protobuf/types/known/anypb"
	structpb "google.golang.org/protobuf/types/known/structpb"
	time "time"
)

type VirtualExtra struct {
	Id        string    `json:"id"`
	CreatedAt time.Time `json:"created_at"`
}

type TestMessagePlain struct {
	OidcId                   string                                        `json:"oidc_id"`
	Id                       uuid.UUID                                     `json:"id"`
	EmbedOidcId              string                                        `json:"embed_oidc_id"`
	EmbedId                  uuid.UUID                                     `json:"embed_id"`
	FDouble                  float64                                       `json:"f_double"`
	FFloat                   float32                                       `json:"f_float"`
	FInt32                   int32                                         `json:"f_int_32"`
	FInt64                   int64                                         `json:"f_int_64"`
	FUint32                  uint32                                        `json:"f_uint_32"`
	FUint64                  uint64                                        `json:"f_uint_64"`
	FSint32                  int32                                         `json:"f_sint_32"`
	FSint64                  int64                                         `json:"f_sint_64"`
	FFixed32                 uint32                                        `json:"f_fixed_32"`
	FFixed64                 uint64                                        `json:"f_fixed_64"`
	FSfixed32                int32                                         `json:"f_sfixed_32"`
	FSfixed64                int64                                         `json:"f_sfixed_64"`
	FBool                    bool                                          `json:"f_bool"`
	FString                  string                                        `json:"f_string"`
	FUuid                    uuid.UUID                                     `json:"f_uuid"`
	FBytes                   []byte                                        `json:"f_bytes"`
	FOptInt32                *int32                                        `json:"f_opt_int_32"`
	FOptString               *string                                       `json:"f_opt_string"`
	FOptMessage              *NestedMessage                                `json:"f_opt_message"`
	FOptEnum                 *TestEnum                                     `json:"f_opt_enum"`
	FRepInt32                []int32                                       `json:"f_rep_int_32"`
	FRepString               []string                                      `json:"f_rep_string"`
	FRepMessage              []*NestedMessage                              `json:"f_rep_message"`
	FRepMessageSerialized    [][]byte                                      `json:"f_rep_message_serialized"`
	FRepEnum                 []TestEnum                                    `json:"f_rep_enum"`
	FMapInt32String          map[int32]string                              `json:"f_map_int_32_string"`
	FMapInt64Int32           map[int64]int32                               `json:"f_map_int_64_int_32"`
	FMapUint32Uint64         map[uint32]uint64                             `json:"f_map_uint_32_uint_64"`
	FMapUint64Bool           map[uint64]bool                               `json:"f_map_uint_64_bool"`
	FMapSint32Bytes          map[int32][]byte                              `json:"f_map_sint_32_bytes"`
	FMapSint64Float          map[int64]float32                             `json:"f_map_sint_64_float"`
	FMapFixed32Double        map[uint32]float64                            `json:"f_map_fixed_32_double"`
	FMapFixed64Message       map[uint64]*NestedMessage                     `json:"f_map_fixed_64_message"`
	FMapSfixed32Enum         map[int32]TestEnum                            `json:"f_map_sfixed_32_enum"`
	FMapSfixed64String       map[int64]string                              `json:"f_map_sfixed_64_string"`
	FMapBoolInt32            map[bool]int32                                `json:"f_map_bool_int_32"`
	FMapStringString         map[string]string                             `json:"f_map_string_string"`
	FOneofInt32              *int32                                        `json:"f_oneof_int_32"`
	FOneofString             *string                                       `json:"f_oneof_string"`
	FOneofBytes              *[]byte                                       `json:"f_oneof_bytes"`
	FOneofMessage            *NestedMessage                                `json:"f_oneof_message"`
	FOneofEnum               *TestEnum                                     `json:"f_oneof_enum"`
	FNestedMessage           *NestedMessage                                `json:"f_nested_message"`
	Name                     string                                        `json:"name"`
	Inner                    *NestedMessage_InnerMessage                   `json:"inner"`
	DoubleEmbed              string                                        `json:"double_embed"`
	FNestedMessageSerialized []byte                                        `json:"f_nested_message_serialized"`
	FEnum                    TestEnum                                      `json:"f_enum"`
	FAny                     []byte                                        `json:"f_any"`
	FTimestamp               *time.Time                                    `json:"f_timestamp"`
	FDuration                *time.Duration                                `json:"f_duration"`
	FStruct                  map[string]any                                `json:"f_struct"`
	FValue                   []byte                                        `json:"f_value"`
	FListValue               []byte                                        `json:"f_list_value"`
	FWktDouble               *float64                                      `json:"f_wkt_double"`
	FWktFloat                *float32                                      `json:"f_wkt_float"`
	FWktInt64                *int64                                        `json:"f_wkt_int_64"`
	FWktUint64               *uint64                                       `json:"f_wkt_uint_64"`
	FWktInt32                *int32                                        `json:"f_wkt_int_32"`
	FWktUint32               *uint32                                       `json:"f_wkt_uint_32"`
	FWktBool                 *bool                                         `json:"f_wkt_bool"`
	FWktString               *string                                       `json:"f_wkt_string"`
	FWktBytes                *[]byte                                       `json:"f_wkt_bytes"`
	FDoubleNested            *NestedMessage_InnerMessage_InnerInnerMessage `json:"f_double_nested"`
	Meta                     int64                                         `json:"meta"`
	TraceId                  uuid.UUID                                     `json:"trace_id"`
	Debug                    string                                        `json:"debug"`
}

type TestMessagePlainOption func(*TestMessagePlain)

func WithTestMessageMeta(v int64) TestMessagePlainOption {
	return func(out *TestMessagePlain) { out.Meta = v }
}
func WithTestMessageTraceId(v uuid.UUID) TestMessagePlainOption {
	return func(out *TestMessagePlain) { out.TraceId = v }
}
func WithTestMessageDebug(v string) TestMessagePlainOption {
	return func(out *TestMessagePlain) { out.Debug = v }
}

func (v *TestMessage) IntoPlain(opts ...TestMessagePlainOption) *TestMessagePlain {
	if v == nil {
		return nil
	}
	out := &TestMessagePlain{}
	out.OidcId = func() string {
		if v.OidcId == nil {
			var zero string
			return zero
		}
		val := v.OidcId.Value
		return val
	}()
	out.Id = func() uuid.UUID {
		if v.Id == nil {
			var zero uuid.UUID
			return zero
		}
		val := func(v string) uuid.UUID {
			id, err := uuid.Parse(v)
			if err != nil {
				panic(err)
			}
			return id
		}(v.Id.Value)
		return val
	}()
	if v.Embed != nil {
		out.EmbedOidcId = func() string {
			if v.Embed.EmbedOidcId == nil {
				var zero string
				return zero
			}
			val := v.Embed.EmbedOidcId.Value
			return val
		}()
		out.EmbedId = func() uuid.UUID {
			if v.Embed.EmbedId == nil {
				var zero uuid.UUID
				return zero
			}
			val := func(v string) uuid.UUID {
				id, err := uuid.Parse(v)
				if err != nil {
					panic(err)
				}
				return id
			}(v.Embed.EmbedId.Value)
			return val
		}()
	}
	out.FDouble = v.FDouble
	out.FFloat = v.FFloat
	out.FInt32 = v.FInt32
	out.FInt64 = v.FInt64
	out.FUint32 = v.FUint32
	out.FUint64 = v.FUint64
	out.FSint32 = v.FSint32
	out.FSint64 = v.FSint64
	out.FFixed32 = v.FFixed32
	out.FFixed64 = v.FFixed64
	out.FSfixed32 = v.FSfixed32
	out.FSfixed64 = v.FSfixed64
	out.FBool = v.FBool
	out.FString = v.FString
	out.FUuid = func(v string) uuid.UUID {
		id, err := uuid.Parse(v)
		if err != nil {
			panic(err)
		}
		return id
	}(v.FUuid)
	out.FBytes = v.FBytes
	out.FOptInt32 = v.FOptInt32
	out.FOptString = v.FOptString
	out.FOptMessage = v.FOptMessage
	out.FOptEnum = v.FOptEnum
	out.FRepInt32 = v.FRepInt32
	out.FRepString = v.FRepString
	out.FRepMessage = v.FRepMessage
	if v.FRepMessageSerialized != nil {
		for _, el := range v.FRepMessageSerialized {
			out.FRepMessageSerialized = append(out.FRepMessageSerialized, cast.MessageToSliceByte(el))
		}
	}
	out.FRepEnum = v.FRepEnum
	out.FMapInt32String = v.FMapInt32String
	out.FMapInt64Int32 = v.FMapInt64Int32
	out.FMapUint32Uint64 = v.FMapUint32Uint64
	out.FMapUint64Bool = v.FMapUint64Bool
	out.FMapSint32Bytes = v.FMapSint32Bytes
	out.FMapSint64Float = v.FMapSint64Float
	out.FMapFixed32Double = v.FMapFixed32Double
	out.FMapFixed64Message = v.FMapFixed64Message
	out.FMapSfixed32Enum = v.FMapSfixed32Enum
	out.FMapSfixed64String = v.FMapSfixed64String
	out.FMapBoolInt32 = v.FMapBoolInt32
	out.FMapStringString = v.FMapStringString
	out.FNestedMessage = v.FNestedMessage
	if v.FNestedMessageEmbedded != nil {
		out.Name = v.FNestedMessageEmbedded.Name
		out.Inner = v.FNestedMessageEmbedded.Inner
		if v.FNestedMessageEmbedded.DoubleEmbedded != nil {
			out.DoubleEmbed = v.FNestedMessageEmbedded.DoubleEmbedded.DoubleEmbed
		}
	}
	out.FNestedMessageSerialized = cast.MessageToSliceByte(v.FNestedMessageSerialized)
	out.FEnum = v.FEnum
	out.FAny = cast.MessageToSliceByte(v.FAny)
	out.FTimestamp = cast.TimestampToPtrTime(v.FTimestamp)
	out.FDuration = cast.DurationToPtrTime(v.FDuration)
	out.FStruct = cast.StructToMap(v.FStruct)
	out.FValue = cast.MessageToSliceByte(v.FValue)
	out.FListValue = cast.MessageToSliceByte(v.FListValue)
	out.FWktDouble = cast.DoubleValueToPtrFloat64(v.FWktDouble)
	out.FWktFloat = cast.FloatValueToPtrFloat32(v.FWktFloat)
	out.FWktInt64 = cast.Int64ValueToPtrInt64(v.FWktInt64)
	out.FWktUint64 = cast.UInt64ValueToPtrUint64(v.FWktUint64)
	out.FWktInt32 = cast.Int32ValueToPtrInt32(v.FWktInt32)
	out.FWktUint32 = cast.UInt32ValueToPtrUint32(v.FWktUint32)
	out.FWktBool = cast.BoolValueToPtrBool(v.FWktBool)
	out.FWktString = cast.StringValueToPtrString(v.FWktString)
	out.FWktBytes = cast.BytesValueToPtrBytes(v.FWktBytes)
	out.FDoubleNested = v.FDoubleNested
	switch t := v.FOneof.(type) {
	case *TestMessage_FOneofInt32:
		val := t.FOneofInt32
		out.FOneofInt32 = &val
	case *TestMessage_FOneofString:
		val := t.FOneofString
		out.FOneofString = &val
	case *TestMessage_FOneofBytes:
		val := t.FOneofBytes
		out.FOneofBytes = &val
	case *TestMessage_FOneofMessage:
		out.FOneofMessage = t.FOneofMessage
	case *TestMessage_FOneofEnum:
		val := t.FOneofEnum
		out.FOneofEnum = &val
	}
	for _, opt := range opts {
		if opt != nil {
			opt(out)
		}
	}
	return out
}

func (v *TestMessage) IntoPlainDeep(opts ...TestMessagePlainOption) *TestMessagePlain {
	if v == nil {
		return nil
	}
	out := &TestMessagePlain{}
	out.OidcId = func() string {
		if v.OidcId == nil {
			var zero string
			return zero
		}
		val := v.OidcId.Value
		return val
	}()
	out.Id = func() uuid.UUID {
		if v.Id == nil {
			var zero uuid.UUID
			return zero
		}
		val := func(v string) uuid.UUID {
			id, err := uuid.Parse(v)
			if err != nil {
				panic(err)
			}
			return id
		}(v.Id.Value)
		return val
	}()
	if v.Embed != nil {
		out.EmbedOidcId = func() string {
			if v.Embed.EmbedOidcId == nil {
				var zero string
				return zero
			}
			val := v.Embed.EmbedOidcId.Value
			return val
		}()
		out.EmbedId = func() uuid.UUID {
			if v.Embed.EmbedId == nil {
				var zero uuid.UUID
				return zero
			}
			val := func(v string) uuid.UUID {
				id, err := uuid.Parse(v)
				if err != nil {
					panic(err)
				}
				return id
			}(v.Embed.EmbedId.Value)
			return val
		}()
	}
	out.FDouble = v.FDouble
	out.FFloat = v.FFloat
	out.FInt32 = v.FInt32
	out.FInt64 = v.FInt64
	out.FUint32 = v.FUint32
	out.FUint64 = v.FUint64
	out.FSint32 = v.FSint32
	out.FSint64 = v.FSint64
	out.FFixed32 = v.FFixed32
	out.FFixed64 = v.FFixed64
	out.FSfixed32 = v.FSfixed32
	out.FSfixed64 = v.FSfixed64
	out.FBool = v.FBool
	out.FString = v.FString
	out.FUuid = func(v string) uuid.UUID {
		id, err := uuid.Parse(v)
		if err != nil {
			panic(err)
		}
		return id
	}(v.FUuid)
	out.FBytes = append([]byte(nil), v.FBytes...)
	out.FOptInt32 = v.FOptInt32
	out.FOptString = v.FOptString
	out.FOptMessage = v.FOptMessage
	out.FOptEnum = v.FOptEnum
	if v.FRepInt32 != nil {
		for _, el := range v.FRepInt32 {
			out.FRepInt32 = append(out.FRepInt32, el)
		}
	}
	if v.FRepString != nil {
		for _, el := range v.FRepString {
			out.FRepString = append(out.FRepString, el)
		}
	}
	if v.FRepMessage != nil {
		for _, el := range v.FRepMessage {
			out.FRepMessage = append(out.FRepMessage, el)
		}
	}
	if v.FRepMessageSerialized != nil {
		for _, el := range v.FRepMessageSerialized {
			out.FRepMessageSerialized = append(out.FRepMessageSerialized, cast.MessageToSliceByte(el))
		}
	}
	if v.FRepEnum != nil {
		for _, el := range v.FRepEnum {
			out.FRepEnum = append(out.FRepEnum, el)
		}
	}
	if v.FMapInt32String != nil {
		out.FMapInt32String = make(map[int32]string, len(v.FMapInt32String))
		for k, val := range v.FMapInt32String {
			out.FMapInt32String[k] = val
		}
	}
	if v.FMapInt64Int32 != nil {
		out.FMapInt64Int32 = make(map[int64]int32, len(v.FMapInt64Int32))
		for k, val := range v.FMapInt64Int32 {
			out.FMapInt64Int32[k] = val
		}
	}
	if v.FMapUint32Uint64 != nil {
		out.FMapUint32Uint64 = make(map[uint32]uint64, len(v.FMapUint32Uint64))
		for k, val := range v.FMapUint32Uint64 {
			out.FMapUint32Uint64[k] = val
		}
	}
	if v.FMapUint64Bool != nil {
		out.FMapUint64Bool = make(map[uint64]bool, len(v.FMapUint64Bool))
		for k, val := range v.FMapUint64Bool {
			out.FMapUint64Bool[k] = val
		}
	}
	if v.FMapSint32Bytes != nil {
		out.FMapSint32Bytes = make(map[int32][]byte, len(v.FMapSint32Bytes))
		for k, val := range v.FMapSint32Bytes {
			out.FMapSint32Bytes[k] = append([]byte(nil), val...)
		}
	}
	if v.FMapSint64Float != nil {
		out.FMapSint64Float = make(map[int64]float32, len(v.FMapSint64Float))
		for k, val := range v.FMapSint64Float {
			out.FMapSint64Float[k] = val
		}
	}
	if v.FMapFixed32Double != nil {
		out.FMapFixed32Double = make(map[uint32]float64, len(v.FMapFixed32Double))
		for k, val := range v.FMapFixed32Double {
			out.FMapFixed32Double[k] = val
		}
	}
	if v.FMapFixed64Message != nil {
		out.FMapFixed64Message = make(map[uint64]*NestedMessage, len(v.FMapFixed64Message))
		for k, val := range v.FMapFixed64Message {
			out.FMapFixed64Message[k] = val
		}
	}
	if v.FMapSfixed32Enum != nil {
		out.FMapSfixed32Enum = make(map[int32]TestEnum, len(v.FMapSfixed32Enum))
		for k, val := range v.FMapSfixed32Enum {
			out.FMapSfixed32Enum[k] = val
		}
	}
	if v.FMapSfixed64String != nil {
		out.FMapSfixed64String = make(map[int64]string, len(v.FMapSfixed64String))
		for k, val := range v.FMapSfixed64String {
			out.FMapSfixed64String[k] = val
		}
	}
	if v.FMapBoolInt32 != nil {
		out.FMapBoolInt32 = make(map[bool]int32, len(v.FMapBoolInt32))
		for k, val := range v.FMapBoolInt32 {
			out.FMapBoolInt32[k] = val
		}
	}
	if v.FMapStringString != nil {
		out.FMapStringString = make(map[string]string, len(v.FMapStringString))
		for k, val := range v.FMapStringString {
			out.FMapStringString[k] = val
		}
	}
	out.FNestedMessage = v.FNestedMessage
	if v.FNestedMessageEmbedded != nil {
		out.Name = v.FNestedMessageEmbedded.Name
		out.Inner = v.FNestedMessageEmbedded.Inner
		if v.FNestedMessageEmbedded.DoubleEmbedded != nil {
			out.DoubleEmbed = v.FNestedMessageEmbedded.DoubleEmbedded.DoubleEmbed
		}
	}
	out.FNestedMessageSerialized = cast.MessageToSliceByte(v.FNestedMessageSerialized)
	out.FEnum = v.FEnum
	out.FAny = cast.MessageToSliceByte(v.FAny)
	out.FTimestamp = cast.TimestampToPtrTime(v.FTimestamp)
	out.FDuration = cast.DurationToPtrTime(v.FDuration)
	out.FStruct = cast.StructToMap(v.FStruct)
	out.FValue = cast.MessageToSliceByte(v.FValue)
	out.FListValue = cast.MessageToSliceByte(v.FListValue)
	out.FWktDouble = cast.DoubleValueToPtrFloat64(v.FWktDouble)
	out.FWktFloat = cast.FloatValueToPtrFloat32(v.FWktFloat)
	out.FWktInt64 = cast.Int64ValueToPtrInt64(v.FWktInt64)
	out.FWktUint64 = cast.UInt64ValueToPtrUint64(v.FWktUint64)
	out.FWktInt32 = cast.Int32ValueToPtrInt32(v.FWktInt32)
	out.FWktUint32 = cast.UInt32ValueToPtrUint32(v.FWktUint32)
	out.FWktBool = cast.BoolValueToPtrBool(v.FWktBool)
	out.FWktString = cast.StringValueToPtrString(v.FWktString)
	out.FWktBytes = cast.BytesValueToPtrBytes(v.FWktBytes)
	out.FDoubleNested = v.FDoubleNested
	switch t := v.FOneof.(type) {
	case *TestMessage_FOneofInt32:
		val := t.FOneofInt32
		out.FOneofInt32 = &val
	case *TestMessage_FOneofString:
		val := t.FOneofString
		out.FOneofString = &val
	case *TestMessage_FOneofBytes:
		val := append([]byte(nil), t.FOneofBytes...)
		out.FOneofBytes = &val
	case *TestMessage_FOneofMessage:
		out.FOneofMessage = t.FOneofMessage
	case *TestMessage_FOneofEnum:
		val := t.FOneofEnum
		out.FOneofEnum = &val
	}
	for _, opt := range opts {
		if opt != nil {
			opt(out)
		}
	}
	return out
}

func (v *TestMessagePlain) IntoPb() *TestMessage {
	if v == nil {
		return nil
	}
	out := &TestMessage{}
	out.OidcId = &OidcIdAlias{Value: v.OidcId}
	out.Id = &IdAlias{Value: func(v uuid.UUID) string { return v.String() }(v.Id)}
	out.Embed = &EmbedWithAlias{}
	out.Embed.EmbedOidcId = &OidcIdAlias{Value: v.EmbedOidcId}
	out.Embed.EmbedId = &IdAlias{Value: func(v uuid.UUID) string { return v.String() }(v.EmbedId)}
	out.FDouble = v.FDouble
	out.FFloat = v.FFloat
	out.FInt32 = v.FInt32
	out.FInt64 = v.FInt64
	out.FUint32 = v.FUint32
	out.FUint64 = v.FUint64
	out.FSint32 = v.FSint32
	out.FSint64 = v.FSint64
	out.FFixed32 = v.FFixed32
	out.FFixed64 = v.FFixed64
	out.FSfixed32 = v.FSfixed32
	out.FSfixed64 = v.FSfixed64
	out.FBool = v.FBool
	out.FString = v.FString
	out.FUuid = func(v uuid.UUID) string { return v.String() }(v.FUuid)
	out.FBytes = v.FBytes
	out.FOptInt32 = v.FOptInt32
	out.FOptString = v.FOptString
	out.FOptMessage = v.FOptMessage
	out.FOptEnum = v.FOptEnum
	out.FRepInt32 = v.FRepInt32
	out.FRepString = v.FRepString
	out.FRepMessage = v.FRepMessage
	if v.FRepMessageSerialized != nil {
		for _, el := range v.FRepMessageSerialized {
			out.FRepMessageSerialized = append(out.FRepMessageSerialized, cast.MessageFromSliceByte[*NestedMessage](el))
		}
	}
	out.FRepEnum = v.FRepEnum
	out.FMapInt32String = v.FMapInt32String
	out.FMapInt64Int32 = v.FMapInt64Int32
	out.FMapUint32Uint64 = v.FMapUint32Uint64
	out.FMapUint64Bool = v.FMapUint64Bool
	out.FMapSint32Bytes = v.FMapSint32Bytes
	out.FMapSint64Float = v.FMapSint64Float
	out.FMapFixed32Double = v.FMapFixed32Double
	out.FMapFixed64Message = v.FMapFixed64Message
	out.FMapSfixed32Enum = v.FMapSfixed32Enum
	out.FMapSfixed64String = v.FMapSfixed64String
	out.FMapBoolInt32 = v.FMapBoolInt32
	out.FMapStringString = v.FMapStringString
	out.FNestedMessage = v.FNestedMessage
	out.FNestedMessageEmbedded = &NestedMessage{}
	out.FNestedMessageEmbedded.Name = v.Name
	out.FNestedMessageEmbedded.Inner = v.Inner
	if v.DoubleEmbed != "" {
		if out.FNestedMessageEmbedded.DoubleEmbedded == nil {
			out.FNestedMessageEmbedded.DoubleEmbedded = &DoubleEmbeddedMessage{}
		}
		out.FNestedMessageEmbedded.DoubleEmbedded.DoubleEmbed = v.DoubleEmbed
	}
	out.FNestedMessageSerialized = cast.MessageFromSliceByte[*NestedMessage](v.FNestedMessageSerialized)
	out.FEnum = v.FEnum
	out.FAny = cast.MessageFromSliceByte[*anypb.Any](v.FAny)
	out.FTimestamp = cast.TimestampFromPtrTime(v.FTimestamp)
	out.FDuration = cast.DurationFromPtrTime(v.FDuration)
	out.FStruct = cast.StructFromMap(v.FStruct)
	out.FValue = cast.MessageFromSliceByte[*structpb.Value](v.FValue)
	out.FListValue = cast.MessageFromSliceByte[*structpb.ListValue](v.FListValue)
	out.FWktDouble = cast.DoubleValueFromPtrFloat64(v.FWktDouble)
	out.FWktFloat = cast.FloatValueFromPtrFloat32(v.FWktFloat)
	out.FWktInt64 = cast.Int64ValueFromPtrInt64(v.FWktInt64)
	out.FWktUint64 = cast.UInt64ValueFromPtrUint64(v.FWktUint64)
	out.FWktInt32 = cast.Int32ValueFromPtrInt32(v.FWktInt32)
	out.FWktUint32 = cast.UInt32ValueFromPtrUint32(v.FWktUint32)
	out.FWktBool = cast.BoolValueFromPtrBool(v.FWktBool)
	out.FWktString = cast.StringValueFromPtrString(v.FWktString)
	out.FWktBytes = cast.BytesValueFromPtrBytes(v.FWktBytes)
	out.FDoubleNested = v.FDoubleNested
	if v.FOneofInt32 != nil {
		out.FOneof = &TestMessage_FOneofInt32{FOneofInt32: *v.FOneofInt32}
	} else if v.FOneofString != nil {
		out.FOneof = &TestMessage_FOneofString{FOneofString: *v.FOneofString}
	} else if v.FOneofBytes != nil {
		out.FOneof = &TestMessage_FOneofBytes{FOneofBytes: *v.FOneofBytes}
	} else if v.FOneofMessage != nil {
		out.FOneof = &TestMessage_FOneofMessage{FOneofMessage: v.FOneofMessage}
	} else if v.FOneofEnum != nil {
		out.FOneof = &TestMessage_FOneofEnum{FOneofEnum: *v.FOneofEnum}
	}
	return out
}

func (v *TestMessagePlain) IntoPbDeep() *TestMessage {
	if v == nil {
		return nil
	}
	out := &TestMessage{}
	out.OidcId = &OidcIdAlias{Value: v.OidcId}
	out.Id = &IdAlias{Value: func(v uuid.UUID) string { return v.String() }(v.Id)}
	out.Embed = &EmbedWithAlias{}
	out.Embed.EmbedOidcId = &OidcIdAlias{Value: v.EmbedOidcId}
	out.Embed.EmbedId = &IdAlias{Value: func(v uuid.UUID) string { return v.String() }(v.EmbedId)}
	out.FDouble = v.FDouble
	out.FFloat = v.FFloat
	out.FInt32 = v.FInt32
	out.FInt64 = v.FInt64
	out.FUint32 = v.FUint32
	out.FUint64 = v.FUint64
	out.FSint32 = v.FSint32
	out.FSint64 = v.FSint64
	out.FFixed32 = v.FFixed32
	out.FFixed64 = v.FFixed64
	out.FSfixed32 = v.FSfixed32
	out.FSfixed64 = v.FSfixed64
	out.FBool = v.FBool
	out.FString = v.FString
	out.FUuid = func(v uuid.UUID) string { return v.String() }(v.FUuid)
	out.FBytes = append([]byte(nil), v.FBytes...)
	out.FOptInt32 = v.FOptInt32
	out.FOptString = v.FOptString
	out.FOptMessage = v.FOptMessage
	out.FOptEnum = v.FOptEnum
	if v.FRepInt32 != nil {
		for _, el := range v.FRepInt32 {
			out.FRepInt32 = append(out.FRepInt32, el)
		}
	}
	if v.FRepString != nil {
		for _, el := range v.FRepString {
			out.FRepString = append(out.FRepString, el)
		}
	}
	if v.FRepMessage != nil {
		for _, el := range v.FRepMessage {
			out.FRepMessage = append(out.FRepMessage, el)
		}
	}
	if v.FRepMessageSerialized != nil {
		for _, el := range v.FRepMessageSerialized {
			out.FRepMessageSerialized = append(out.FRepMessageSerialized, cast.MessageFromSliceByte[*NestedMessage](el))
		}
	}
	if v.FRepEnum != nil {
		for _, el := range v.FRepEnum {
			out.FRepEnum = append(out.FRepEnum, el)
		}
	}
	if v.FMapInt32String != nil {
		out.FMapInt32String = make(map[int32]string, len(v.FMapInt32String))
		for k, val := range v.FMapInt32String {
			out.FMapInt32String[k] = val
		}
	}
	if v.FMapInt64Int32 != nil {
		out.FMapInt64Int32 = make(map[int64]int32, len(v.FMapInt64Int32))
		for k, val := range v.FMapInt64Int32 {
			out.FMapInt64Int32[k] = val
		}
	}
	if v.FMapUint32Uint64 != nil {
		out.FMapUint32Uint64 = make(map[uint32]uint64, len(v.FMapUint32Uint64))
		for k, val := range v.FMapUint32Uint64 {
			out.FMapUint32Uint64[k] = val
		}
	}
	if v.FMapUint64Bool != nil {
		out.FMapUint64Bool = make(map[uint64]bool, len(v.FMapUint64Bool))
		for k, val := range v.FMapUint64Bool {
			out.FMapUint64Bool[k] = val
		}
	}
	if v.FMapSint32Bytes != nil {
		out.FMapSint32Bytes = make(map[int32][]byte, len(v.FMapSint32Bytes))
		for k, val := range v.FMapSint32Bytes {
			out.FMapSint32Bytes[k] = append([]byte(nil), val...)
		}
	}
	if v.FMapSint64Float != nil {
		out.FMapSint64Float = make(map[int64]float32, len(v.FMapSint64Float))
		for k, val := range v.FMapSint64Float {
			out.FMapSint64Float[k] = val
		}
	}
	if v.FMapFixed32Double != nil {
		out.FMapFixed32Double = make(map[uint32]float64, len(v.FMapFixed32Double))
		for k, val := range v.FMapFixed32Double {
			out.FMapFixed32Double[k] = val
		}
	}
	if v.FMapFixed64Message != nil {
		out.FMapFixed64Message = make(map[uint64]*NestedMessage, len(v.FMapFixed64Message))
		for k, val := range v.FMapFixed64Message {
			out.FMapFixed64Message[k] = val
		}
	}
	if v.FMapSfixed32Enum != nil {
		out.FMapSfixed32Enum = make(map[int32]TestEnum, len(v.FMapSfixed32Enum))
		for k, val := range v.FMapSfixed32Enum {
			out.FMapSfixed32Enum[k] = val
		}
	}
	if v.FMapSfixed64String != nil {
		out.FMapSfixed64String = make(map[int64]string, len(v.FMapSfixed64String))
		for k, val := range v.FMapSfixed64String {
			out.FMapSfixed64String[k] = val
		}
	}
	if v.FMapBoolInt32 != nil {
		out.FMapBoolInt32 = make(map[bool]int32, len(v.FMapBoolInt32))
		for k, val := range v.FMapBoolInt32 {
			out.FMapBoolInt32[k] = val
		}
	}
	if v.FMapStringString != nil {
		out.FMapStringString = make(map[string]string, len(v.FMapStringString))
		for k, val := range v.FMapStringString {
			out.FMapStringString[k] = val
		}
	}
	out.FNestedMessage = v.FNestedMessage
	out.FNestedMessageEmbedded = &NestedMessage{}
	out.FNestedMessageEmbedded.Name = v.Name
	out.FNestedMessageEmbedded.Inner = v.Inner
	if v.DoubleEmbed != "" {
		if out.FNestedMessageEmbedded.DoubleEmbedded == nil {
			out.FNestedMessageEmbedded.DoubleEmbedded = &DoubleEmbeddedMessage{}
		}
		out.FNestedMessageEmbedded.DoubleEmbedded.DoubleEmbed = v.DoubleEmbed
	}
	out.FNestedMessageSerialized = cast.MessageFromSliceByte[*NestedMessage](v.FNestedMessageSerialized)
	out.FEnum = v.FEnum
	out.FAny = cast.MessageFromSliceByte[*anypb.Any](v.FAny)
	out.FTimestamp = cast.TimestampFromPtrTime(v.FTimestamp)
	out.FDuration = cast.DurationFromPtrTime(v.FDuration)
	out.FStruct = cast.StructFromMap(v.FStruct)
	out.FValue = cast.MessageFromSliceByte[*structpb.Value](v.FValue)
	out.FListValue = cast.MessageFromSliceByte[*structpb.ListValue](v.FListValue)
	out.FWktDouble = cast.DoubleValueFromPtrFloat64(v.FWktDouble)
	out.FWktFloat = cast.FloatValueFromPtrFloat32(v.FWktFloat)
	out.FWktInt64 = cast.Int64ValueFromPtrInt64(v.FWktInt64)
	out.FWktUint64 = cast.UInt64ValueFromPtrUint64(v.FWktUint64)
	out.FWktInt32 = cast.Int32ValueFromPtrInt32(v.FWktInt32)
	out.FWktUint32 = cast.UInt32ValueFromPtrUint32(v.FWktUint32)
	out.FWktBool = cast.BoolValueFromPtrBool(v.FWktBool)
	out.FWktString = cast.StringValueFromPtrString(v.FWktString)
	out.FWktBytes = cast.BytesValueFromPtrBytes(v.FWktBytes)
	out.FDoubleNested = v.FDoubleNested
	if v.FOneofInt32 != nil {
		out.FOneof = &TestMessage_FOneofInt32{FOneofInt32: *v.FOneofInt32}
	} else if v.FOneofString != nil {
		out.FOneof = &TestMessage_FOneofString{FOneofString: *v.FOneofString}
	} else if v.FOneofBytes != nil {
		out.FOneof = &TestMessage_FOneofBytes{FOneofBytes: append([]byte(nil), *v.FOneofBytes...)}
	} else if v.FOneofMessage != nil {
		out.FOneof = &TestMessage_FOneofMessage{FOneofMessage: v.FOneofMessage}
	} else if v.FOneofEnum != nil {
		out.FOneof = &TestMessage_FOneofEnum{FOneofEnum: *v.FOneofEnum}
	}
	return out
}
