// Code generated by protoc-gen-go-plain. DO NOT EDIT.

package test

import (
	cast "github.com/yaroher/protoc-gen-go-plain/cast"
	anypb "google.golang.org/protobuf/types/known/anypb"
	structpb "google.golang.org/protobuf/types/known/structpb"
	time "time"
)

type TestMessagePlain struct {
	OidcId                   string
	Id                       string
	FDouble                  float64
	FFloat                   float32
	FInt32                   int32
	FInt64                   int64
	FUint32                  uint32
	FUint64                  uint64
	FSint32                  int32
	FSint64                  int64
	FFixed32                 uint32
	FFixed64                 uint64
	FSfixed32                int32
	FSfixed64                int64
	FBool                    bool
	FString                  string
	FBytes                   []byte
	FOptInt32                *int32
	FOptString               *string
	FOptMessage              *NestedMessage
	FRepInt32                []int32
	FRepString               []string
	FRepMessage              []*NestedMessage
	FRepEnum                 []TestEnum
	FMapInt32String          map[int32]string
	FMapInt64Int32           map[int64]int32
	FMapUint32Uint64         map[uint32]uint64
	FMapUint64Bool           map[uint64]bool
	FMapSint32Bytes          map[int32][]byte
	FMapSint64Float          map[int64]float32
	FMapFixed32Double        map[uint32]float64
	FMapFixed64Message       map[uint64]*NestedMessage
	FMapSfixed32Enum         map[int32]TestEnum
	FMapSfixed64String       map[int64]string
	FMapBoolInt32            map[bool]int32
	FMapStringString         map[string]string
	FOneofInt32              *int32
	FOneofString             *string
	FOneofBytes              *[]byte
	FOneofMessage            *NestedMessage
	FOneofEnum               *TestEnum
	FNestedMessage           *NestedMessage
	Name                     string
	Inner                    *NestedMessage_InnerMessage
	FNestedMessageSerialized []byte
	FEnum                    TestEnum
	FAny                     []byte
	FTimestamp               *time.Time
	FDuration                *time.Duration
	FStruct                  map[string]any
	FValue                   []byte
	FListValue               []byte
	FWktDouble               *float64
	FWktFloat                *float32
	FWktInt64                *int64
	FWktUint64               *uint64
	FWktInt32                *int32
	FWktUint32               *uint32
	FWktBool                 *bool
	FWktString               *string
	FWktBytes                *[]byte
	FDoubleNested            *NestedMessage_InnerMessage_InnerInnerMessage
}

func (v *TestMessage) IntoPlain() *TestMessagePlain {
	if v == nil {
		return nil
	}
	out := &TestMessagePlain{}
	out.OidcId = func() string {
		if v.OidcId == nil {
			var zero string
			return zero
		}
		val := v.OidcId.Value
		return val
	}()
	out.Id = func() string {
		if v.Id == nil {
			var zero string
			return zero
		}
		val := v.Id.Value
		return val
	}()
	out.FDouble = v.FDouble
	out.FFloat = v.FFloat
	out.FInt32 = v.FInt32
	out.FInt64 = v.FInt64
	out.FUint32 = v.FUint32
	out.FUint64 = v.FUint64
	out.FSint32 = v.FSint32
	out.FSint64 = v.FSint64
	out.FFixed32 = v.FFixed32
	out.FFixed64 = v.FFixed64
	out.FSfixed32 = v.FSfixed32
	out.FSfixed64 = v.FSfixed64
	out.FBool = v.FBool
	out.FString = v.FString
	out.FBytes = v.FBytes
	out.FOptInt32 = v.FOptInt32
	out.FOptString = v.FOptString
	out.FOptMessage = v.FOptMessage
	out.FRepInt32 = v.FRepInt32
	out.FRepString = v.FRepString
	out.FRepMessage = v.FRepMessage
	out.FRepEnum = v.FRepEnum
	out.FMapInt32String = v.FMapInt32String
	out.FMapInt64Int32 = v.FMapInt64Int32
	out.FMapUint32Uint64 = v.FMapUint32Uint64
	out.FMapUint64Bool = v.FMapUint64Bool
	out.FMapSint32Bytes = v.FMapSint32Bytes
	out.FMapSint64Float = v.FMapSint64Float
	out.FMapFixed32Double = v.FMapFixed32Double
	out.FMapFixed64Message = v.FMapFixed64Message
	out.FMapSfixed32Enum = v.FMapSfixed32Enum
	out.FMapSfixed64String = v.FMapSfixed64String
	out.FMapBoolInt32 = v.FMapBoolInt32
	out.FMapStringString = v.FMapStringString
	out.FNestedMessage = v.FNestedMessage
	if v.FNestedMessageEmbedded != nil {
		out.Name = v.FNestedMessageEmbedded.Name
		out.Inner = v.FNestedMessageEmbedded.Inner
	}
	out.FNestedMessageSerialized = cast.MessageToSliceByte(v.FNestedMessageSerialized)
	out.FEnum = v.FEnum
	out.FAny = cast.MessageToSliceByte(v.FAny)
	out.FTimestamp = cast.TimestampToPtrTime(v.FTimestamp)
	out.FDuration = cast.DurationToPtrTime(v.FDuration)
	out.FStruct = cast.StructToMap(v.FStruct)
	out.FValue = cast.MessageToSliceByte(v.FValue)
	out.FListValue = cast.MessageToSliceByte(v.FListValue)
	out.FWktDouble = cast.DoubleValueToPtrFloat64(v.FWktDouble)
	out.FWktFloat = cast.FloatValueToPtrFloat32(v.FWktFloat)
	out.FWktInt64 = cast.Int64ValueToPtrInt64(v.FWktInt64)
	out.FWktUint64 = cast.UInt64ValueToPtrUint64(v.FWktUint64)
	out.FWktInt32 = cast.Int32ValueToPtrInt32(v.FWktInt32)
	out.FWktUint32 = cast.UInt32ValueToPtrUint32(v.FWktUint32)
	out.FWktBool = cast.BoolValueToPtrBool(v.FWktBool)
	out.FWktString = cast.StringValueToPtrString(v.FWktString)
	out.FWktBytes = cast.BytesValueToPtrBytes(v.FWktBytes)
	out.FDoubleNested = v.FDoubleNested
	switch t := v.FOneof.(type) {
	case *TestMessage_FOneofInt32:
		val := t.FOneofInt32
		out.FOneofInt32 = &val
	case *TestMessage_FOneofString:
		val := t.FOneofString
		out.FOneofString = &val
	case *TestMessage_FOneofBytes:
		val := t.FOneofBytes
		out.FOneofBytes = &val
	case *TestMessage_FOneofMessage:
		out.FOneofMessage = t.FOneofMessage
	case *TestMessage_FOneofEnum:
		val := t.FOneofEnum
		out.FOneofEnum = &val
	}
	return out
}

func (v *TestMessage) IntoPlainDeep() *TestMessagePlain {
	if v == nil {
		return nil
	}
	out := &TestMessagePlain{}
	out.OidcId = func() string {
		if v.OidcId == nil {
			var zero string
			return zero
		}
		val := v.OidcId.Value
		return val
	}()
	out.Id = func() string {
		if v.Id == nil {
			var zero string
			return zero
		}
		val := v.Id.Value
		return val
	}()
	out.FDouble = v.FDouble
	out.FFloat = v.FFloat
	out.FInt32 = v.FInt32
	out.FInt64 = v.FInt64
	out.FUint32 = v.FUint32
	out.FUint64 = v.FUint64
	out.FSint32 = v.FSint32
	out.FSint64 = v.FSint64
	out.FFixed32 = v.FFixed32
	out.FFixed64 = v.FFixed64
	out.FSfixed32 = v.FSfixed32
	out.FSfixed64 = v.FSfixed64
	out.FBool = v.FBool
	out.FString = v.FString
	out.FBytes = append([]byte(nil), v.FBytes...)
	out.FOptInt32 = v.FOptInt32
	out.FOptString = v.FOptString
	out.FOptMessage = v.FOptMessage
	if v.FRepInt32 != nil {
		for _, el := range v.FRepInt32 {
			out.FRepInt32 = append(out.FRepInt32, el)
		}
	}
	if v.FRepString != nil {
		for _, el := range v.FRepString {
			out.FRepString = append(out.FRepString, el)
		}
	}
	if v.FRepMessage != nil {
		for _, el := range v.FRepMessage {
			out.FRepMessage = append(out.FRepMessage, el)
		}
	}
	if v.FRepEnum != nil {
		for _, el := range v.FRepEnum {
			out.FRepEnum = append(out.FRepEnum, el)
		}
	}
	if v.FMapInt32String != nil {
		out.FMapInt32String = make(map[int32]string, len(v.FMapInt32String))
		for k, val := range v.FMapInt32String {
			out.FMapInt32String[k] = val
		}
	}
	if v.FMapInt64Int32 != nil {
		out.FMapInt64Int32 = make(map[int64]int32, len(v.FMapInt64Int32))
		for k, val := range v.FMapInt64Int32 {
			out.FMapInt64Int32[k] = val
		}
	}
	if v.FMapUint32Uint64 != nil {
		out.FMapUint32Uint64 = make(map[uint32]uint64, len(v.FMapUint32Uint64))
		for k, val := range v.FMapUint32Uint64 {
			out.FMapUint32Uint64[k] = val
		}
	}
	if v.FMapUint64Bool != nil {
		out.FMapUint64Bool = make(map[uint64]bool, len(v.FMapUint64Bool))
		for k, val := range v.FMapUint64Bool {
			out.FMapUint64Bool[k] = val
		}
	}
	if v.FMapSint32Bytes != nil {
		out.FMapSint32Bytes = make(map[int32][]byte, len(v.FMapSint32Bytes))
		for k, val := range v.FMapSint32Bytes {
			out.FMapSint32Bytes[k] = append([]byte(nil), val...)
		}
	}
	if v.FMapSint64Float != nil {
		out.FMapSint64Float = make(map[int64]float32, len(v.FMapSint64Float))
		for k, val := range v.FMapSint64Float {
			out.FMapSint64Float[k] = val
		}
	}
	if v.FMapFixed32Double != nil {
		out.FMapFixed32Double = make(map[uint32]float64, len(v.FMapFixed32Double))
		for k, val := range v.FMapFixed32Double {
			out.FMapFixed32Double[k] = val
		}
	}
	if v.FMapFixed64Message != nil {
		out.FMapFixed64Message = make(map[uint64]*NestedMessage, len(v.FMapFixed64Message))
		for k, val := range v.FMapFixed64Message {
			out.FMapFixed64Message[k] = val
		}
	}
	if v.FMapSfixed32Enum != nil {
		out.FMapSfixed32Enum = make(map[int32]TestEnum, len(v.FMapSfixed32Enum))
		for k, val := range v.FMapSfixed32Enum {
			out.FMapSfixed32Enum[k] = val
		}
	}
	if v.FMapSfixed64String != nil {
		out.FMapSfixed64String = make(map[int64]string, len(v.FMapSfixed64String))
		for k, val := range v.FMapSfixed64String {
			out.FMapSfixed64String[k] = val
		}
	}
	if v.FMapBoolInt32 != nil {
		out.FMapBoolInt32 = make(map[bool]int32, len(v.FMapBoolInt32))
		for k, val := range v.FMapBoolInt32 {
			out.FMapBoolInt32[k] = val
		}
	}
	if v.FMapStringString != nil {
		out.FMapStringString = make(map[string]string, len(v.FMapStringString))
		for k, val := range v.FMapStringString {
			out.FMapStringString[k] = val
		}
	}
	out.FNestedMessage = v.FNestedMessage
	if v.FNestedMessageEmbedded != nil {
		out.Name = v.FNestedMessageEmbedded.Name
		out.Inner = v.FNestedMessageEmbedded.Inner
	}
	out.FNestedMessageSerialized = cast.MessageToSliceByte(v.FNestedMessageSerialized)
	out.FEnum = v.FEnum
	out.FAny = cast.MessageToSliceByte(v.FAny)
	out.FTimestamp = cast.TimestampToPtrTime(v.FTimestamp)
	out.FDuration = cast.DurationToPtrTime(v.FDuration)
	out.FStruct = cast.StructToMap(v.FStruct)
	out.FValue = cast.MessageToSliceByte(v.FValue)
	out.FListValue = cast.MessageToSliceByte(v.FListValue)
	out.FWktDouble = cast.DoubleValueToPtrFloat64(v.FWktDouble)
	out.FWktFloat = cast.FloatValueToPtrFloat32(v.FWktFloat)
	out.FWktInt64 = cast.Int64ValueToPtrInt64(v.FWktInt64)
	out.FWktUint64 = cast.UInt64ValueToPtrUint64(v.FWktUint64)
	out.FWktInt32 = cast.Int32ValueToPtrInt32(v.FWktInt32)
	out.FWktUint32 = cast.UInt32ValueToPtrUint32(v.FWktUint32)
	out.FWktBool = cast.BoolValueToPtrBool(v.FWktBool)
	out.FWktString = cast.StringValueToPtrString(v.FWktString)
	out.FWktBytes = cast.BytesValueToPtrBytes(v.FWktBytes)
	out.FDoubleNested = v.FDoubleNested
	switch t := v.FOneof.(type) {
	case *TestMessage_FOneofInt32:
		val := t.FOneofInt32
		out.FOneofInt32 = &val
	case *TestMessage_FOneofString:
		val := t.FOneofString
		out.FOneofString = &val
	case *TestMessage_FOneofBytes:
		val := append([]byte(nil), t.FOneofBytes...)
		out.FOneofBytes = &val
	case *TestMessage_FOneofMessage:
		out.FOneofMessage = t.FOneofMessage
	case *TestMessage_FOneofEnum:
		val := t.FOneofEnum
		out.FOneofEnum = &val
	}
	return out
}

func (v *TestMessagePlain) IntoPb() *TestMessage {
	if v == nil {
		return nil
	}
	out := &TestMessage{}
	out.OidcId = &OidcIdAlias{Value: v.OidcId}
	out.Id = &IdAlias{Value: v.Id}
	out.FDouble = v.FDouble
	out.FFloat = v.FFloat
	out.FInt32 = v.FInt32
	out.FInt64 = v.FInt64
	out.FUint32 = v.FUint32
	out.FUint64 = v.FUint64
	out.FSint32 = v.FSint32
	out.FSint64 = v.FSint64
	out.FFixed32 = v.FFixed32
	out.FFixed64 = v.FFixed64
	out.FSfixed32 = v.FSfixed32
	out.FSfixed64 = v.FSfixed64
	out.FBool = v.FBool
	out.FString = v.FString
	out.FBytes = v.FBytes
	out.FOptInt32 = v.FOptInt32
	out.FOptString = v.FOptString
	out.FOptMessage = v.FOptMessage
	out.FRepInt32 = v.FRepInt32
	out.FRepString = v.FRepString
	out.FRepMessage = v.FRepMessage
	out.FRepEnum = v.FRepEnum
	out.FMapInt32String = v.FMapInt32String
	out.FMapInt64Int32 = v.FMapInt64Int32
	out.FMapUint32Uint64 = v.FMapUint32Uint64
	out.FMapUint64Bool = v.FMapUint64Bool
	out.FMapSint32Bytes = v.FMapSint32Bytes
	out.FMapSint64Float = v.FMapSint64Float
	out.FMapFixed32Double = v.FMapFixed32Double
	out.FMapFixed64Message = v.FMapFixed64Message
	out.FMapSfixed32Enum = v.FMapSfixed32Enum
	out.FMapSfixed64String = v.FMapSfixed64String
	out.FMapBoolInt32 = v.FMapBoolInt32
	out.FMapStringString = v.FMapStringString
	out.FNestedMessage = v.FNestedMessage
	out.FNestedMessageEmbedded = &NestedMessage{}
	out.FNestedMessageEmbedded.Name = v.Name
	out.FNestedMessageEmbedded.Inner = v.Inner
	out.FNestedMessageSerialized = cast.MessageFromSliceByte[*NestedMessage](v.FNestedMessageSerialized)
	out.FEnum = v.FEnum
	out.FAny = cast.MessageFromSliceByte[*anypb.Any](v.FAny)
	out.FTimestamp = cast.TimestampFromPtrTime(v.FTimestamp)
	out.FDuration = cast.DurationFromPtrTime(v.FDuration)
	out.FStruct = cast.StructFromMap(v.FStruct)
	out.FValue = cast.MessageFromSliceByte[*structpb.Value](v.FValue)
	out.FListValue = cast.MessageFromSliceByte[*structpb.ListValue](v.FListValue)
	out.FWktDouble = cast.DoubleValueFromPtrFloat64(v.FWktDouble)
	out.FWktFloat = cast.FloatValueFromPtrFloat32(v.FWktFloat)
	out.FWktInt64 = cast.Int64ValueFromPtrInt64(v.FWktInt64)
	out.FWktUint64 = cast.UInt64ValueFromPtrUint64(v.FWktUint64)
	out.FWktInt32 = cast.Int32ValueFromPtrInt32(v.FWktInt32)
	out.FWktUint32 = cast.UInt32ValueFromPtrUint32(v.FWktUint32)
	out.FWktBool = cast.BoolValueFromPtrBool(v.FWktBool)
	out.FWktString = cast.StringValueFromPtrString(v.FWktString)
	out.FWktBytes = cast.BytesValueFromPtrBytes(v.FWktBytes)
	out.FDoubleNested = v.FDoubleNested
	if v.FOneofInt32 != nil {
		out.FOneof = &TestMessage_FOneofInt32{FOneofInt32: *v.FOneofInt32}
	} else if v.FOneofString != nil {
		out.FOneof = &TestMessage_FOneofString{FOneofString: *v.FOneofString}
	} else if v.FOneofBytes != nil {
		out.FOneof = &TestMessage_FOneofBytes{FOneofBytes: *v.FOneofBytes}
	} else if v.FOneofMessage != nil {
		out.FOneof = &TestMessage_FOneofMessage{FOneofMessage: v.FOneofMessage}
	} else if v.FOneofEnum != nil {
		out.FOneof = &TestMessage_FOneofEnum{FOneofEnum: *v.FOneofEnum}
	}
	return out
}

func (v *TestMessagePlain) IntoPbDeep() *TestMessage {
	if v == nil {
		return nil
	}
	out := &TestMessage{}
	out.OidcId = &OidcIdAlias{Value: v.OidcId}
	out.Id = &IdAlias{Value: v.Id}
	out.FDouble = v.FDouble
	out.FFloat = v.FFloat
	out.FInt32 = v.FInt32
	out.FInt64 = v.FInt64
	out.FUint32 = v.FUint32
	out.FUint64 = v.FUint64
	out.FSint32 = v.FSint32
	out.FSint64 = v.FSint64
	out.FFixed32 = v.FFixed32
	out.FFixed64 = v.FFixed64
	out.FSfixed32 = v.FSfixed32
	out.FSfixed64 = v.FSfixed64
	out.FBool = v.FBool
	out.FString = v.FString
	out.FBytes = append([]byte(nil), v.FBytes...)
	out.FOptInt32 = v.FOptInt32
	out.FOptString = v.FOptString
	out.FOptMessage = v.FOptMessage
	if v.FRepInt32 != nil {
		for _, el := range v.FRepInt32 {
			out.FRepInt32 = append(out.FRepInt32, el)
		}
	}
	if v.FRepString != nil {
		for _, el := range v.FRepString {
			out.FRepString = append(out.FRepString, el)
		}
	}
	if v.FRepMessage != nil {
		for _, el := range v.FRepMessage {
			out.FRepMessage = append(out.FRepMessage, el)
		}
	}
	if v.FRepEnum != nil {
		for _, el := range v.FRepEnum {
			out.FRepEnum = append(out.FRepEnum, el)
		}
	}
	if v.FMapInt32String != nil {
		out.FMapInt32String = make(map[int32]string, len(v.FMapInt32String))
		for k, val := range v.FMapInt32String {
			out.FMapInt32String[k] = val
		}
	}
	if v.FMapInt64Int32 != nil {
		out.FMapInt64Int32 = make(map[int64]int32, len(v.FMapInt64Int32))
		for k, val := range v.FMapInt64Int32 {
			out.FMapInt64Int32[k] = val
		}
	}
	if v.FMapUint32Uint64 != nil {
		out.FMapUint32Uint64 = make(map[uint32]uint64, len(v.FMapUint32Uint64))
		for k, val := range v.FMapUint32Uint64 {
			out.FMapUint32Uint64[k] = val
		}
	}
	if v.FMapUint64Bool != nil {
		out.FMapUint64Bool = make(map[uint64]bool, len(v.FMapUint64Bool))
		for k, val := range v.FMapUint64Bool {
			out.FMapUint64Bool[k] = val
		}
	}
	if v.FMapSint32Bytes != nil {
		out.FMapSint32Bytes = make(map[int32][]byte, len(v.FMapSint32Bytes))
		for k, val := range v.FMapSint32Bytes {
			out.FMapSint32Bytes[k] = append([]byte(nil), val...)
		}
	}
	if v.FMapSint64Float != nil {
		out.FMapSint64Float = make(map[int64]float32, len(v.FMapSint64Float))
		for k, val := range v.FMapSint64Float {
			out.FMapSint64Float[k] = val
		}
	}
	if v.FMapFixed32Double != nil {
		out.FMapFixed32Double = make(map[uint32]float64, len(v.FMapFixed32Double))
		for k, val := range v.FMapFixed32Double {
			out.FMapFixed32Double[k] = val
		}
	}
	if v.FMapFixed64Message != nil {
		out.FMapFixed64Message = make(map[uint64]*NestedMessage, len(v.FMapFixed64Message))
		for k, val := range v.FMapFixed64Message {
			out.FMapFixed64Message[k] = val
		}
	}
	if v.FMapSfixed32Enum != nil {
		out.FMapSfixed32Enum = make(map[int32]TestEnum, len(v.FMapSfixed32Enum))
		for k, val := range v.FMapSfixed32Enum {
			out.FMapSfixed32Enum[k] = val
		}
	}
	if v.FMapSfixed64String != nil {
		out.FMapSfixed64String = make(map[int64]string, len(v.FMapSfixed64String))
		for k, val := range v.FMapSfixed64String {
			out.FMapSfixed64String[k] = val
		}
	}
	if v.FMapBoolInt32 != nil {
		out.FMapBoolInt32 = make(map[bool]int32, len(v.FMapBoolInt32))
		for k, val := range v.FMapBoolInt32 {
			out.FMapBoolInt32[k] = val
		}
	}
	if v.FMapStringString != nil {
		out.FMapStringString = make(map[string]string, len(v.FMapStringString))
		for k, val := range v.FMapStringString {
			out.FMapStringString[k] = val
		}
	}
	out.FNestedMessage = v.FNestedMessage
	out.FNestedMessageEmbedded = &NestedMessage{}
	out.FNestedMessageEmbedded.Name = v.Name
	out.FNestedMessageEmbedded.Inner = v.Inner
	out.FNestedMessageSerialized = cast.MessageFromSliceByte[*NestedMessage](v.FNestedMessageSerialized)
	out.FEnum = v.FEnum
	out.FAny = cast.MessageFromSliceByte[*anypb.Any](v.FAny)
	out.FTimestamp = cast.TimestampFromPtrTime(v.FTimestamp)
	out.FDuration = cast.DurationFromPtrTime(v.FDuration)
	out.FStruct = cast.StructFromMap(v.FStruct)
	out.FValue = cast.MessageFromSliceByte[*structpb.Value](v.FValue)
	out.FListValue = cast.MessageFromSliceByte[*structpb.ListValue](v.FListValue)
	out.FWktDouble = cast.DoubleValueFromPtrFloat64(v.FWktDouble)
	out.FWktFloat = cast.FloatValueFromPtrFloat32(v.FWktFloat)
	out.FWktInt64 = cast.Int64ValueFromPtrInt64(v.FWktInt64)
	out.FWktUint64 = cast.UInt64ValueFromPtrUint64(v.FWktUint64)
	out.FWktInt32 = cast.Int32ValueFromPtrInt32(v.FWktInt32)
	out.FWktUint32 = cast.UInt32ValueFromPtrUint32(v.FWktUint32)
	out.FWktBool = cast.BoolValueFromPtrBool(v.FWktBool)
	out.FWktString = cast.StringValueFromPtrString(v.FWktString)
	out.FWktBytes = cast.BytesValueFromPtrBytes(v.FWktBytes)
	out.FDoubleNested = v.FDoubleNested
	if v.FOneofInt32 != nil {
		out.FOneof = &TestMessage_FOneofInt32{FOneofInt32: *v.FOneofInt32}
	} else if v.FOneofString != nil {
		out.FOneof = &TestMessage_FOneofString{FOneofString: *v.FOneofString}
	} else if v.FOneofBytes != nil {
		out.FOneof = &TestMessage_FOneofBytes{FOneofBytes: append([]byte(nil), *v.FOneofBytes...)}
	} else if v.FOneofMessage != nil {
		out.FOneof = &TestMessage_FOneofMessage{FOneofMessage: v.FOneofMessage}
	} else if v.FOneofEnum != nil {
		out.FOneof = &TestMessage_FOneofEnum{FOneofEnum: *v.FOneofEnum}
	}
	return out
}
