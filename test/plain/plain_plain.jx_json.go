// Code generated by protoc-gen-go-plain. DO NOT EDIT.

package plain

import (
	"fmt"
	"github.com/go-faster/jx"
)

func jxEncodeError(field string) error {
	return fmt.Errorf("jx: encode %s", field)
}
func jxDecodeError(field string, err error) error {
	return fmt.Errorf("jx: decode %s: %w", field, err)
}

func (x *BaseInfoPlain) MarshalJSON() ([]byte, error) {
	if x == nil {
		return []byte("null"), nil
	}
	e := jx.GetEncoder()
	defer jx.PutEncoder(e)
	if e.ObjStart() {
		return nil, jxEncodeError("BaseInfoPlain")
	}
	if e.FieldStart("id") {
		return nil, jxEncodeError("id")
	}
	e.Str(x.Id)
	if e.FieldStart("source") {
		return nil, jxEncodeError("source")
	}
	e.Str(x.Source)
	if e.ObjEnd() {
		return nil, jxEncodeError("BaseInfoPlain")
	}
	buf := append([]byte(nil), e.Bytes()...)
	return buf, nil
}

func (x *BaseInfoPlain) UnmarshalJSON(data []byte) error {
	if x == nil {
		return fmt.Errorf("jx: nil receiver")
	}
	d := jx.DecodeBytes(data)
	return d.Obj(func(d *jx.Decoder, key string) error {
		switch key {
		case "id":
			val, err := (*jx.Decoder).Str(d)
			if err != nil {
				return jxDecodeError("Id", err)
			}
			x.Id = val
			return nil
		case "source":
			val, err := (*jx.Decoder).Str(d)
			if err != nil {
				return jxDecodeError("Source", err)
			}
			x.Source = val
			return nil
		default:
			return d.Skip()
		}
	})
}

func (x *UserPlain) MarshalJSON() ([]byte, error) {
	if x == nil {
		return []byte("null"), nil
	}
	e := jx.GetEncoder()
	defer jx.PutEncoder(e)
	if e.ObjStart() {
		return nil, jxEncodeError("UserPlain")
	}
	if e.FieldStart("id") {
		return nil, jxEncodeError("id")
	}
	e.Str(x.Id)
	if e.FieldStart("source") {
		return nil, jxEncodeError("source")
	}
	e.Str(x.Source)
	if e.FieldStart("name") {
		return nil, jxEncodeError("name")
	}
	e.Str(x.Name)
	if x.ContactEmail != nil {
		if e.FieldStart("contactEmail") {
			return nil, jxEncodeError("contactEmail")
		}
		if x.ContactEmail == nil {
			e.Null()
		} else {
			e.Str(*x.ContactEmail)
		}
	}
	if x.ContactPhone != nil {
		if e.FieldStart("contactPhone") {
			return nil, jxEncodeError("contactPhone")
		}
		if x.ContactPhone == nil {
			e.Null()
		} else {
			e.Str(*x.ContactPhone)
		}
	}
	if e.ObjEnd() {
		return nil, jxEncodeError("UserPlain")
	}
	buf := append([]byte(nil), e.Bytes()...)
	return buf, nil
}

func (x *UserPlain) UnmarshalJSON(data []byte) error {
	if x == nil {
		return fmt.Errorf("jx: nil receiver")
	}
	d := jx.DecodeBytes(data)
	return d.Obj(func(d *jx.Decoder, key string) error {
		switch key {
		case "id":
			val, err := (*jx.Decoder).Str(d)
			if err != nil {
				return jxDecodeError("Id", err)
			}
			x.Id = val
			return nil
		case "source":
			val, err := (*jx.Decoder).Str(d)
			if err != nil {
				return jxDecodeError("Source", err)
			}
			x.Source = val
			return nil
		case "name":
			val, err := (*jx.Decoder).Str(d)
			if err != nil {
				return jxDecodeError("Name", err)
			}
			x.Name = val
			return nil
		case "contactEmail":
			if d.Next() == jx.Null {
				if err := d.Null(); err != nil {
					return jxDecodeError("ContactEmail", err)
				}
				x.ContactEmail = nil
				return nil
			}
			val, err := (*jx.Decoder).Str(d)
			if err != nil {
				return jxDecodeError("ContactEmail", err)
			}
			x.ContactEmail = &val
			return nil
		case "contactPhone":
			if d.Next() == jx.Null {
				if err := d.Null(); err != nil {
					return jxDecodeError("ContactPhone", err)
				}
				x.ContactPhone = nil
				return nil
			}
			val, err := (*jx.Decoder).Str(d)
			if err != nil {
				return jxDecodeError("ContactPhone", err)
			}
			x.ContactPhone = &val
			return nil
		default:
			return d.Skip()
		}
	})
}

func (x *UserEventPlain) MarshalJSON() ([]byte, error) {
	if x == nil {
		return []byte("null"), nil
	}
	e := jx.GetEncoder()
	defer jx.PutEncoder(e)
	if e.ObjStart() {
		return nil, jxEncodeError("UserEventPlain")
	}
	if e.FieldStart("source") {
		return nil, jxEncodeError("source")
	}
	e.Str(x.Source)
	if e.FieldStart("name") {
		return nil, jxEncodeError("name")
	}
	e.Str(x.Name)
	if x.ContactEmail != nil {
		if e.FieldStart("contactEmail") {
			return nil, jxEncodeError("contactEmail")
		}
		if x.ContactEmail == nil {
			e.Null()
		} else {
			e.Str(*x.ContactEmail)
		}
	}
	if x.ContactPhone != nil {
		if e.FieldStart("contactPhone") {
			return nil, jxEncodeError("contactPhone")
		}
		if x.ContactPhone == nil {
			e.Null()
		} else {
			e.Str(*x.ContactPhone)
		}
	}
	if e.FieldStart("eventType") {
		return nil, jxEncodeError("eventType")
	}
	e.Str(x.EventType)
	if e.FieldStart("id") {
		return nil, jxEncodeError("id")
	}
	e.Str(x.Id)
	if e.ObjEnd() {
		return nil, jxEncodeError("UserEventPlain")
	}
	buf := append([]byte(nil), e.Bytes()...)
	return buf, nil
}

func (x *UserEventPlain) UnmarshalJSON(data []byte) error {
	if x == nil {
		return fmt.Errorf("jx: nil receiver")
	}
	d := jx.DecodeBytes(data)
	return d.Obj(func(d *jx.Decoder, key string) error {
		switch key {
		case "source":
			val, err := (*jx.Decoder).Str(d)
			if err != nil {
				return jxDecodeError("Source", err)
			}
			x.Source = val
			return nil
		case "name":
			val, err := (*jx.Decoder).Str(d)
			if err != nil {
				return jxDecodeError("Name", err)
			}
			x.Name = val
			return nil
		case "contactEmail":
			if d.Next() == jx.Null {
				if err := d.Null(); err != nil {
					return jxDecodeError("ContactEmail", err)
				}
				x.ContactEmail = nil
				return nil
			}
			val, err := (*jx.Decoder).Str(d)
			if err != nil {
				return jxDecodeError("ContactEmail", err)
			}
			x.ContactEmail = &val
			return nil
		case "contactPhone":
			if d.Next() == jx.Null {
				if err := d.Null(); err != nil {
					return jxDecodeError("ContactPhone", err)
				}
				x.ContactPhone = nil
				return nil
			}
			val, err := (*jx.Decoder).Str(d)
			if err != nil {
				return jxDecodeError("ContactPhone", err)
			}
			x.ContactPhone = &val
			return nil
		case "eventType":
			val, err := (*jx.Decoder).Str(d)
			if err != nil {
				return jxDecodeError("EventType", err)
			}
			x.EventType = val
			return nil
		case "id":
			val, err := (*jx.Decoder).Str(d)
			if err != nil {
				return jxDecodeError("Id", err)
			}
			x.Id = val
			return nil
		default:
			return d.Skip()
		}
	})
}
